<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –î–æ–º–∏–∫ - –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç—å</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        #controls h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }

        #controls p {
            margin: 5px 0;
            color: #666;
            font-size: 12px;
        }

        .key {
            display: inline-block;
            background: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 0 2px;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px; /* Reduced padding */
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-width: 250px;
            display: flex; /* Use flexbox for button alignment */
            flex-direction: column; /* Stack items vertically */
            align-items: flex-start; /* Align items to the start */
        }

        #info h3 { 
            margin: 0 0 0px 0; 
            color: #333;
            font-size: 16px;
        }

        #info p {
            margin: 5px 0;
            color: #666;
            font-size: 12px;
            line-height: 1.4;
        }

        #toggleDayNightButton {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            padding: 5px 10px; /* Reduced padding for the button */
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 24px; /* Increased font size for emoji */
            margin-top: 5px; /* Reduced top margin */
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: auto; /* Automatic width */
            height: auto; /* Automatic height */
            line-height: 1; /* Removed extra line height */
        }

        #toggleDayNightButton:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>üè† –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
            <p>üñ±Ô∏è –ú—ã—à—å: –ø–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</p>
            <p>üîÑ –ö–æ–ª–µ—Å–æ: –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ</p>
            <p>üö∂ <span class="key">WASD</span> –∏–ª–∏ <span class="key">‚Üë‚Üì‚Üê‚Üí</span>: –¥–≤–∏–∂–µ–Ω–∏–µ</p>
            <p>üèÉ <span class="key">Shift</span>: –±–µ–≥</p>
        </div>

        <div id="info">
            <button id="toggleDayNightButton">‚òÄÔ∏è</button> 
        </div>
    </div>

    <script>
        // Global variables for the scene
        let scene, camera, renderer, house, particles = [], player;
        let isMouseDown = false, mouseX = 0, mouseY = 0;
        let cameraAngleX = 0.3, cameraAngleY = 0;
        let cameraDistance = 40; // Increased initial camera distance for larger world
        let isDayTime = true;
        let keys = {};
        let playerPosition = new THREE.Vector3(-10, 0.8, 0); 
        let playerRotation = 0;
        let walkAnimation = 0;
        let windowLights = []; 
        let fish = []; 
        let rabbits = []; // Array to hold rabbit objects
        let clouds = []; // Array to hold cloud objects

        let transitionProgress = 1; 
        let transitionSpeed = 0.02; 
        let targetTransitionProgress = 1; 

        // Day and Night settings for lighting and fog
        const daySettings = {
            fogColor: 0xA0D0FF, // Light blue fog
            clearColor: 0xA0D0FF, // Sky blue clear color
            ambientIntensity: 0.4, // Moderate ambient light
            directionalColor: 0xffffff, // White sunlight
            directionalIntensity: 0.8, // Strong sunlight
            directionalPosition: new THREE.Vector3(10, 15, 10), // Sun position
            hemisphereSkyColor: 0xC0E0FF, // Light blue sky for hemisphere
            hemisphereGroundColor: 0xA9D9A9, // Light green ground for hemisphere
            hemisphereIntensity: 0.6, // Moderate hemisphere light
            windowLightIntensity: 0.0 // Windows off during day
        };

        const nightSettings = {
            fogColor: 0x101040, // Dark blue/purple fog
            clearColor: 0x101040, // Dark blue/purple clear color
            ambientIntensity: 0.25, // Dim ambient light
            directionalColor: 0x404080, // Bluish moonlight
            directionalIntensity: 0.3, // Dim moonlight
            directionalPosition: new THREE.Vector3(-10, 15, -10), // Moon position
            hemisphereSkyColor: 0x202050, // Dark blue sky for hemisphere
            hemisphereGroundColor: 0x101010, // Very dark ground for hemisphere
            hemisphereIntensity: 0.2, // Very dim hemisphere light
            windowLightIntensity: 2.0 // Windows on during night
        };

        const textureLoader = new THREE.TextureLoader();

        // --- Helper Functions (defined before init for proper scope) ---

        /**
         * Creates the main house model with walls, roof, door, handle, windows, and chimney.
         */
        function createHouse() {
            house = new THREE.Group();

            // Load brick texture for walls
            const brickTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg',
                function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
                    texture.repeat.set(2, 2); 
                    wallMaterial.map = texture; 
                    wallMaterial.needsUpdate = true; 
                },
                undefined,
                function (err) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ–∫—Å—Ç—É—Ä—ã –∫–∏—Ä–ø–∏—á–∞:', err);
                    wallMaterial.color.set(0x8B4513); // Fallback color if texture fails
                    wallMaterial.needsUpdate = true;
                }
            );

            // Walls
            const wallGeometry = new THREE.BoxGeometry(4, 3, 4); 
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 0.8, metalness: 0.1 });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 1.5;
            walls.castShadow = true;
            walls.receiveShadow = true;
            house.add(walls);

            // Roof
            const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4, 8); // Increased segments for smoother cone
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.7, metalness: 0.0 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 4;
            roof.rotation.y = Math.PI / 4; 
            roof.castShadow = true;
            house.add(roof);

            // Door
            const doorGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.1);
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.6, metalness: 0.0 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.9, 2.05); 
            door.castShadow = true;
            house.add(door);

            // Door handle
            const handleGeometry = new THREE.SphereGeometry(0.05, 16, 16); // Increased segments for smoother sphere
            const handleMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3, metalness: 0.8 });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(-0.3, 0.9, 2.1);
            handle.castShadow = true;
            house.add(handle);

            // Windows
            const windowGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.1);
            const windowMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.7, roughness: 0.2, metalness: 0.1 });
            
            // Front window
            const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow.position.set(1.2, 1.8, 2.05); 
            frontWindow.castShadow = true;
            house.add(frontWindow);
            // Point light for the front window
            windowLights = []; 
            const frontWindowLight = new THREE.PointLight(0xFFE0B2, daySettings.windowLightIntensity, 5); 
            frontWindowLight.position.set(1.2, 1.8, 1.95); 
            frontWindowLight.castShadow = true;
            house.add(frontWindowLight);
            windowLights.push(frontWindowLight); 

            // Side window
            const sideWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            sideWindow.position.set(2.05, 1.8, 0); 
            sideWindow.rotation.y = Math.PI / 2; 
            sideWindow.castShadow = true;
            house.add(sideWindow);
            // Point light for the side window
            const sideWindowLight = new THREE.PointLight(0xFFE0B2, daySettings.windowLightIntensity, 5); 
            sideWindowLight.position.set(1.95, 1.8, 0); 
            sideWindowLight.castShadow = true;
            house.add(sideWindowLight);
            windowLights.push(sideWindowLight); 

            // Chimney
            const chimneyGeometry = new THREE.BoxGeometry(0.6, 1.5, 0.6);
            const chimneyMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.7, metalness: 0.0 });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(-1.2, 4.5, -1.2); 
            chimney.castShadow = true;
            house.add(chimney);

            scene.add(house);
        }

        /**
         * Creates the player character.
         */
        function createPlayer() {
            player = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 16); // Increased segments
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1, roughness: 0.5 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6; 
            body.castShadow = true;
            player.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16); // Increased segments
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3, roughness: 0.6 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.45; 
            head.castShadow = true;
            player.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.5, 0.2); 
            player.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.5, 0.2); 
            player.add(rightEye);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8); // Increased segments
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3, roughness: 0.6 });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.45, 0.8, 0); 
            leftArm.castShadow = true;
            player.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.45, 0.8, 0); 
            rightArm.castShadow = true;
            player.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8); // Increased segments
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.7 });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, -0.4, 0); 
            leftLeg.castShadow = true;
            player.add(leftLeg);
            player.userData.leftLeg = leftLeg; 

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, -0.4, 0); 
            rightLeg.castShadow = true;
            player.add(rightLeg);
            player.userData.rightLeg = rightLeg; 

            player.position.copy(playerPosition); 
            scene.add(player);
        }

        /**
         * Creates the ground plane.
         */
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(200, 200); // Doubled size
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x90EE90, roughness: 0.9, metalness: 0.0 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        /**
         * Creates various types of trees (deciduous and fir) and places them, avoiding the house and lake.
         */
        function createTrees() {
            const numDeciduousTrees = 60; // Doubled number for density in larger world
            const numFirTrees = 80; ¬† ¬† // Doubled number

            // Define house bounding box for collision detection
            const houseMinX = -2;
            const houseMaxX = 2;
            const houseMinZ = -2;
            const houseMaxZ = 2;

            // Define lake bounding circle for collision detection (scaled position and radius)
            const lakeCenterX = 60; // Doubled
            const lakeCenterZ = 0;
            const lakeRadius = 30; // Doubled
            const lakeBuffer = 6; // Doubled buffer zone

            // Deciduous trees
            const deciduousTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const deciduousFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });

            for (let i = 0; i < numDeciduousTrees; i++) {
                const tree = new THREE.Group();
                let treeX, treeZ;
                let isValidPosition = false;

                // Keep generating random positions until it's outside the house and lake
                while (!isValidPosition) {
                    treeX = -90 + Math.random() * 180; // Doubled range
                    treeZ = -90 + Math.random() * 180; // Doubled range

                    // Check if the tree is too close to the house
                    const isNearHouse = (treeX >= houseMinX - 3 && treeX <= houseMaxX + 3 && 
                                        treeZ >= houseMinZ - 3 && treeZ <= houseMaxZ + 3);

                    // Check if the tree is too close to the lake
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(treeX - lakeCenterX, 2) + 
                        Math.pow(treeZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (lakeRadius + lakeBuffer);

                    if (!isNearHouse && !isNearLake) {
                        isValidPosition = true;
                    }
                }
                
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8); // Increased segments
                const trunk = new THREE.Mesh(trunkGeometry, deciduousTrunkMaterial);
                trunk.position.y = 1;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                tree.add(trunk);

                const foliageGeometry = new THREE.SphereGeometry(1.2, 16, 16); // Increased segments
                const foliage = new THREE.Mesh(foliageGeometry, deciduousFoliageMaterial);
                foliage.position.y = 2.5;
                foliage.castShadow = true;
                tree.add(foliage);

                tree.position.x = treeX; 
                tree.position.z = treeZ; 
                tree.scale.setScalar(0.7 + Math.random() * 0.6); 

                scene.add(tree);
            }

            // Fir trees (coniferous)
            const firTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.8 }); 
            const firFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 0.7 }); 

            for (let i = 0; i < numFirTrees; i++) {
                const firTree = new THREE.Group();
                let treeX, treeZ;
                let isValidPosition = false;

                // Keep generating random positions until it's outside the house and lake
                while (!isValidPosition) {
                    treeX = -90 + Math.random() * 180; // Doubled range
                    treeZ = -90 + Math.random() * 180; // Doubled range

                    // Check if the tree is too close to the house
                    const isNearHouse = (treeX >= houseMinX - 3 && treeX <= houseMaxX + 3 && 
                                        treeZ >= houseMinZ - 3 && treeZ <= houseMaxZ + 3);

                    // Check if the tree is too close to the lake
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(treeX - lakeCenterX, 2) + 
                        Math.pow(treeZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (lakeRadius + lakeBuffer);

                    if (!isNearHouse && !isNearLake) {
                        isValidPosition = true;
                    }
                }

                const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.25, 2.5, 8); // Increased segments
                const trunk = new THREE.Mesh(trunkGeometry, firTrunkMaterial);
                trunk.position.y = 1.25;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                firTree.add(trunk);

                // Use a single variable for foliage meshes within the loop
                let foliageGeometry;
                let foliageMesh;

                foliageGeometry = new THREE.ConeGeometry(1.5, 2, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial);
                foliageMesh.position.y = 2.5;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                foliageGeometry = new THREE.ConeGeometry(1.0, 1.5, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial);
                foliageMesh.position.y = 3.5;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                foliageGeometry = new THREE.ConeGeometry(0.6, 1.0, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial); 
                foliageMesh.position.y = 4.2;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                firTree.position.x = treeX; 
                firTree.position.z = treeZ; 
                firTree.scale.setScalar(0.8 + Math.random() * 0.7); 

                scene.add(firTree);
            }
        }

        /**
         * Creates the lake with fish.
         */
        function createLake() {
            // Define points for the irregular lake shape
            const shapePoints = [
                new THREE.Vector2(0, 15),
                new THREE.Vector2(8, 12),
                new THREE.Vector2(13, 5),
                new THREE.Vector2(15, -5),
                new THREE.Vector2(10, -12),
                new THREE.Vector2(0, -15),
                new THREE.Vector2(-10, -12),
                new THREE.Vector2(-15, -5),
                new THREE.Vector2(-13, 5),
                new THREE.Vector2(-8, 12)
            ];
            // Scale points to double the lake size
            const scaledShapePoints = shapePoints.map(p => new THREE.Vector2(p.x * 2, p.y * 2));

            const lakeShape = new THREE.Shape(scaledShapePoints);
            const lakeGeometry = new THREE.ShapeGeometry(lakeShape); 
            
            // Water material with transparency and reflectivity
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x0066FF, 
                transparent: true,
                opacity: 0.7,
                roughness: 0.1, // Low roughness for more reflection
                metalness: 0.8, // High metalness for more reflection
                side: THREE.DoubleSide 
            });
            const lake = new THREE.Mesh(lakeGeometry, waterMaterial);
            lake.rotation.x = -Math.PI / 2; 
            lake.position.set(60, 0.01, 0); // Doubled X position
            scene.add(lake);

            // Fish
            const numFish = 10;
            const fishGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.2); 
            const fishMaterial = new THREE.MeshStandardMaterial({ color: 0xFF8C00 }); 

            const fishBoundaryRadius = 36; // Doubled

            for (let i = 0; i < numFish; i++) {
                const f = new THREE.Mesh(fishGeometry, fishMaterial);
                f.position.set(
                    lake.position.x + (Math.random() - 0.5) * fishBoundaryRadius * 1.8, 
                    lake.position.y - (0.1 + Math.random() * 0.3), 
                    lake.position.z + (Math.random() - 0.5) * fishBoundaryRadius * 1.8
                );
                f.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.025, 
                    0,
                    (Math.random() - 0.5) * 0.025 
                );
                f.userData.swimCycle = Math.random() * Math.PI * 2; 
                scene.add(f);
                fish.push(f);
            }
        }

        /**
         * Creates vegetation around the lake (bushes and reeds).
         */
        function createLakeVegetation() {
            const lakeCenterX = 60; // Doubled
            const lakeCenterZ = 0;
            const lakeRadius = 30; // Doubled
            const numBushes = 60; // Doubled
            const numReeds = 100; // Doubled

            const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x558B2F, roughness: 0.8 });
            for (let i = 0; i < numBushes; i++) {
                const bush = new THREE.Mesh(new THREE.SphereGeometry(0.3 + Math.random() * 0.3, 12, 12), bushMaterial); // Increased segments
                
                const angle = Math.random() * Math.PI * 2;
                const distance = lakeRadius + 4 + Math.random() * 10; // Doubled distance and range
                bush.position.set(
                    lakeCenterX + Math.cos(angle) * distance,
                    0.15, 
                    lakeCenterZ + Math.sin(angle) * distance
                );
                bush.scale.y = 0.7 + Math.random() * 0.6; 
                bush.castShadow = true;
                bush.receiveShadow = true;
                scene.add(bush);
            }

            const reedStemMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
            const reedHeadMaterial = new THREE.MeshStandardMaterial({ color: 0x6B8E23, roughness: 0.7 });
            for (let i = 0; i < numReeds; i++) {
                const reed = new THREE.Group();
                const height = 0.8 + Math.random() * 0.7;

                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, height, 8), reedStemMaterial); // Increased segments
                stem.position.y = height / 2;
                stem.castShadow = true;
                stem.receiveShadow = true;
                reed.add(stem);

                const head = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.08), reedHeadMaterial);
                head.position.y = height + 0.1;
                head.rotation.y = Math.random() * Math.PI;
                head.castShadow = true;
                reed.add(head);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = lakeRadius - 2 + Math.random() * 4; // Doubled distance and range
                reed.position.set(
                    lakeCenterX + Math.cos(angle) * distance,
                    0, 
                    lakeCenterZ + Math.sin(angle) * distance
                );
                reed.rotation.y = Math.random() * Math.PI * 2; 
                reed.rotation.z = (Math.random() - 0.5) * 0.2; 
                scene.add(reed);
            }
        }

        /**
         * Creates a pier and a boat on the lake.
         */
        function createPierAndBoat() {
            const lakeCenter = new THREE.Vector3(60, 0.01, 0); // Doubled X position

            // Create pier
            const pierMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6 }); 
            
            // Main part of the pier
            const pierBaseGeometry = new THREE.BoxGeometry(1.5, 0.2, 5); 
            const pierBase = new THREE.Mesh(pierBaseGeometry, pierMaterial);
            pierBase.position.set(lakeCenter.x + 20, lakeCenter.y + pierBaseGeometry.parameters.height / 2 + 0.01, lakeCenter.z + 10); // Adjusted X position
            pierBase.castShadow = true;
            pierBase.receiveShadow = true;
            scene.add(pierBase);

            // Pier supports
            const pierLegGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
            for (let i = 0; i < 3; i++) {
                const leg1 = new THREE.Mesh(pierLegGeometry, pierMaterial);
                leg1.position.set(pierBase.position.x - 0.5, lakeCenter.y - 0.4, pierBase.position.z - 1.5 + i * 1.5);
                leg1.castShadow = true;
                scene.add(leg1);

                const leg2 = new THREE.Mesh(pierLegGeometry, pierMaterial);
                leg2.position.set(pierBase.position.x + 0.5, lakeCenter.y - 0.4, pierBase.position.z - 1.5 + i * 1.5);
                leg2.castShadow = true;
                scene.add(leg2);
            }

            // Create boat
            const boat = new THREE.Group();
            const boatMaterial = new THREE.MeshStandardMaterial({ color: 0x6A5ACD, roughness: 0.4, metalness: 0.1 }); 
            const boatInsideMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6 }); 

            // Boat hull (main part)
            const boatHullGeometry = new THREE.BoxGeometry(0.8, 0.3, 2.5);
            const boatHull = new THREE.Mesh(boatHullGeometry, boatMaterial);
            boatHull.position.y = 0; 
            boat.add(boatHull);

            // Boat front (cone or more complex shape)
            const boatFrontGeometry = new THREE.ConeGeometry(0.4, 0.5, 8); // Increased segments
            const boatFront = new THREE.Mesh(boatFrontGeometry, boatMaterial);
            boatFront.rotation.x = Math.PI / 2; 
            boatFront.position.set(0, 0, 1.25); 
            boat.add(boatFront);

            // Inside part (seat)
            const seatGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.5);
            const seat = new THREE.Mesh(seatGeometry, boatInsideMaterial);
            seat.position.set(0, 0.1, 0); 
            boat.add(seat);

            // Position the boat at lake level
            boat.position.set(pierBase.position.x + 2, lakeCenter.y + boatHullGeometry.parameters.height / 2, pierBase.position.z + 1.5); // Adjusted X position
            boat.rotation.y = -Math.PI / 4; 
            boat.castShadow = true;
            boat.receiveShadow = true;
            scene.add(boat);
        }

        /**
         * Creates a circular fence around the house.
         */
        function createFence() {
            const fenceRadius = 6; 
            const fenceHeight = 0.8;
            const postRadius = 0.08;
            const numPosts = 32; // Increased posts for smoother circle

            const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 }); 

            const posts = [];
            for (let i = 0; i < numPosts; i++) {
                const angle = (i / numPosts) * Math.PI * 2;
                const x = Math.cos(angle) * fenceRadius;
                const z = Math.sin(angle) * fenceRadius;
                posts.push(new THREE.Vector3(x, fenceHeight / 2, z));
            }

            // Create fence posts
            const fencePostGeometry = new THREE.CylinderGeometry(postRadius, postRadius, fenceHeight, 8);
            posts.forEach(pos => {
                const post = new THREE.Mesh(fencePostGeometry, fenceMaterial);
                post.position.copy(pos);
                post.castShadow = true;
                post.receiveShadow = true;
                scene.add(post);
            });
        }

        /**
         * Creates rabbits with smooth forward/backward movement and bobbing.
         */
        function createRabbits() {
            const numRabbits = 3; 
            const rabbitMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5DC, roughness: 0.7 }); 
            const rabbitScale = 0.6; // Increased scale for better visibility

            // Define house and lake bounding boxes/circles for collision detection
            const houseMinX = -2;
            const houseMaxX = 2;
            const houseMinZ = -2;
            const houseMaxZ = 2;

            const lakeCenterX = 60; // Scaled
            const lakeCenterZ = 0;
            const lakeRadius = 30; // Scaled
            const exclusionBuffer = 4; // Adjusted buffer zone

            // Movement properties for rabbits (smooth oscillation)
            const rabbitOscillationSpeed = 0.001; // Slower speed for oscillation
            const rabbitOscillationAmplitude = 5; // Increased amplitude for more noticeable movement

            for (let i = 0; i < numRabbits; i++) {
                const rabbit = new THREE.Group();
                let rabbitX, rabbitZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    rabbitX = -90 + Math.random() * 180; // Doubled range
                    rabbitZ = -90 + Math.random() * 180; // Doubled range

                    // Check if the rabbit is too close to the house
                    const isNearHouse = (rabbitX >= houseMinX - exclusionBuffer && rabbitX <= houseMaxX + exclusionBuffer && 
                                        rabbitZ >= houseMinZ - exclusionBuffer && rabbitZ <= houseMaxZ + exclusionBuffer);

                    // Check if the rabbit is too close to the lake
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(rabbitX - lakeCenterX, 2) + 
                        Math.pow(rabbitZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (lakeRadius + exclusionBuffer);

                    if (!isNearHouse && !isNearLake) {
                        isValidPosition = true;
                    }
                }

                // Body
                const bodyGeometry = new THREE.SphereGeometry(0.8 * rabbitScale, 24, 12); // Increased segments
                const body = new THREE.Mesh(bodyGeometry, rabbitMaterial);
                body.position.y = 0.4 * rabbitScale; 
                body.scale.z = 1.5; 
                body.castShadow = true;
                body.receiveShadow = true;
                rabbit.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.5 * rabbitScale, 24, 12); // Increased segments
                const head = new THREE.Mesh(headGeometry, rabbitMaterial);
                head.position.set(0.6 * rabbitScale, 0.8 * rabbitScale, 0); 
                head.castShadow = true;
                rabbit.add(head);

                // Ears
                const earGeometry = new THREE.BoxGeometry(0.2 * rabbitScale, 1.2 * rabbitScale, 0.2 * rabbitScale); 
                const leftEar = new THREE.Mesh(earGeometry, rabbitMaterial);
                leftEar.position.set(0.7 * rabbitScale, 1.6 * rabbitScale, 0.3 * rabbitScale); 
                leftEar.rotation.z = Math.PI / 10;
                leftEar.castShadow = true;
                rabbit.add(leftEar);

                const rightEar = new THREE.Mesh(earGeometry, rabbitMaterial);
                rightEar.position.set(0.7 * rabbitScale, 1.6 * rabbitScale, -0.3 * rabbitScale); 
                rightEar.rotation.z = -Math.PI / 10;
                rightEar.castShadow = true;
                rabbit.add(rightEar);

                // Tail
                const tailGeometry = new THREE.SphereGeometry(0.3 * rabbitScale, 16, 16); // Increased segments
                const tailMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.7 }); 
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.position.set(-1.0 * rabbitScale, 0.4 * rabbitScale, 0); 
                tail.castShadow = true;
                rabbit.add(tail);

                rabbit.position.set(rabbitX, 0, rabbitZ); 
                rabbit.rotation.y = Math.random() * Math.PI * 2; // Random initial rotation
                rabbit.userData.initialRotationY = rabbit.rotation.y; // Store initial rotation for movement
                rabbit.userData.offset = Math.random() * Math.PI * 2; // Unique offset for bobbing
                
                rabbit.userData.initialPosition = rabbit.position.clone(); // Store initial position for oscillation
                rabbit.userData.oscillationSpeed = rabbitOscillationSpeed + (Math.random() - 0.5) * 0.0002; // Slightly varied speed
                rabbit.userData.oscillationAmplitude = rabbitOscillationAmplitude + (Math.random() - 0.5) * 0.5; // Slightly varied amplitude
                rabbit.userData.oscillationOffset = Math.random() * Math.PI * 2; // Unique offset for oscillation

                scene.add(rabbit);
                rabbits.push(rabbit);
            }
        }

        /**
         * Creates smoke particles for the chimney.
         */
        function createSmokeParticles() {
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8); // Increased segments
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0xDDDDDD,
                transparent: true,
                opacity: 0.6
            });

            for (let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(-1.2, 5.2 + i * 0.3, -1.2);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.02
                    ),
                    life: Math.random()
                };
                particles.push(particle);
                scene.add(particle);
            }
        }

        /**
         * Creates scattered rocks/stones across the terrain.
         */
        function createRocks() {
            const numRocks = 100;
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9, metalness: 0.0 }); // Grey stone color

            // Define exclusion zones (house and lake)
            const houseMinX = -2; const houseMaxX = 2;
            const houseMinZ = -2; const houseMaxZ = 2;
            const lakeCenterX = 60; const lakeCenterZ = 0;
            const lakeRadius = 30;
            const exclusionBuffer = 5; // Buffer zone around house/lake

            for (let i = 0; i < numRocks; i++) {
                let rockX, rockZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    rockX = -90 + Math.random() * 180; // Full world range
                    rockZ = -90 + Math.random() * 180; // Full world range

                    const isNearHouse = (rockX >= houseMinX - exclusionBuffer && rockX <= houseMaxX + exclusionBuffer && 
                                        rockZ >= houseMinZ - exclusionBuffer && rockZ <= houseMaxZ + exclusionBuffer);
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(rockX - lakeCenterX, 2) + 
                        Math.pow(rockZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (lakeRadius + exclusionBuffer);

                    if (!isNearHouse && !isNearLake) {
                        isValidPosition = true;
                    }
                }

                // Randomly choose between a sphere or box geometry for variety
                let rockGeometry;
                if (Math.random() > 0.5) {
                    rockGeometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.4, 8, 8); // Small spheres
                } else {
                    rockGeometry = new THREE.BoxGeometry(0.3 + Math.random() * 0.5, 0.1 + Math.random() * 0.3, 0.3 + Math.random() * 0.5); // Flat-ish boxes
                }
                
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(rockX, rockGeometry.parameters.height / 2 || rockGeometry.parameters.radius || 0.1, rockZ); // Place on ground
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI); // Random rotation
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
            }
        }

        /**
         * Creates dynamic clouds in the sky.
         */
        let cloudMeshes = []; // Array to store cloud meshes for animation
        function createClouds() {
            const numClouds = 10;
            const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8, roughness: 0.5 });

            for (let i = 0; i < numClouds; i++) {
                const cloud = new THREE.Group();
                const numParts = 3 + Math.floor(Math.random() * 3); // 3-5 parts per cloud

                for (let j = 0; j < numParts; j++) {
                    const partGeometry = new THREE.SphereGeometry(3 + Math.random() * 2, 16, 16); // Varying sizes
                    const part = new THREE.Mesh(partGeometry, cloudMaterial);
                    part.position.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 5
                    );
                    part.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    cloud.add(part);
                }

                cloud.position.set(
                    -90 + Math.random() * 180, // Wide range across the world
                    30 + Math.random() * 10, ¬†// High in the sky
                    -90 + Math.random() * 180
                );
                cloud.scale.setScalar(0.5 + Math.random()); // Vary cloud size
                cloud.userData.speed = (Math.random() - 0.5) * 0.05; // Random horizontal speed
                scene.add(cloud);
                clouds.push(cloud);
            }
        }

        /**
         * Creates a mailbox near the house.
         */
        function createMailbox() {
            const mailbox = new THREE.Group();
            const postMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 }); // Brown post
            const boxMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.6 }); // Red box

            // Post
            const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.0, 8);
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 0.5;
            post.castShadow = true;
            post.receiveShadow = true;
            mailbox.add(post);

            // Box
            const boxGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.6);
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(0, 1.2, 0);
            box.castShadow = true;
            box.receiveShadow = true;
            mailbox.add(box);

            // Flag (small cylinder)
            const flagGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4);
            const flagMaterial = new THREE.MeshStandardMaterial({ color: 0x0000FF, roughness: 0.5 }); // Blue flag
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(0.2, 1.35, 0.2);
            flag.rotation.z = Math.PI / 2; // Make it horizontal
            flag.castShadow = true;
            mailbox.add(flag);

            mailbox.position.set(-3, 0, 3); // Position near the house
            mailbox.rotation.y = Math.PI / 4; // Slightly rotate
            scene.add(mailbox);
        }


        /**
         * Sets up the scene's lighting (ambient, directional, hemisphere).
         */
        function setupLighting() {
            // Remove existing lights to avoid duplication
            scene.children.forEach(obj => {
                if (obj instanceof THREE.Light) {
                    scene.remove(obj);
                }
            });

            const ambientLight = new THREE.AmbientLight(0x404040, daySettings.ambientIntensity);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(daySettings.directionalColor, daySettings.directionalIntensity);
            directionalLight.position.copy(daySettings.directionalPosition);
            directionalLight.castShadow = true;

            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200; // Increased far plane for larger world
            directionalLight.shadow.camera.left = -90; // Adjusted for larger world
            directionalLight.shadow.camera.right = 90; // Adjusted for larger world
            directionalLight.shadow.camera.top = 90; // Adjusted for larger world
            directionalLight.shadow.camera.bottom = -90; // Adjusted for larger world
            scene.add(directionalLight);

            const hemisphereLight = new THREE.HemisphereLight(daySettings.hemisphereSkyColor, daySettings.hemisphereGroundColor, daySettings.hemisphereIntensity);
            scene.add(hemisphereLight);
        }

        /**
         * Sets up event listeners for mouse and keyboard controls.
         */
        function setupControls() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            window.addEventListener('resize', onWindowResize);

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            document.getElementById('toggleDayNightButton').addEventListener('click', toggleDayNight);
        }

        // --- Event Handlers ---

        function onKeyDown(event) {
            keys[event.code] = true;
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX));

                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onWheel(event) {
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(3, Math.min(200, cameraDistance)); // Increased max camera distance for larger world
        }

        /**
         * Toggles between day and night settings with a smooth transition.
         */
        function toggleDayNight() {
            isDayTime = !isDayTime;
            targetTransitionProgress = isDayTime ? 1 : 0; 

            const button = document.getElementById('toggleDayNightButton');
            if (button) {
                button.textContent = isDayTime ? '‚òÄÔ∏è' : 'üåô';
            }
        }

        /**
         * Handles window resizing to keep the renderer and camera aspect ratio correct.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Main animation loop.
         */
        function animate() {
            requestAnimationFrame(animate);

            // Smooth day/night transition logic
            if (transitionProgress !== targetTransitionProgress) {
                const delta = targetTransitionProgress - transitionProgress;
                transitionProgress += Math.sign(delta) * transitionSpeed;

                transitionProgress = Math.max(0, Math.min(1, transitionProgress));

                const fogColorDay = new THREE.Color(daySettings.fogColor);
                const fogColorNight = new THREE.Color(nightSettings.fogColor);
                scene.fog.color.copy(fogColorNight).lerp(fogColorDay, transitionProgress);

                const clearColorDay = new THREE.Color(daySettings.clearColor);
                const clearColorNight = new THREE.Color(nightSettings.clearColor);
                const currentClearColor = new THREE.Color().copy(clearColorNight).lerp(clearColorDay, transitionProgress);
                renderer.setClearColor(currentClearColor, 1);

                const ambientLight = scene.children.find(obj => obj instanceof THREE.AmbientLight);
                const directionalLight = scene.children.find(obj => obj instanceof THREE.DirectionalLight);
                const hemisphereLight = scene.children.find(obj => obj instanceof THREE.HemisphereLight);

                if (ambientLight) {
                    ambientLight.intensity = nightSettings.ambientIntensity + (daySettings.ambientIntensity - nightSettings.ambientIntensity) * transitionProgress;
                }
                if (directionalLight) {
                    const dirColorDay = new THREE.Color(daySettings.directionalColor);
                    const dirColorNight = new THREE.Color(nightSettings.directionalColor);
                    directionalLight.color.copy(dirColorNight).lerp(dirColorDay, transitionProgress);
                    directionalLight.intensity = nightSettings.directionalIntensity + (daySettings.directionalIntensity - nightSettings.directionalIntensity) * transitionProgress;
                    directionalLight.position.lerpVectors(nightSettings.directionalPosition, daySettings.directionalPosition, transitionProgress);
                }
                if (hemisphereLight) {
                    const hemiSkyColorDay = new THREE.Color(daySettings.hemisphereSkyColor);
                    const hemiSkyColorNight = new THREE.Color(nightSettings.hemisphereSkyColor);
                    hemisphereLight.color.copy(hemiSkyColorNight).lerp(hemiSkyColorDay, transitionProgress);

                    const hemiGroundColorDay = new THREE.Color(daySettings.hemisphereGroundColor);
                    const hemiGroundColorNight = new THREE.Color(nightSettings.hemisphereGroundColor);
                    hemisphereLight.groundColor.copy(hemiGroundColorNight).lerp(hemiGroundColorDay, transitionProgress);
                    hemisphereLight.intensity = nightSettings.hemisphereIntensity + (daySettings.hemisphereIntensity - nightSettings.hemisphereIntensity) * transitionProgress;
                }

                windowLights.forEach(light => {
                    light.intensity = nightSettings.windowLightIntensity + (daySettings.windowLightIntensity - nightSettings.windowLightIntensity) * transitionProgress;
                });
            }

            updatePlayer();

            const cameraOffset = new THREE.Vector3(
                Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance,
                Math.sin(cameraAngleX) * cameraDistance + 3,
                Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance
            );

            camera.position.copy(playerPosition).add(cameraOffset);
            camera.lookAt(playerPosition.x, playerPosition.y + 1, playerPosition.z);

            // Animate smoke particles
            particles.forEach((particle, idx) => { 
                particle.position.add(particle.userData.velocity);
                particle.userData.life += 0.01;

                if (particle.userData.life > 1 || particle.position.y > 15) {
                    particle.position.set(-1.2, 5.2 + idx * 0.3, -1.2); 
                    particle.userData.life = 0;
                    particle.userData.velocity.set(
                        (Math.random() - 0.5) * 0.02,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.02
                    );
                }

                particle.material.opacity = 0.6 * (1 - particle.userData.life);
            });

            // Animate fish
            const lakeCenter = new THREE.Vector3(60, 0.01, 0); // Scaled
            const fishBoundaryRadius = 36; // Scaled
            fish.forEach(f => {
                f.position.add(f.userData.velocity);
                
                const distanceToCenter = f.position.distanceTo(lakeCenter);
                if (distanceToCenter > fishBoundaryRadius) { 
                    const directionToCenter = new THREE.Vector3().subVectors(lakeCenter, f.position).normalize();
                    f.userData.velocity.copy(directionToCenter).multiplyScalar(0.025 + Math.random() * 0.01); 
                    
                    f.userData.velocity.x += (Math.random() - 0.5) * 0.005; 
                    f.userData.velocity.z += (Math.random() - 0.5) * 0.005; 
                    f.userData.velocity.normalize().multiplyScalar(0.025); 
                }

                f.position.y += Math.sin(f.userData.swimCycle) * 0.005; 
                f.userData.swimCycle += 0.05;

                f.rotation.y = Math.atan2(f.userData.velocity.x, f.userData.velocity.z);
            });

            // Animate rabbits (smooth forward/backward movement and bobbing)
            rabbits.forEach(rabbit => {
                // Calculate new Z position based on sine wave for smooth oscillation
                const newZ = rabbit.userData.initialPosition.z + Math.sin(Date.now() * rabbit.userData.oscillationSpeed + rabbit.userData.oscillationOffset) * rabbit.userData.oscillationAmplitude;
                
                // Determine movement direction for rotation
                const prevZ = rabbit.position.z;
                rabbit.position.z = newZ;

                // Rotate rabbit to face the direction of movement
                // If moving forward (newZ > prevZ), face one way, else face the other
                if (newZ > prevZ) { 
                    rabbit.rotation.y = rabbit.userData.initialRotationY; // Use initial rotation for forward
                } else { 
                    rabbit.rotation.y = rabbit.userData.initialRotationY + Math.PI; // Add PI for backward
                }

                // Bobbing animation relative to ground (y=0)
                rabbit.position.y = Math.sin(Date.now() * 0.005 + rabbit.userData.offset) * 0.05; 
            });

            // Animate clouds
            clouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speed;
                // Wrap clouds around the world
                if (cloud.position.x > 100) cloud.position.x = -100;
                if (cloud.position.x < -100) cloud.position.x = 100;
            });


            house.rotation.y = Math.sin(Date.now() * 0.0005) * 0.02;

            renderer.render(scene, camera);
        }

        /**
         * Updates player position and rotation based on keyboard input and camera direction.
         */
        function updatePlayer() {
            let isMoving = false;
            const speed = keys['ShiftLeft'] || keys['ShiftRight'] ? 0.15 : 0.08;
            const moveDirection = new THREE.Vector3(); 
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection); 

            // Ensure horizontal movement only
            cameraDirection.y = 0;
            cameraDirection.normalize();

            const cameraRight = new THREE.Vector3();
            // Cross product of camera's up vector and forward vector gives right vector
            cameraRight.crossVectors(camera.up, cameraDirection); 
            cameraRight.normalize();

            // Calculate movement based on pressed keys and camera orientation
            if (keys['KeyW'] || keys['ArrowUp']) {
                moveDirection.add(cameraDirection);
                isMoving = true;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                moveDirection.sub(cameraDirection);
                isMoving = true;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                moveDirection.add(cameraRight); // Move right relative to camera
                isMoving = true;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                moveDirection.sub(cameraRight); // Move left relative to camera
                isMoving = true;
            }

            if (isMoving) {
                moveDirection.normalize().multiplyScalar(speed);
                playerPosition.add(moveDirection);

                // Update player rotation to face movement direction
                if (Math.abs(moveDirection.x) > 0.0001 || Math.abs(moveDirection.z) > 0.0001) {
                    player.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);
                }

                walkAnimation += 0.2;
                if (player.userData.leftLeg && player.userData.rightLeg) {
                    player.userData.leftLeg.rotation.x = Math.sin(walkAnimation) * 0.3;
                    player.userData.rightLeg.rotation.x = -Math.sin(walkAnimation) * 0.3;
                }
            } else {
                if (player.userData.leftLeg && player.userData.rightLeg) {
                    player.userData.leftLeg.rotation.x = 0;
                    player.userData.rightLeg.rotation.x = 0;
                }
            }

            // Clamp player position within scene boundaries
            playerPosition.x = Math.max(-90, Math.min(90, playerPosition.x)); // Doubled boundaries
            playerPosition.z = Math.max(-90, Math.min(90, playerPosition.z)); // Doubled boundaries

            player.position.copy(playerPosition);
        }

        // --- Initialization Function ---
        // This function is called once when the window finishes loading.
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(daySettings.fogColor, 20, 200); // Adjusted fog: near 20, far 200

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(daySettings.clearColor, 1); 
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('container').appendChild(renderer.domElement);

            // Create all scene elements
            createHouse();
            createPlayer();
            createGround();
            createTrees(); ¬†
            createLake(); ¬†
            createSmokeParticles();
            createLakeVegetation(); 
            createPierAndBoat(); 
            createFence(); 
            createRabbits(); 
            createRocks(); // Add rocks
            createClouds(); // Add clouds
            createMailbox(); // Add mailbox
            
            // Setup lighting and controls
            setupLighting(); 
            setupControls();

            // Initial day/night state
            targetTransitionProgress = isDayTime ? 1 : 0;
            const button = document.getElementById('toggleDayNightButton');
            if (button) {
                button.textContent = isDayTime ? '‚òÄÔ∏è' : 'üåô';
            }

            // Start the animation loop
            animate();
        }

        // Ensure init is called after the entire window (including all scripts) has loaded
        window.onload = function() {
            init();
        }; 
    </script>
</body>
</html>

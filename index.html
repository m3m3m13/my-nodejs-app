<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –î–æ–º–∏–∫ - –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç—å</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        #controls h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }

        #controls p {
            margin: 5px 0;
            color: #666;
            font-size: 12px;
        }

        .key {
            display: inline-block;
            background: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 0 2px;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px; /* Reduced padding */
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-width: 250px;
            display: flex; /* Use flexbox for button alignment */
            flex-direction: column; /* Stack items vertically */
            align-items: flex-start; /* Align items to the start */
        }

        #info h3 { 
            margin: 0 0 0px 0; 
            color: #333;
            font-size: 16px;
        }

        #info p {
            margin: 5px 0;
            color: #666;
            font-size: 12px;
            line-height: 1.4;
        }

        #toggleDayNightButton {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            padding: 5px 10px; /* Reduced padding for the button */
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 24px; /* Increased font size for emoji */
            margin-top: 5px; /* Reduced top margin */
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: auto; /* Automatic width */
            height: auto; /* Automatic height */
            line-height: 1; /* Removed extra line height */
        }

        #toggleDayNightButton:hover {
            background-color: #45a049;
        }

        #game-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            color: #333;
            font-size: 16px;
            font-weight: bold;
        }

        #resource-counters {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>üè† –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
            <p>üñ±Ô∏è –ú—ã—à—å: –ø–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</p>
            <p>üîÑ –ö–æ–ª–µ—Å–æ: –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ</p>
            <p>üö∂ <span class="key">WASD</span> –∏–ª–∏ <span class="key">‚Üë‚Üì‚Üê‚Üí</span>: –¥–≤–∏–∂–µ–Ω–∏–µ</p>
            <p>üèÉ <span class="key">Shift</span>: –±–µ–≥</p>
            <p>ü™µ <span class="key">E</span>: –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ (–≤–∑—è—Ç—å/–ø–æ–ª–æ–∂–∏—Ç—å —Ä–µ—Å—É—Ä—Å)</p>
        </div>

        <div id="info">
            <button id="toggleDayNightButton">‚òÄÔ∏è</button> 
        </div>

        <div id="game-ui">
            <div id="resource-counters">
                <span>–ë—Ä–µ–≤–Ω–∞ —Å–æ–±—Ä–∞–Ω—ã: <span id="collectedLogsCount">0</span></span>
                <span>–ö–∞–º–Ω–∏ —Å–æ–±—Ä–∞–Ω—ã: <span id="collectedStonesCount">0</span></span>
            </div>
        </div>
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Å—Ü–µ–Ω—ã
        let scene, camera, renderer, house, particles = [], player;
        let isMouseDown = false, mouseX = 0, mouseY = 0;
        let cameraAngleX = 0.3, cameraAngleY = 0;
        let cameraDistance = 40; // –£–≤–µ–ª–∏—á–µ–Ω–æ –Ω–∞—á–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∫–∞–º–µ—Ä—ã –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –º–∏—Ä–∞
        let isDayTime = true;
        let keys = {};
        let playerPosition = new THREE.Vector3(-10, 0.8, 0); 
        let playerRotation = 0;
        let walkAnimation = 0;
        let windowLights = []; 
        let fish = []; 
        let rabbits = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ –∫—Ä–æ–ª–∏–∫–æ–≤
        let clouds = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ –æ–±–ª–∞–∫–æ–≤
        let fireflies = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ —Å–≤–µ—Ç–ª—è—á–∫–æ–≤
        let bird; // –û–±—ä–µ–∫—Ç –ø—Ç–∏—Ü—ã

        // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let playerHasResource = false; // –ú–æ–∂–µ—Ç –¥–µ—Ä–∂–∞—Ç—å –ª–∏–±–æ –±—Ä–µ–≤–Ω–æ, –ª–∏–±–æ –∫–∞–º–µ–Ω—å
        let currentHeldResource = null; // –¢–µ–∫—É—â–∏–π —É–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ä–µ—Å—É—Ä—Å (THREE.Mesh)
        let currentResourceType = null; // 'log' –∏–ª–∏ 'stone'
        let collectedLogsCount = 0;
        let collectedStonesCount = 0;
        let logDropOffPileGroup = null; // –ì—Ä—É–ø–ø–∞ –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º—ã—Ö –±—Ä–µ–≤–µ–Ω —É —Å–∞—Ä–∞–π—á–∏–∫–∞ (–ª–µ—Å–æ–ø–∏–ª–∫–∏)
        let stoneDropOffPileGroup = null; // –ì—Ä—É–ø–ø–∞ –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º—ã—Ö –∫–∞–º–Ω–µ–π —É –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
        let quarryHouse = null; // –î–æ–º –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
        const interactDistance = 3; // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è (–ø–æ–¥–±–æ—Ä–∞/–≤—ã–≥—Ä—É–∑–∫–∏)
        let collectibleTrees = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –≤—Å–µ—Ö —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤
        let collectibleStones = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –≤—Å–µ—Ö —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –∫–∞–º–Ω–µ–π (—Ç–µ–ø–µ—Ä—å –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –≤ createRocks)

        let transitionProgress = 1; 
        let transitionSpeed = 0.02; 
        let targetTransitionProgress = 1; 

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–Ω—è –∏ –Ω–æ—á–∏ –¥–ª—è –æ—Å–≤–µ—â–µ–Ω–∏—è –∏ —Ç—É–º–∞–Ω–∞
        const daySettings = {
            fogColor: 0xA0D0FF, // –°–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–æ–π —Ç—É–º–∞–Ω
            clearColor: 0xA0D0FF, // –°–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–æ–π —Ü–≤–µ—Ç –æ—á–∏—Å—Ç–∫–∏
            ambientIntensity: 0.4, // –£–º–µ—Ä–µ–Ω–Ω—ã–π –æ–∫—Ä—É–∂–∞—é—â–∏–π —Å–≤–µ—Ç
            directionalColor: 0xffffff, // –ë–µ–ª—ã–π —Å–æ–ª–Ω–µ—á–Ω—ã–π —Å–≤–µ—Ç
            directionalIntensity: 0.8, // –°–∏–ª—å–Ω—ã–π —Å–æ–ª–Ω–µ—á–Ω—ã–π —Å–≤–µ—Ç
            directionalPosition: new THREE.Vector3(10, 15, 10), // –ü–æ–∑–∏—Ü–∏—è —Å–æ–ª–Ω—Ü–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è)
            hemisphereSkyColor: 0xC0E0FF, // –°–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–æ–µ –Ω–µ–±–æ –¥–ª—è –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            hemisphereGroundColor: 0xA9D9A9, // –°–≤–µ—Ç–ª–æ-–∑–µ–ª–µ–Ω–∞—è –∑–µ–º–ª—è –¥–ª—è –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            hemisphereIntensity: 0.6, // –£–º–µ—Ä–µ–Ω–Ω—ã–π —Å–≤–µ—Ç –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            windowLightIntensity: 0.0 // –û–∫–Ω–∞ –≤—ã–∫–ª—é—á–µ–Ω—ã –¥–Ω–µ–º
        };

        const nightSettings = {
            fogColor: 0x101040, // –¢–µ–º–Ω–æ-—Å–∏–Ω–∏–π/—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π —Ç—É–º–∞–Ω
            clearColor: 0x101040, // –¢–µ–º–Ω–æ-—Å–∏–Ω–∏–π/—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π —Ü–≤–µ—Ç –æ—á–∏—Å—Ç–∫–∏
            ambientIntensity: 0.25, // –¢—É—Å–∫–ª—ã–π –æ–∫—Ä—É–∂–∞—é—â–∏–π —Å–≤–µ—Ç
            directionalColor: 0x404080, // –ì–æ–ª—É–±–æ–≤–∞—Ç—ã–π –ª—É–Ω–Ω—ã–π —Å–≤–µ—Ç
            directionalIntensity: 0.3, // –¢—É—Å–∫–ª—ã–π –ª—É–Ω–Ω—ã–π —Å–≤–µ—Ç
            directionalPosition: new THREE.Vector3(-10, 15, -10), // –ü–æ–∑–∏—Ü–∏—è –ª—É–Ω—ã (–±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è)
            hemisphereSkyColor: 0x202050, // –¢–µ–º–Ω–æ-—Å–∏–Ω–µ–µ –Ω–µ–±–æ –¥–ª—è –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            hemisphereGroundColor: 0x101010, // –û—á–µ–Ω—å —Ç–µ–º–Ω–∞—è –∑–µ–º–ª—è –¥–ª—è –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            hemisphereIntensity: 0.2, // –û—á–µ–Ω—å —Ç—É—Å–∫–ª—ã–π —Å–≤–µ—Ç –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            windowLightIntensity: 2.0 // –û–∫–Ω–∞ –≤–∫–ª—é—á–µ–Ω—ã –Ω–æ—á—å—é
        };

        const textureLoader = new THREE.TextureLoader();

        // --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (–æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –¥–æ init –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏) ---

        /**
         * –°–æ–∑–¥–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω—É—é –º–æ–¥–µ–ª—å –¥–æ–º–∞ —Å–æ —Å—Ç–µ–Ω–∞–º–∏, –∫—Ä—ã—à–µ–π, –¥–≤–µ—Ä—å—é, —Ä—É—á–∫–æ–π, –æ–∫–Ω–∞–º–∏ –∏ –¥—ã–º–æ—Ö–æ–¥–æ–º.
         */
        function createHouse() {
            house = new THREE.Group();

            // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä—ã –∫–∏—Ä–ø–∏—á–∞ –¥–ª—è —Å—Ç–µ–Ω
            const brickTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg',
                function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
                    texture.repeat.set(2, 2); 
                    wallMaterial.map = texture; 
                    wallMaterial.needsUpdate = true; 
                },
                undefined,
                function (err) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ–∫—Å—Ç—É—Ä—ã –∫–∏—Ä–ø–∏—á–∞:', err);
                    wallMaterial.color.set(0x8B4513); // –†–µ–∑–µ—Ä–≤–Ω—ã–π —Ü–≤–µ—Ç, –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å
                    wallMaterial.needsUpdate = true;
                }
            );

            // –°—Ç–µ–Ω—ã
            const wallGeometry = new THREE.BoxGeometry(4, 3, 4); 
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 0.8, metalness: 0.1 });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 1.5;
            walls.castShadow = true;
            walls.receiveShadow = true;
            house.add(walls);

            // –ö—Ä—ã—à–∞
            const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –¥–ª—è –±–æ–ª–µ–µ –≥–ª–∞–¥–∫–æ–≥–æ –∫–æ–Ω—É—Å–∞
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.7, metalness: 0.0 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 4;
            roof.rotation.y = Math.PI / 4; 
            roof.castShadow = true;
            house.add(roof);

            // –î–≤–µ—Ä—å
            const doorGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.1);
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.6, metalness: 0.0 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.9, 2.05); 
            door.castShadow = true;
            house.add(door);

            // –†—É—á–∫–∞ –¥–≤–µ—Ä–∏
            const handleGeometry = new THREE.SphereGeometry(0.05, 16, 16); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –¥–ª—è –±–æ–ª–µ–µ –≥–ª–∞–¥–∫–æ–π —Å—Ñ–µ—Ä—ã
            const handleMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3, metalness: 0.8 });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(-0.3, 0.9, 2.1);
            handle.castShadow = true;
            house.add(handle);

            // –û–∫–Ω–∞
            const windowGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.1);
            // –î–æ–±–∞–≤–ª–µ–Ω—ã polygonOffset –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            const windowMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.7, roughness: 0.2, metalness: 0.1, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: 1 });
            // –î–æ–±–∞–≤–ª–µ–Ω—ã polygonOffset –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            const windowFrameMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.5, polygonOffset: true, polygonOffsetFactor: -2, polygonOffsetUnits: 1 }); 

            // –ü–µ—Ä–µ–¥–Ω–µ–µ –æ–∫–Ω–æ
            const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow.position.set(1.2, 1.8, 2.05); 
            frontWindow.castShadow = true;
            house.add(frontWindow);
            // –†–∞–º—ã –¥–ª—è –ø–µ—Ä–µ–¥–Ω–µ–≥–æ –æ–∫–Ω–∞
            const frontWindowFrameH1 = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 0.1), windowFrameMaterial);
            frontWindowFrameH1.position.set(1.2, 1.8 + 0.4, 2.05);
            house.add(frontWindowFrameH1);
            const frontWindowFrameH2 = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 0.1), windowFrameMaterial);
            frontWindowFrameH2.position.set(1.2, 1.8 - 0.4, 2.05);
            house.add(frontWindowFrameH2);
            const frontWindowFrameV1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.1), windowFrameMaterial);
            frontWindowFrameV1.position.set(1.2 + 0.4, 1.8, 2.05);
            house.add(frontWindowFrameV1);
            const frontWindowFrameV2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.1), windowFrameMaterial);
            frontWindowFrameV2.position.set(1.2 - 0.4, 1.8, 2.05);
            house.add(frontWindowFrameV2);

            // –¢–æ—á–µ—á–Ω—ã–π —Å–≤–µ—Ç –¥–ª—è –ø–µ—Ä–µ–¥–Ω–µ–≥–æ –æ–∫–Ω–∞
            windowLights = []; 
            const frontWindowLight = new THREE.PointLight(0xFFE0B2, daySettings.windowLightIntensity, 5); 
            frontWindowLight.position.set(1.2, 1.8, 1.95); 
            frontWindowLight.castShadow = true;
            house.add(frontWindowLight);
            windowLights.push(frontWindowLight); 

            // –ë–æ–∫–æ–≤–æ–µ –æ–∫–Ω–æ
            const sideWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            sideWindow.position.set(2.05, 1.8, 0); 
            sideWindow.rotation.y = Math.PI / 2; 
            sideWindow.castShadow = true;
            house.add(sideWindow);
            // –†–∞–º—ã –¥–ª—è –±–æ–∫–æ–≤–æ–≥–æ –æ–∫–Ω–∞
            const sideWindowFrameH1 = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 0.1), windowFrameMaterial);
            sideWindowFrameH1.position.set(2.05, 1.8 + 0.4, 0);
            sideWindowFrameH1.rotation.y = Math.PI / 2;
            house.add(sideWindowFrameH1);
            const sideWindowFrameH2 = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 0.1), windowFrameMaterial);
            sideWindowFrameH2.position.set(2.05, 1.8 - 0.4, 0);
            sideWindowFrameH2.rotation.y = Math.PI / 2;
            house.add(sideWindowFrameH2);
            const sideWindowFrameV1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.1), windowFrameMaterial);
            sideWindowFrameV1.position.set(2.05, 1.8, 0 + 0.4);
            sideWindowFrameV1.rotation.y = Math.PI / 2;
            house.add(sideWindowFrameV1);
            const sideWindowFrameV2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.1), windowFrameMaterial);
            sideWindowFrameV2.position.set(2.05, 1.8, 0 - 0.4);
            sideWindowFrameV2.rotation.y = Math.PI / 2;
            house.add(sideWindowFrameV2);

            // –¢–æ—á–µ—á–Ω—ã–π —Å–≤–µ—Ç –¥–ª—è –±–æ–∫–æ–≤–æ–≥–æ –æ–∫–Ω–∞
            const sideWindowLight = new THREE.PointLight(0xFFE0B2, daySettings.windowLightIntensity, 5); 
            sideWindowLight.position.set(1.95, 1.8, 0); 
            sideWindowLight.castShadow = true;
            house.add(sideWindowLight);
            windowLights.push(sideWindowLight); 

            // –î—ã–º–æ—Ö–æ–¥
            const chimneyGeometry = new THREE.BoxGeometry(0.6, 1.5, 0.6);
            const chimneyMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.7, metalness: 0.0 });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(-1.2, 4.5, -1.2); 
            chimney.castShadow = true;
            house.add(chimney);

            // –°—Ç—É–ø–µ–Ω–∏
            // –î–æ–±–∞–≤–ª–µ–Ω—ã polygonOffset –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            const stepsMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, polygonOffset: true, polygonOffsetFactor: -3, polygonOffsetUnits: 1 });
            const step1 = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.4), stepsMaterial);
            step1.position.set(0, 0.05, 2.2);
            step1.castShadow = true;
            step1.receiveShadow = true;
            house.add(step1);
            const step2 = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.1, 0.4), stepsMaterial);
            step2.position.set(0, -0.05, 2.5);
            step2.castShadow = true;
            step2.receiveShadow = true;
            house.add(step2);

            // –î–µ—Ä–µ–≤—è–Ω–Ω—ã–π –Ω–∞—Å—Ç–∏–ª –≤–æ–∫—Ä—É–≥ –¥–æ–º–∞
            const deckGeometry = new THREE.BoxGeometry(5, 0.1, 5); // –ë–æ–ª—å—à–µ, —á–µ–º –¥–æ–º
            // –î–æ–±–∞–≤–ª–µ–Ω—ã polygonOffset –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            const deckMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.6, metalness: 0.0, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: 1 });
            const deck = new THREE.Mesh(deckGeometry, deckMaterial);
            deck.position.y = 0.01; // –ß—É—Ç—å –≤—ã—à–µ —É—Ä–æ–≤–Ω—è –∑–µ–º–ª–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            deck.castShadow = true;
            deck.receiveShadow = true;
            house.add(deck);


            scene.add(house);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∏–≥—Ä–æ–∫–∞.
         */
        function createPlayer() {
            player = new THREE.Group();

            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 16); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1, roughness: 0.5 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6; 
            body.castShadow = true;
            player.add(body);

            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3, roughness: 0.6 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.45; 
            head.castShadow = true;
            player.add(head);

            // –ì–ª–∞–∑–∞
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.5, 0.2); 
            player.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.5, 0.2); 
            player.add(rightEye);

            // –†—É–∫–∏
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3, roughness: 0.6 });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.45, 0.8, 0); 
            leftArm.castShadow = true;
            player.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.45, 0.8, 0); 
            rightArm.castShadow = true;
            player.add(rightArm);

            // –ù–æ–≥–∏
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.7 });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, -0.4, 0); 
            leftLeg.castShadow = true;
            player.add(leftLeg);
            player.userData.leftLeg = leftLeg; 

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, -0.4, 0); 
            rightLeg.castShadow = true;
            player.add(rightLeg);
            player.userData.rightLeg = rightLeg; 

            // –¢–æ—á–∫–∞ –∫—Ä–µ–ø–ª–µ–Ω–∏—è –¥–ª—è –±—Ä–µ–≤–Ω–∞/–∫–∞–º–Ω—è –≤ —Ä—É–∫–µ –∏–≥—Ä–æ–∫–∞
            player.userData.hand = new THREE.Group();
            player.userData.hand.position.set(0.4, 1.0, 0.3); // –ü—Ä–∏–º–µ—Ä–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ä—É–∫–µ
            player.add(player.userData.hand);

            player.position.copy(playerPosition); 
            scene.add(player);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–ª–æ—Å–∫–æ—Å—Ç—å –∑–µ–º–ª–∏.
         */
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(200, 200); // –£–¥–≤–æ–µ–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x90EE90, roughness: 0.9, metalness: 0.0 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–µ–Ω–µ–∫, –∫–æ—Ç–æ—Ä—ã–π –ø–æ—è–≤–ª—è–µ—Ç—Å—è –ø–æ—Å–ª–µ —Å–±–æ—Ä–∞ –≤—Å–µ—Ö –±—Ä–µ–≤–µ–Ω —Å –¥–µ—Ä–µ–≤–∞.
         * @returns {THREE.Mesh} –ú–µ—à –ø–µ–Ω—å–∫–∞.
         */
        function createStump() {
            const stumpGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.5, 8); // –®–∏—Ä–µ –∏ –∫–æ—Ä–æ—á–µ —Å—Ç–≤–æ–ª–∞
            const stumpMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.8 }); // –¢–µ–º–Ω–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π
            const stump = new THREE.Mesh(stumpGeometry, stumpMaterial);
            stump.position.y = 0.25; // –ü–æ–ª–æ–≤–∏–Ω–∞ –≤—ã—Å–æ—Ç—ã –ø–µ–Ω—å–∫–∞
            stump.castShadow = true;
            stump.receiveShadow = true;
            return stump;
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ç–∏–ø—ã –¥–µ—Ä–µ–≤—å–µ–≤ (–ª–∏—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏ –µ–ª–∏) –∏ —Ä–∞–∑–º–µ—â–∞–µ—Ç –∏—Ö, –∏–∑–±–µ–≥–∞—è –¥–æ–º–∞ –∏ –æ–∑–µ—Ä–∞.
         */
        function createTrees() {
            const numDeciduousTrees = 60; // –£–¥–≤–æ–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ –≤ –±–æ–ª—å—à–µ–º –º–∏—Ä–µ
            const numFirTrees = 80;      // –£–¥–≤–æ–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –¥–æ–º–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const houseMinX = -2;
            const houseMaxX = 2;
            const houseMinZ = -2;
            const houseMaxZ = 2;

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –∫—Ä—É–≥ –æ–∑–µ—Ä–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π (–º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –∏ —Ä–∞–¥–∏—É—Å)
            const lakeCenterX = 60; // –£–¥–≤–æ–µ–Ω–æ
            const lakeCenterZ = 0;
            const lakeRadius = 30; // –£–¥–≤–æ–µ–Ω–æ
            const lakeBuffer = 6; // –£–¥–≤–æ–µ–Ω–Ω–∞—è –±—É—Ñ–µ—Ä–Ω–∞—è –∑–æ–Ω–∞

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ —Å–∞—Ä–∞–π—á–∏–∫–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const barnMinX = -40 - 2; // –ü–æ–∑–∏—Ü–∏—è —Å–∞—Ä–∞–π—á–∏–∫–∞ -2.5, —Ä–∞–∑–º–µ—Ä 5
            const barnMaxX = -40 + 2;
            const barnMinZ = 40 - 2;
            const barnMaxZ = 40 + 2;
            const barnBuffer = 3; // –ë—É—Ñ–µ—Ä–Ω–∞—è –∑–æ–Ω–∞ –≤–æ–∫—Ä—É–≥ —Å–∞—Ä–∞–π—á–∏–∫–∞

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const quarryMinX = 40 - 2; // –ü–æ–∑–∏—Ü–∏—è –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏ 40, —Ä–∞–∑–º–µ—Ä 5
            const quarryMaxX = 40 + 2;
            const quarryMinZ = -40 - 2;
            const quarryMaxZ = -40 + 2;
            const quarryBuffer = 3; // –ë—É—Ñ–µ—Ä–Ω–∞—è –∑–æ–Ω–∞ –≤–æ–∫—Ä—É–≥ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏


            // –õ–∏—Å—Ç–≤–µ–Ω–Ω—ã–µ –¥–µ—Ä–µ–≤—å—è
            const deciduousTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const deciduousFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });

            for (let i = 0; i < numDeciduousTrees; i++) {
                const tree = new THREE.Group();
                let treeX, treeZ;
                let isValidPosition = false;

                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏, –ø–æ–∫–∞ –æ–Ω–∞ –Ω–µ –æ–∫–∞–∂–µ—Ç—Å—è –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–æ–º–∞, –æ–∑–µ—Ä–∞, —Å–∞—Ä–∞–π—á–∏–∫–∞ –∏ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
                while (!isValidPosition) {
                    treeX = -90 + Math.random() * 180; // –£–¥–≤–æ–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
                    treeZ = -90 + Math.random() * 180; // –£–¥–≤–æ–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –¥–æ–º—É
                    const isNearHouse = (treeX >= houseMinX - 3 && treeX <= houseMaxX + 3 && 
                                        treeZ >= houseMinZ - 3 && treeZ <= houseMaxZ + 3);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –æ–∑–µ—Ä—É
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(treeX - lakeCenterX, 2) + 
                        Math.pow(treeZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (lakeRadius + lakeBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ —Å–∞—Ä–∞–π—á–∏–∫—É
                    const isNearBarn = (treeX >= barnMinX - barnBuffer && treeX <= barnMaxX + barnBuffer &&
                                        treeZ >= barnMinZ - barnBuffer && treeZ <= barnMaxZ + barnBuffer);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–µ
                    const isNearQuarry = (treeX >= quarryMinX - quarryBuffer && treeX <= quarryMaxX + quarryBuffer &&
                                          treeZ >= quarryMinZ - quarryBuffer && treeZ <= quarryMaxZ + quarryBuffer);

                    if (!isNearHouse && !isNearLake && !isNearBarn && !isNearQuarry) {
                        isValidPosition = true;
                    }
                }
                
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                const trunk = new THREE.Mesh(trunkGeometry, deciduousTrunkMaterial); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª —Å—Ç–≤–æ–ª–∞
                trunk.position.y = 1;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                tree.add(trunk);

                // –õ–∏—Å—Ç–≤–∞ –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Ñ–µ—Ä
                const numFoliageSpheres = 3 + Math.floor(Math.random() * 3); // 3-5 —Å—Ñ–µ—Ä
                for (let j = 0; j < numFoliageSpheres; j++) {
                    const foliageGeometry = new THREE.SphereGeometry(0.8 + Math.random() * 0.4, 16, 16); // –í–∞—Ä—å–∏—Ä—É—é—â–∏–µ—Å—è —Ä–∞–∑–º–µ—Ä—ã
                    const foliage = new THREE.Mesh(foliageGeometry, deciduousFoliageMaterial); 
                    foliage.position.set(
                        (Math.random() - 0.5) * 1.5, // –ù–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑–±—Ä–æ—Å –ø–æ X
                        2.5 + (Math.random() - 0.5) * 0.5, // –ù–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑–±—Ä–æ—Å –ø–æ Y
                        (Math.random() - 0.5) * 1.5  // –ù–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑–±—Ä–æ—Å –ø–æ Z
                    );
                    foliage.castShadow = true;
                    tree.add(foliage);
                }

                tree.position.x = treeX; 
                tree.position.z = treeZ; 
                tree.scale.setScalar(0.7 + Math.random() * 0.6); 
                tree.userData.isCollectible = true; // –ü–æ–º–µ—á–∞–µ–º, —á—Ç–æ —ç—Ç–æ –¥–µ—Ä–µ–≤–æ, —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –º–æ–∂–Ω–æ –≤–∑—è—Ç—å –±—Ä–µ–≤–Ω–æ
                tree.userData.type = 'log'; // –¢–∏–ø —Ä–µ—Å—É—Ä—Å–∞
                tree.userData.logsRemaining = 10; // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –∏–º–µ–µ—Ç 10 –±—Ä–µ–≤–µ–Ω
                tree.userData.originalFoliage = tree.children.filter(c => c.isMesh && c.geometry.type === 'SphereGeometry'); // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ –ª–∏—Å—Ç–≤—É
                collectibleTrees.push(tree); // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤ —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤
                scene.add(tree);
            }

            // –ï–ª–∏ (—Ö–≤–æ–π–Ω—ã–µ)
            const firTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.8 }); 
            const firFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 0.7 }); 

            for (let i = 0; i < numFirTrees; i++) {
                const firTree = new THREE.Group();
                let treeX, treeZ;
                let isValidPosition = false;

                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏, –ø–æ–∫–∞ –æ–Ω–∞ –Ω–µ –æ–∫–∞–∂–µ—Ç—Å—è –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–æ–º–∞, –æ–∑–µ—Ä–∞, —Å–∞—Ä–∞–π—á–∏–∫–∞ –∏ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
                while (!isValidPosition) {
                    treeX = -90 + Math.random() * 180; // –£–¥–≤–æ–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
                    treeZ = -90 + Math.random() * 180; // –£–¥–≤–æ–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –¥–æ–º—É
                    const isNearHouse = (treeX >= houseMinX - 3 && treeX <= houseMaxX + 3 && 
                                        treeZ >= houseMinZ - 3 && treeZ <= houseMaxZ + 3);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –æ–∑–µ—Ä—É
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(treeX - lakeCenterX, 2) + 
                        Math.pow(treeZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (lakeRadius + lakeBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ —Å–∞—Ä–∞–π—á–∏–∫—É
                    const isNearBarn = (treeX >= barnMinX - barnBuffer && treeX <= barnMaxX + barnBuffer &&
                                        treeZ >= barnMinZ - barnBuffer && treeZ <= barnMaxZ + barnBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–µ
                    const isNearQuarry = (treeX >= quarryMinX - quarryBuffer && treeX <= quarryMaxX + quarryBuffer &&
                                          treeZ >= quarryMinZ - quarryBuffer && treeZ <= quarryMaxZ + quarryBuffer);


                    if (!isNearHouse && !isNearLake && !isNearBarn && !isNearQuarry) {
                        isValidPosition = true;
                    }
                }

                const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.25, 2.5, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                const trunk = new THREE.Mesh(trunkGeometry, firTrunkMaterial);
                trunk.position.y = 1.25;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                firTree.add(trunk);

                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–¥–Ω—É –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –¥–ª—è –º–µ—à–µ–π –ª–∏—Å—Ç–≤—ã –≤–Ω—É—Ç—Ä–∏ —Ü–∏–∫–ª–∞
                let foliageGeometry;
                let foliageMesh;

                foliageGeometry = new THREE.ConeGeometry(1.5, 2, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial);
                foliageMesh.position.y = 2.5;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                foliageGeometry = new THREE.ConeGeometry(1.0, 1.5, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial);
                foliageMesh.position.y = 3.5;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                foliageGeometry = new THREE.ConeGeometry(0.6, 1.0, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial); 
                foliageMesh.position.y = 4.2;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                firTree.position.x = treeX; 
                firTree.position.z = treeZ; 
                firTree.scale.setScalar(0.8 + Math.random() * 0.7); 
                firTree.userData.isCollectible = true; // –ü–æ–º–µ—á–∞–µ–º, —á—Ç–æ —ç—Ç–æ –¥–µ—Ä–µ–≤–æ, —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –º–æ–∂–Ω–æ –≤–∑—è—Ç—å –±—Ä–µ–≤–Ω–æ
                firTree.userData.type = 'log'; // –¢–∏–ø —Ä–µ—Å—É—Ä—Å–∞
                firTree.userData.logsRemaining = 10; // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –∏–º–µ–µ—Ç 10 –±—Ä–µ–≤–µ–Ω
                firTree.userData.originalFoliage = firTree.children.filter(c => c.isMesh && c.geometry.type.includes('ConeGeometry')); // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ –ª–∏—Å—Ç–≤—É
                collectibleTrees.push(firTree); // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤ —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤
                scene.add(firTree);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –æ–∑–µ—Ä–æ —Å —Ä—ã–±–æ–π.
         */
        function createLake() {
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–æ—á–∫–∏ –¥–ª—è –Ω–µ—Ä–µ–≥—É–ª—è—Ä–Ω–æ–π —Ñ–æ—Ä–º—ã –æ–∑–µ—Ä–∞
            const shapePoints = [
                new THREE.Vector2(0, 15),
                new THREE.Vector2(8, 12),
                new THREE.Vector2(13, 5),
                new THREE.Vector2(15, -5),
                new THREE.Vector2(10, -12),
                new THREE.Vector2(0, -15),
                new THREE.Vector2(-10, -12),
                new THREE.Vector2(-15, -5),
                new THREE.Vector2(-13, 5),
                new THREE.Vector2(-8, 12)
            ];
            // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º —Ç–æ—á–∫–∏, —á—Ç–æ–±—ã —É–¥–≤–æ–∏—Ç—å —Ä–∞–∑–º–µ—Ä –æ–∑–µ—Ä–∞
            const scaledShapePoints = shapePoints.map(p => new THREE.Vector2(p.x * 2, p.y * 2));

            const lakeShape = new THREE.Shape(scaledShapePoints);
            const lakeGeometry = new THREE.ShapeGeometry(lakeShape); 
            
            // –ú–∞—Ç–µ—Ä–∏–∞–ª –≤–æ–¥—ã —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é –∏ –æ—Ç—Ä–∞–∂–∞—Ç–µ–ª—å–Ω–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å—é
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x0066FF, 
                transparent: true,
                opacity: 0.7,
                roughness: 0.1, // –ù–∏–∑–∫–∞—è —à–µ—Ä–æ—Ö–æ–≤–∞—Ç–æ—Å—Ç—å –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –æ—Ç—Ä–∞–∂–µ–Ω–∏—è
                metalness: 0.8, // –í—ã—Å–æ–∫–∞—è –º–µ—Ç–∞–ª–ª–∏—á–Ω–æ—Å—Ç—å –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –æ—Ç—Ä–∞–∂–µ–Ω–∏—è
                side: THREE.DoubleSide 
            });
            const lake = new THREE.Mesh(lakeGeometry, waterMaterial);
            lake.rotation.x = -Math.PI / 2; 
            lake.position.set(60, 0.01, 0); // –£–¥–≤–æ–µ–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –ø–æ X
            scene.add(lake);

            // –†—ã–±–∞
            const numFish = 10;
            const fishGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.2); 
            const fishMaterial = new THREE.MeshStandardMaterial({ color: 0xFF8C00 }); 

            const fishBoundaryRadius = 36; // –£–¥–≤–æ–µ–Ω–æ

            for (let i = 0; i < numFish; i++) {
                const f = new THREE.Mesh(fishGeometry, fishMaterial);
                f.position.set(
                    lake.position.x + (Math.random() - 0.5) * fishBoundaryRadius * 1.8, 
                    lake.position.y - (0.1 + Math.random() * 0.3), 
                    lake.position.z + (Math.random() - 0.5) * fishBoundaryRadius * 1.8
                );
                f.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.025, 
                    0,
                    (Math.random() - 0.5) * 0.025 
                );
                f.userData.swimCycle = Math.random() * Math.PI * 2; 
                scene.add(f);
                fish.push(f);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —Ä–∞—Å—Ç–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤–æ–∫—Ä—É–≥ –æ–∑–µ—Ä–∞ (–∫—É—Å—Ç—ã –∏ –∫–∞–º—ã—à–∏).
         */
        function createLakeVegetation() {
            const lakeCenterX = 60; // –£–¥–≤–æ–µ–Ω–æ
            const lakeCenterZ = 0;
            const lakeRadius = 30; // –£–¥–≤–æ–µ–Ω–æ
            const numBushes = 60; // –£–¥–≤–æ–µ–Ω–æ
            const numReeds = 100; // –£–¥–≤–æ–µ–Ω–æ

            const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x558B2F, roughness: 0.8 });
            for (let i = 0; i < numBushes; i++) {
                const bush = new THREE.Mesh(new THREE.SphereGeometry(0.3 + Math.random() * 0.3, 12, 12), bushMaterial); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                
                const angle = Math.random() * Math.PI * 2;
                const distance = lakeRadius + 4 + Math.random() * 10; // –£–¥–≤–æ–µ–Ω–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∏ –¥–∏–∞–ø–∞–∑–æ–Ω
                bush.position.set(
                    lakeCenterX + Math.cos(angle) * distance,
                    0.15, 
                    lakeCenterZ + Math.sin(angle) * distance
                );
                bush.scale.y = 0.7 + Math.random() * 0.6; 
                bush.castShadow = true;
                bush.receiveShadow = true;
                scene.add(bush);
            }

            const reedStemMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
            const reedHeadMaterial = new THREE.MeshStandardMaterial({ color: 0x6B8E23, roughness: 0.7 });
            for (let i = 0; i < numReeds; i++) {
                const reed = new THREE.Group();
                const height = 0.8 + Math.random() * 0.7;

                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, height, 8), reedStemMaterial); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                stem.position.y = height / 2;
                stem.castShadow = true;
                stem.receiveShadow = true;
                reed.add(stem);

                const head = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.08), reedHeadMaterial);
                head.position.y = height + 0.1;
                head.rotation.y = Math.random() * Math.PI;
                head.castShadow = true;
                reed.add(head);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = lakeRadius - 2 + Math.random() * 4; // –£–¥–≤–æ–µ–Ω–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∏ –¥–∏–∞–ø–∞–∑–æ–Ω
                reed.position.set(
                    lakeCenterX + Math.cos(angle) * distance,
                    0, 
                    lakeCenterZ + Math.sin(angle) * distance
                );
                reed.rotation.y = Math.random() * Math.PI * 2; 
                reed.rotation.z = (Math.random() - 0.5) * 0.2; 
                scene.add(reed);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–∏—Ä—Å –∏ –ª–æ–¥–∫—É –Ω–∞ –æ–∑–µ—Ä–µ.
         */
        function createPierAndBoat() {
            const lakeCenter = new THREE.Vector3(60, 0.01, 0); // –£–¥–≤–æ–µ–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –ø–æ X

            // –°–æ–∑–¥–∞–µ–º –ø–∏—Ä—Å
            const pierMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6 }); 
            
            // –û—Å–Ω–æ–≤–Ω–∞—è —á–∞—Å—Ç—å –ø–∏—Ä—Å–∞
            const pierBaseGeometry = new THREE.BoxGeometry(1.5, 0.2, 5); 
            const pierBase = new THREE.Mesh(pierBaseGeometry, pierMaterial);
            pierBase.position.set(lakeCenter.x + 20, lakeCenter.y + pierBaseGeometry.parameters.height / 2 + 0.01, lakeCenter.z + 10); // –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –ø–æ X
            pierBase.castShadow = true;
            pierBase.receiveShadow = true;
            scene.add(pierBase);

            // –û–ø–æ—Ä—ã –ø–∏—Ä—Å–∞
            const pierLegGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
            for (let i = 0; i < 3; i++) {
                const leg1 = new THREE.Mesh(pierLegGeometry, pierMaterial);
                leg1.position.set(pierBase.position.x - 0.5, lakeCenter.y - 0.4, pierBase.position.z - 1.5 + i * 1.5);
                leg1.castShadow = true;
                scene.add(leg1);

                const leg2 = new THREE.Mesh(pierLegGeometry, pierMaterial);
                leg2.position.set(pierBase.position.x + 0.5, lakeCenter.y - 0.4, pierBase.position.z - 1.5 + i * 1.5);
                leg2.castShadow = true;
                scene.add(leg2);
            }

            // –°–æ–∑–¥–∞–µ–º –ª–æ–¥–∫—É
            const boat = new THREE.Group();
            const boatMaterial = new THREE.MeshStandardMaterial({ color: 0x6A5ACD, roughness: 0.4, metalness: 0.1 }); 
            const boatInsideMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6 }); 

            // –ö–æ—Ä–ø—É—Å –ª–æ–¥–∫–∏ (–æ—Å–Ω–æ–≤–Ω–∞—è —á–∞—Å—Ç—å)
            const boatHullGeometry = new THREE.BoxGeometry(0.8, 0.3, 2.5);
            const boatHull = new THREE.Mesh(boatHullGeometry, boatMaterial);
            boatHull.position.y = 0; 
            boat.add(boatHull);

            // –ù–æ—Å –ª–æ–¥–∫–∏ (–∫–æ–Ω—É—Å –∏–ª–∏ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–∞—è —Ñ–æ—Ä–º–∞)
            const boatFrontGeometry = new THREE.ConeGeometry(0.4, 0.5, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const boatFront = new THREE.Mesh(boatFrontGeometry, boatMaterial);
            boatFront.rotation.x = Math.PI / 2; 
            boatFront.position.set(0, 0, 1.25); 
            boat.add(boatFront);

            // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —á–∞—Å—Ç—å (—Å–∏–¥–µ–Ω—å–µ)
            const seatGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.5);
            const seat = new THREE.Mesh(seatGeometry, boatInsideMaterial);
            seat.position.set(0, 0.1, 0); 
            boat.add(seat);

            // –†–∞–∑–º–µ—â–∞–µ–º –ª–æ–¥–∫—É –Ω–∞ —É—Ä–æ–≤–Ω–µ –æ–∑–µ—Ä–∞
            boat.position.set(pierBase.position.x + 2, lakeCenter.y + boatHullGeometry.parameters.height / 2, pierBase.position.z + 1.5); // –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –ø–æ X
            boat.rotation.y = -Math.PI / 4; 
            boat.castShadow = true;
            boat.receiveShadow = true;
            scene.add(boat);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –∫—Ä—É–≥–æ–≤–æ–π –∑–∞–±–æ—Ä –≤–æ–∫—Ä—É–≥ –¥–æ–º–∞.
         */
        function createFence() {
            const fenceRadius = 6; 
            const fenceHeight = 0.8;
            const postRadius = 0.08;
            const numPosts = 32; // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç–æ–ª–±–æ–≤ –¥–ª—è –±–æ–ª–µ–µ –≥–ª–∞–¥–∫–æ–≥–æ –∫—Ä—É–≥–∞

            const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 }); 

            const posts = [];
            for (let i = 0; i < numPosts; i++) {
                const angle = (i / numPosts) * Math.PI * 2;
                const x = Math.cos(angle) * fenceRadius;
                const z = Math.sin(angle) * fenceRadius;
                posts.push(new THREE.Vector3(x, fenceHeight / 2, z));
            }

            // –°–æ–∑–¥–∞–µ–º —Å—Ç–æ–ª–±—ã –∑–∞–±–æ—Ä–∞
            const fencePostGeometry = new THREE.CylinderGeometry(postRadius, postRadius, fenceHeight, 8);
            posts.forEach(pos => {
                const post = new THREE.Mesh(fencePostGeometry, fenceMaterial);
                post.position.copy(pos);
                post.castShadow = true;
                post.receiveShadow = true;
                scene.add(post);
            });
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –∫—Ä–æ–ª–∏–∫–æ–≤ —Å –ø–ª–∞–≤–Ω—ã–º –¥–≤–∏–∂–µ–Ω–∏–µ–º –≤–ø–µ—Ä–µ–¥/–Ω–∞–∑–∞–¥ –∏ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ–º.
         */
        function createRabbits() {
            const numRabbits = 3; 
            const rabbitMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5DC, roughness: 0.7 }); 
            const rabbitScale = 0.6; // –£–≤–µ–ª–∏—á–µ–Ω –º–∞—Å—à—Ç–∞–± –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∏/–∫—Ä—É–≥–∏ –¥–æ–º–∞ –∏ –æ–∑–µ—Ä–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const houseMinX = -2;
            const houseMaxX = 2;
            const houseMinZ = -2;
            const houseMaxZ = 2;

            const lakeCenterX = 60; // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–æ
            const lakeCenterZ = 0;
            const lakeRadius = 30; // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–æ
            const exclusionBuffer = 4; // –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –±—É—Ñ–µ—Ä–Ω–∞—è –∑–æ–Ω–∞

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ —Å–∞—Ä–∞–π—á–∏–∫–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const barnMinX = -40 - 2; // –ü–æ–∑–∏—Ü–∏—è —Å–∞—Ä–∞–π—á–∏–∫–∞ -2.5, —Ä–∞–∑–º–µ—Ä 5
            const barnMaxX = -40 + 2;
            const barnMinZ = 40 - 2;
            const barnMaxZ = 40 + 2;
            const barnBuffer = 3; // –ë—É—Ñ–µ—Ä–Ω–∞—è –∑–æ–Ω–∞ –≤–æ–∫—Ä—É–≥ —Å–∞—Ä–∞–π—á–∏–∫–∞

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const quarryMinX = 40 - 2; // –ü–æ–∑–∏—Ü–∏—è –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏ 40, —Ä–∞–∑–º–µ—Ä 5
            const quarryMaxX = 40 + 2;
            const quarryMinZ = -40 - 2;
            const quarryMaxZ = -40 + 2;
            const quarryBuffer = 3; // –ë—É—Ñ–µ—Ä–Ω–∞—è –∑–æ–Ω–∞ –≤–æ–∫—Ä—É–≥ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏

            // –°–≤–æ–π—Å—Ç–≤–∞ –¥–≤–∏–∂–µ–Ω–∏—è –¥–ª—è –∫—Ä–æ–ª–∏–∫–æ–≤ (–ø–ª–∞–≤–Ω–∞—è –æ—Å—Ü–∏–ª–ª—è—Ü–∏—è)
            const rabbitOscillationSpeed = 0.001; // –ë–æ–ª–µ–µ –Ω–∏–∑–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è –æ—Å—Ü–∏–ª–ª—è—Ü–∏–∏
            const rabbitOscillationAmplitude = 5; // –£–≤–µ–ª–∏—á–µ–Ω–∞ –∞–º–ø–ª–∏—Ç—É–¥–∞ –¥–ª—è –±–æ–ª–µ–µ –∑–∞–º–µ—Ç–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è

            for (let i = 0; i < numRabbits; i++) {
                const rabbit = new THREE.Group();
                let rabbitX, rabbitZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    rabbitX = -90 + Math.random() * 180; // –£–¥–≤–æ–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
                    rabbitZ = -90 + Math.random() * 180; // –£–¥–≤–æ–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –∫—Ä–æ–ª–∏–∫ –±–ª–∏–∑–∫–æ –∫ –¥–æ–º—É
                    const isNearHouse = (rabbitX >= houseMinX - exclusionBuffer && rabbitX <= houseMaxX + exclusionBuffer && 
                                        rabbitZ >= houseMinZ - exclusionBuffer && rabbitZ <= houseMaxZ + exclusionBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –∫—Ä–æ–ª–∏–∫ –±–ª–∏–∑–∫–æ –∫ –æ–∑–µ—Ä—É
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(rabbitX - lakeCenterX, 2) + 
                        Math.pow(rabbitZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (lakeRadius + exclusionBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –∫—Ä–æ–ª–∏–∫ –±–ª–∏–∑–∫–æ –∫ —Å–∞—Ä–∞–π—á–∏–∫—É
                    const isNearBarn = (rabbitX >= barnMinX - barnBuffer && rabbitX <= barnMaxX + barnBuffer &&
                                        rabbitZ >= barnMinZ - barnBuffer && rabbitZ <= barnMaxZ + barnBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –∫—Ä–æ–ª–∏–∫ –±–ª–∏–∑–∫–æ –∫ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–µ
                    const isNearQuarry = (rabbitX >= quarryMinX - quarryBuffer && rabbitX <= quarryMaxX + quarryBuffer &&
                                          rabbitZ >= quarryMinZ - quarryBuffer && rabbitZ <= quarryMaxZ + quarryBuffer);


                    if (!isNearHouse && !isNearLake && !isNearBarn && !isNearQuarry) {
                        isValidPosition = true;
                    }
                }

                // –¢–µ–ª–æ
                const bodyGeometry = new THREE.SphereGeometry(0.8 * rabbitScale, 24, 12); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                const body = new THREE.Mesh(bodyGeometry, rabbitMaterial);
                body.position.y = 0.4 * rabbitScale; 
                body.scale.z = 1.5; 
                body.castShadow = true;
                body.receiveShadow = true;
                rabbit.add(body);

                // –ì–æ–ª–æ–≤–∞
                const headGeometry = new THREE.SphereGeometry(0.5 * rabbitScale, 24, 12); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                const head = new THREE.Mesh(headGeometry, rabbitMaterial);
                head.position.set(0.6 * rabbitScale, 0.8 * rabbitScale, 0); 
                head.castShadow = true;
                rabbit.add(head);

                // –£—à–∏
                const earGeometry = new THREE.BoxGeometry(0.2 * rabbitScale, 1.2 * rabbitScale, 0.2 * rabbitScale); 
                const leftEar = new THREE.Mesh(earGeometry, rabbitMaterial);
                leftEar.position.set(0.7 * rabbitScale, 1.6 * rabbitScale, 0.3 * rabbitScale); 
                leftEar.rotation.z = Math.PI / 10;
                leftEar.castShadow = true;
                rabbit.add(leftEar);

                const rightEar = new THREE.Mesh(earGeometry, rabbitMaterial);
                rightEar.position.set(0.7 * rabbitScale, 1.6 * rabbitScale, -0.3 * rabbitScale); 
                rightEar.rotation.z = -Math.PI / 10;
                rightEar.castShadow = true;
                rabbit.add(rightEar);

                // –•–≤–æ—Å—Ç
                const tailGeometry = new THREE.SphereGeometry(0.3 * rabbitScale, 16, 16); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                const tailMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.7 }); 
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.position.set(-1.0 * rabbitScale, 0.4 * rabbitScale, 0); 
                tail.castShadow = true;
                rabbit.add(tail);

                rabbit.position.set(rabbitX, 0, rabbitZ); 
                rabbit.rotation.y = Math.random() * Math.PI * 2; // –°–ª—É—á–∞–π–Ω–æ–µ –Ω–∞—á–∞–ª—å–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
                rabbit.userData.initialRotationY = rabbit.rotation.y; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
                rabbit.userData.offset = Math.random() * Math.PI * 2; // –£–Ω–∏–∫–∞–ª—å–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è
                
                rabbit.userData.initialPosition = rabbit.position.clone(); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –æ—Å—Ü–∏–ª–ª—è—Ü–∏–∏
                rabbit.userData.oscillationSpeed = rabbitOscillationSpeed + (Math.random() - 0.5) * 0.0002; // –ù–µ–º–Ω–æ–≥–æ –≤–∞—Ä—å–∏—Ä—É—é—â–∞—è—Å—è —Å–∫–æ—Ä–æ—Å—Ç—å
                rabbit.userData.oscillationAmplitude = rabbitOscillationAmplitude + (Math.random() - 0.5) * 0.5; // –ù–µ–º–Ω–æ–≥–æ –≤–∞—Ä—å–∏—Ä—É—é—â–∞—è—Å—è –∞–º–ø–ª–∏—Ç—É–¥–∞
                rabbit.userData.oscillationOffset = Math.random() * Math.PI * 2; // –£–Ω–∏–∫–∞–ª—å–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –æ—Å—Ü–∏–ª–ª—è—Ü–∏–∏

                scene.add(rabbit);
                rabbits.push(rabbit);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —á–∞—Å—Ç–∏—Ü—ã –¥—ã–º–∞ –¥–ª—è –¥—ã–º–æ—Ö–æ–¥–∞.
         */
        function createSmokeParticles() {
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0xDDDDDD,
                transparent: true,
                opacity: 0.6
            });

            for (let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(-1.2, 5.2 + i * 0.3, -1.2);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.02
                    ),
                    life: Math.random()
                };
                particles.push(particle);
                scene.add(particle);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —Ä–∞–∑–±—Ä–æ—Å–∞–Ω–Ω—ã–µ –∫–∞–º–Ω–∏/–∫–∞–º–Ω–∏ –ø–æ –º–µ—Å—Ç–Ω–æ—Å—Ç–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ç–µ–ø–µ—Ä—å —Ç–∞–∫–∂–µ —Å–æ–±–∏—Ä–∞–µ–º—ã.
         */
        function createRocks() {
            const numRocks = 150; // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑–±—Ä–æ—Å–∞–Ω–Ω—ã—Ö –∫–∞–º–Ω–µ–π
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9, metalness: 0.0 }); // –°–µ—Ä—ã–π —Ü–≤–µ—Ç –∫–∞–º–Ω—è

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–æ–Ω—ã –∏—Å–∫–ª—é—á–µ–Ω–∏—è (–¥–æ–º, –æ–∑–µ—Ä–æ, —Å–∞—Ä–∞–π—á–∏–∫, –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω—è)
            const houseMinX = -2; const houseMaxX = 2;
            const houseMinZ = -2; const houseMaxZ = 2;
            const lakeCenterX = 60; const lakeCenterZ = 0;
            const lakeRadius = 30;
            const exclusionBuffer = 5; // –ë—É—Ñ–µ—Ä–Ω–∞—è –∑–æ–Ω–∞ –≤–æ–∫—Ä—É–≥ –¥–æ–º–∞/–æ–∑–µ—Ä–∞

            const barnMinX = -40 - 2;
            const barnMaxX = -40 + 2;
            const barnMinZ = 40 - 2;
            const barnMaxZ = 40 + 2;
            const barnBuffer = 3;

            const quarryMinX = 40 - 2;
            const quarryMaxX = 40 + 2;
            const quarryMinZ = -40 - 2;
            const quarryMaxZ = -40 + 2;
            const quarryBuffer = 3;

            for (let i = 0; i < numRocks; i++) {
                let rockX, rockZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    rockX = -90 + Math.random() * 180; // –ü–æ–ª–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –º–∏—Ä–∞
                    rockZ = -90 + Math.random() * 180; // –ü–æ–ª–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –º–∏—Ä–∞

                    const isNearHouse = (rockX >= houseMinX - exclusionBuffer && rockX <= houseMaxX + exclusionBuffer && 
                                        rockZ >= houseMinZ - exclusionBuffer && rockZ <= houseMaxZ + exclusionBuffer);
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(rockX - lakeCenterX, 2) + 
                        Math.pow(rockZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (lakeRadius + exclusionBuffer);

                    const isNearBarn = (rockX >= barnMinX - barnBuffer && rockX <= barnMaxX + barnBuffer &&
                                        rockZ >= barnMinZ - barnBuffer && rockZ <= barnMaxZ + barnBuffer);

                    const isNearQuarry = (rockX >= quarryMinX - quarryBuffer && rockX <= quarryMaxX + quarryBuffer &&
                                          rockZ >= quarryMinZ - quarryBuffer && rockZ <= quarryMaxZ + quarryBuffer);

                    if (!isNearHouse && !isNearLake && !isNearBarn && !isNearQuarry) {
                        isValidPosition = true;
                    }
                }

                // –°–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä –º–µ–∂–¥—É —Å—Ñ–µ—Ä–∏—á–µ—Å–∫–æ–π –∏–ª–∏ –∫—É–±–∏—á–µ—Å–∫–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–µ–π –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
                let rockGeometry;
                if (Math.random() > 0.5) {
                    rockGeometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.3, 8, 8); // –ù–µ–º–Ω–æ–≥–æ –±–æ–ª—å—à–µ –¥–ª—è –∑–∞–º–µ—Ç–Ω–æ—Å—Ç–∏
                } else {
                    rockGeometry = new THREE.BoxGeometry(0.4 + Math.random() * 0.6, 0.2 + Math.random() * 0.4, 0.4 + Math.random() * 0.6);
                }
                
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(rockX, rockGeometry.parameters.height / 2 || rockGeometry.parameters.radius || 0.15, rockZ); // –ù–µ–º–Ω–æ–≥–æ –≤—ã—à–µ
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.castShadow = true;
                rock.receiveShadow = true;

                // –ü–æ–º–µ—á–∞–µ–º –∫–∞–º–µ–Ω—å –∫–∞–∫ —Å–æ–±–∏—Ä–∞–µ–º—ã–π
                rock.userData.isCollectible = true;
                rock.userData.type = 'stone';
                rock.userData.logsRemaining = 10; // 10 "—É–¥–∞—Ä–æ–≤" –¥–æ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è (–ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–æ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)

                collectibleStones.push(rock); // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤ —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –∫–∞–º–Ω–µ–π
                scene.add(rock);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –æ–±–ª–∞–∫–∞ –≤ –Ω–µ–±–µ.
         */
        let cloudMeshes = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –º–µ—à–µ–π –æ–±–ª–∞–∫–æ–≤ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
        function createClouds() {
            const numClouds = 10;
            const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8, roughness: 0.5 });

            for (let i = 0; i < numClouds; i++) {
                const cloud = new THREE.Group();
                const numParts = 3 + Math.floor(Math.random() * 3); // 3-5 —á–∞—Å—Ç–µ–π –Ω–∞ –æ–±–ª–∞–∫–æ

                for (let j = 0; j < numParts; j++) {
                    const partGeometry = new THREE.SphereGeometry(3 + Math.random() * 2, 16, 16); // –í–∞—Ä—å–∏—Ä—É—é—â–∏–µ—Å—è —Ä–∞–∑–º–µ—Ä—ã
                    const part = new THREE.Mesh(partGeometry, cloudMaterial);
                    part.position.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 5
                    );
                    part.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    cloud.add(part);
                }

                cloud.position.set(
                    -90 + Math.random() * 180, // –®–∏—Ä–æ–∫–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω –ø–æ –≤—Å–µ–º—É –º–∏—Ä—É
                    30 + Math.random() * 10,  // –í—ã—Å–æ–∫–æ –≤ –Ω–µ–±–µ
                    -90 + Math.random() * 180
                );
                cloud.scale.setScalar(0.5 + Math.random()); // –í–∞—Ä—å–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—Ä –æ–±–ª–∞–∫–∞
                cloud.userData.speed = (Math.random() - 0.5) * 0.05; // –°–ª—É—á–∞–π–Ω–∞—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                scene.add(cloud);
                clouds.push(cloud);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–æ—á—Ç–æ–≤—ã–π —è—â–∏–∫ —Ä—è–¥–æ–º —Å –¥–æ–º–æ–º.
         */
        function createMailbox() {
            const mailbox = new THREE.Group();
            const postMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 }); // –ö–æ—Ä–∏—á–Ω–µ–≤—ã–π —Å—Ç–æ–ª–±
            const boxMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.6 }); // –ö—Ä–∞—Å–Ω—ã–π —è—â–∏–∫

            // –°—Ç–æ–ª–±
            const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.0, 8);
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 0.5;
            post.castShadow = true;
            post.receiveShadow = true;
            mailbox.add(post);

            // –Ø—â–∏–∫
            const boxGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.6);
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(0, 1.2, 0);
            box.castShadow = true;
            box.receiveShadow = true;
            mailbox.add(box);

            // –§–ª–∞–∂–æ–∫ (–º–∞–ª–µ–Ω—å–∫–∏–π —Ü–∏–ª–∏–Ω–¥—Ä)
            const flagGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4);
            const flagMaterial = new THREE.MeshStandardMaterial({ color: 0x0000FF, roughness: 0.5 }); // –°–∏–Ω–∏–π —Ñ–ª–∞–∂–æ–∫
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(0.2, 1.35, 0.2);
            flag.rotation.z = Math.PI / 2; // –î–µ–ª–∞–µ–º –µ–≥–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–º
            flag.castShadow = true;
            mailbox.add(flag);

            mailbox.position.set(-3, 0, 3); // –ü–æ–∑–∏—Ü–∏—è —Ä—è–¥–æ–º —Å –¥–æ–º–æ–º
            mailbox.rotation.y = Math.PI / 4; // –ù–µ–º–Ω–æ–≥–æ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º
            scene.add(mailbox);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø—Ä–æ—Å—Ç—É—é –≥—Ä—É–Ω—Ç–æ–≤—É—é –¥–æ—Ä–æ–∂–∫—É, –≤–µ–¥—É—â—É—é –∫ –¥–æ–º—É.
         */
        function createPath() {
            const pathMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 }); // –ö–æ—Ä–∏—á–Ω–µ–≤—ã–π —Ü–≤–µ—Ç –∑–µ–º–ª–∏
            const pathGeometry = new THREE.BoxGeometry(1.5, 0.01, 10); // –®–∏—Ä–∏–Ω–∞, –≤—ã—Å–æ—Ç–∞, –¥–ª–∏–Ω–∞
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.position.set(-1, 0.02, 0); // –ü–æ–∑–∏—Ü–∏—è –ø–µ—Ä–µ–¥ –¥–æ–º–æ–º, Y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –Ω–µ–º–Ω–æ–≥–æ —É–≤–µ–ª–∏—á–µ–Ω–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            path.receiveShadow = true;
            scene.add(path);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø—Ä–æ—Å—Ç—É—é –¥–µ—Ä–µ–≤—è–Ω–Ω—É—é —Å–∫–∞–º–µ–π–∫—É.
         */
        function createBench() {
            const bench = new THREE.Group();
            const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 }); // –î–µ—Ä–µ–≤—è–Ω–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª

            // –°–∏–¥–µ–Ω—å–µ
            const seatGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.4);
            const seat = new THREE.Mesh(seatGeometry, woodMaterial);
            seat.position.y = 0.4;
            seat.castShadow = true;
            seat.receiveShadow = true;
            bench.add(seat);

            // –ù–æ–∂–∫–∏
            const legGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);
            const leg1 = new THREE.Mesh(legGeometry, woodMaterial);
            leg1.position.set(-0.6, 0.2, 0.15);
            leg1.castShadow = true;
            leg1.receiveShadow = true;
            bench.add(leg1);
            const leg2 = new THREE.Mesh(legGeometry, woodMaterial);
            leg2.position.set(0.6, 0.2, 0.15);
            leg2.castShadow = true;
            leg2.receiveShadow = true;
            bench.add(leg2);
            const leg3 = new THREE.Mesh(legGeometry, woodMaterial);
            leg3.position.set(-0.6, 0.2, -0.15);
            leg3.castShadow = true;
            leg3.receiveShadow = true;
            bench.add(leg3);
            const leg4 = new THREE.Mesh(legGeometry, woodMaterial);
            leg4.position.set(0.6, 0.2, -0.15);
            leg4.castShadow = true;
            leg4.receiveShadow = true;
            bench.add(leg4);

            bench.position.set(-2, 0, -3); // –ü–æ–∑–∏—Ü–∏—è —Ä—è–¥–æ–º —Å –¥–æ–º–æ–º
            bench.rotation.y = Math.PI / 8;
            scene.add(bench);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –∫—É–≤—à–∏–Ω–∫–∏ –Ω–∞ –æ–∑–µ—Ä–µ.
         */
        function createLilyPads() {
            const lilyPadMaterial = new THREE.MeshStandardMaterial({ color: 0x32CD32, roughness: 0.7 }); // –ó–µ–ª–µ–Ω—ã–π —Ü–≤–µ—Ç –∫—É–≤—à–∏–Ω–∫–∏
            const flowerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFB6C1, roughness: 0.5 }); // –†–æ–∑–æ–≤—ã–π —Ü–≤–µ—Ç —Ü–≤–µ—Ç–∫–∞

            const lakeCenterX = 60;
            const lakeCenterZ = 0;
            const lakeRadius = 28; // –ß—É—Ç—å –º–µ–Ω—å—à–µ —Ä–∞–¥–∏—É—Å–∞ –æ–∑–µ—Ä–∞, —á—Ç–æ–±—ã –æ–Ω–∏ –±—ã–ª–∏ –≤–Ω—É—Ç—Ä–∏

            const numLilyPads = 20;

            for (let i = 0; i < numLilyPads; i++) {
                const lilyPad = new THREE.Group();
                const radius = 0.4 + Math.random() * 0.2;
                const padGeometry = new THREE.CircleGeometry(radius, 16); // –ö—Ä—É–≥–ª–∞—è –∫—É–≤—à–∏–Ω–∫–∞
                const pad = new THREE.Mesh(padGeometry, lilyPadMaterial);
                pad.rotation.x = -Math.PI / 2;
                pad.position.y = 0.02; // –ß—É—Ç—å –≤—ã—à–µ –≤–æ–¥—ã
                lilyPad.add(pad);

                // –î–æ–±–∞–≤–ª—è–µ–º –º–∞–ª–µ–Ω—å–∫–∏–π —Ü–≤–µ—Ç–æ–∫ –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∫—É–≤—à–∏–Ω–∫–∏
                if (Math.random() > 0.5) {
                    const flowerGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.05, 8);
                    const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.y = 0.04;
                    lilyPad.add(flower);
                }

                // –†–∞–∑–º–µ—â–∞–µ–º –∫—É–≤—à–∏–Ω–∫–∏ —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –≤–Ω—É—Ç—Ä–∏ –æ–∑–µ—Ä–∞
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * lakeRadius;
                lilyPad.position.set(
                    lakeCenterX + Math.cos(angle) * distance,
                    0, 
                    lakeCenterZ + Math.sin(angle) * distance
                );
                lilyPad.rotation.z = Math.random() * Math.PI * 2; // –°–ª—É—á–∞–π–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
                scene.add(lilyPad);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø—Ä–æ—Å—Ç—É—é –ø—Ç–∏—Ü—É, –∫–æ—Ç–æ—Ä–∞—è –ª–µ—Ç–∞–µ—Ç –ø–æ –∫—Ä—É–≥—É.
         */
        function createBird() {
            bird = new THREE.Group();
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4B0082, roughness: 0.5 }); // –¢–µ–º–Ω–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π

            // –¢–µ–ª–æ –ø—Ç–∏—Ü—ã
            const bodyGeometry = new THREE.SphereGeometry(0.3, 12, 12);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.scale.z = 2; // –í—ã—Ç—è–Ω—É—Ç–æ–µ —Ç–µ–ª–æ
            bird.add(body);

            // –ö—Ä—ã–ª—å—è
            const wingGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.8);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x6A5ACD, roughness: 0.5 }); // –°–≤–µ—Ç–ª–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.2, 0, 0);
            leftWing.rotation.y = Math.PI / 2;
            leftWing.rotation.x = Math.PI / 4; // –ù–∞—á–∞–ª—å–Ω—ã–π —É–≥–æ–ª –∫—Ä—ã–ª–∞
            bird.add(leftWing);
            bird.userData.leftWing = leftWing; // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏

            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.2, 0, 0);
            rightWing.rotation.y = -Math.PI / 2;
            rightWing.rotation.x = -Math.PI / 4; // –ù–∞—á–∞–ª—å–Ω—ã–π —É–≥–æ–ª –∫—Ä—ã–ª–∞
            bird.add(rightWing);
            bird.userData.rightWing = rightWing; // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏

            bird.position.set(0, 15, -20); // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –ø—Ç–∏—Ü—ã
            bird.userData.flightRadius = 50; // –†–∞–¥–∏—É—Å –ø–æ–ª–µ—Ç–∞
            bird.userData.flightSpeed = 0.005; // –°–∫–æ—Ä–æ—Å—Ç—å –ø–æ–ª–µ—Ç–∞
            bird.userData.flightAngle = Math.random() * Math.PI * 2; // –ù–∞—á–∞–ª—å–Ω—ã–π —É–≥–æ–ª –ø–æ–ª–µ—Ç–∞
            bird.userData.wingFlapSpeed = 0.2; // –°–∫–æ—Ä–æ—Å—Ç—å –º–∞—Ö–∞ –∫—Ä—ã–ª—å—è–º–∏
            bird.userData.wingFlapAmplitude = 0.5; // –ê–º–ø–ª–∏—Ç—É–¥–∞ –º–∞—Ö–∞ –∫—Ä—ã–ª—å—è–º–∏

            scene.add(bird);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —Å–≤–µ—Ç–ª—è—á–∫–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ—è–≤–ª—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –Ω–æ—á—å—é.
         */
        function createFireflies() {
            const fireflyMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, transparent: true, opacity: 0.0 }); // –ñ–µ–ª—Ç—ã–π, –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –Ω–µ–≤–∏–¥–∏–º—ã–π
            const fireflyGeometry = new THREE.SphereGeometry(0.05, 8, 8);

            const numFireflies = 50;
            for (let i = 0; i < numFireflies; i++) {
                const firefly = new THREE.Mesh(fireflyGeometry, fireflyMaterial.clone()); // –ö–ª–æ–Ω–∏—Ä—É–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–π –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
                firefly.position.set(
                    -90 + Math.random() * 180,
                    1 + Math.random() * 5, // –í—ã—Å–æ—Ç–∞ –Ω–∞–¥ –∑–µ–º–ª–µ–π
                    -90 + Math.random() * 180
                );
                firefly.userData.speed = 0.01 + Math.random() * 0.02; // –°–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è
                firefly.userData.offset = Math.random() * Math.PI * 2; // –°–º–µ—â–µ–Ω–∏–µ –¥–ª—è –º–µ—Ä—Ü–∞–Ω–∏—è
                firefly.userData.initialPosition = firefly.position.clone(); // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
                fireflies.push(firefly);
                scene.add(firefly);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —Å–∞—Ä–∞–π—á–∏–∫ (–Ω–µ–±–æ–ª—å—à–æ–π –¥–æ–º–∏–∫) –≤ –ª–µ—Å—É.
         */
        function createBarn() {
            const barn = new THREE.Group();
            const barnWoodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 }); // –ö–æ—Ä–∏—á–Ω–µ–≤–æ–µ –¥–µ—Ä–µ–≤–æ
            const barnRoofMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.6 }); // –¢–µ–º–Ω–æ-–∫–æ—Ä–∏—á–Ω–µ–≤–∞—è –∫—Ä—ã—à–∞

            // –°—Ç–µ–Ω—ã —Å–∞—Ä–∞–π—á–∏–∫–∞
            const barnBodyGeometry = new THREE.BoxGeometry(5, 3, 4);
            const barnBody = new THREE.Mesh(barnBodyGeometry, barnWoodMaterial);
            barnBody.position.y = 1.5;
            barnBody.castShadow = true;
            barnBody.receiveShadow = true;
            barn.add(barnBody);

            // –ö—Ä—ã—à–∞ —Å–∞—Ä–∞–π—á–∏–∫–∞ (–¥–≤—É—Å–∫–∞—Ç–Ω–∞—è)
            const barnRoofGeometry = new THREE.ConeGeometry(3.5, 2, 4, 8); // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ConeGeometry —Å 4 —Å–µ–≥–º–µ–Ω—Ç–∞–º–∏ –¥–ª—è –ø–∏—Ä–∞–º–∏–¥–∞–ª—å–Ω–æ–π –∫—Ä—ã—à–∏
            const barnRoof = new THREE.Mesh(barnRoofGeometry, barnRoofMaterial);
            barnRoof.position.y = 3 + 1; // –í—ã—Å–æ—Ç–∞ —Å—Ç–µ–Ω + –ø–æ–ª–æ–≤–∏–Ω–∞ –≤—ã—Å–æ—Ç—ã –∫—Ä—ã—à–∏
            barnRoof.rotation.y = Math.PI / 4; // –í—ã—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–æ —Å—Ç–æ—Ä–æ–Ω–∞–º
            barnRoof.scale.set(1.1, 1, 1.1); // –ù–µ–º–Ω–æ–≥–æ —à–∏—Ä–µ, —á–µ–º —Ç–µ–ª–æ —Å–∞—Ä–∞–π—á–∏–∫–∞
            barnRoof.castShadow = true;
            barn.add(barnRoof);

            // –î–≤–µ—Ä—å —Å–∞—Ä–∞–π—á–∏–∫–∞ (–ø—Ä–æ—Å—Ç–∞—è)
            const barnDoorGeometry = new THREE.BoxGeometry(1.0, 2.0, 0.1);
            const barnDoorMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.6 });
            const barnDoor = new THREE.Mesh(barnDoorGeometry, barnDoorMaterial);
            barnDoor.position.set(0, 1.0, 2.05); // –ü–µ—Ä–µ–¥–Ω—è—è —Å—Ç–æ—Ä–æ–Ω–∞ —Å–∞—Ä–∞–π—á–∏–∫–∞
            barnDoor.castShadow = true;
            barn.add(barnDoor);

            // –†–∞–∑–º–µ—â–∞–µ–º —Å–∞—Ä–∞–π—á–∏–∫ –≤ –ª–µ—Å—É
            barn.position.set(-40, 0, 40); // –ü—Ä–∏–º–µ—Ä–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ª–µ—Å—É
            scene.add(barn);

            return barn; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–∞—Ä–∞–π—á–∏–∫
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–æ–ª–µ–Ω–Ω–∏—Ü—É —Ä—è–¥–æ–º —Å —Å–∞—Ä–∞–π—á–∏–∫–æ–º (–ª–µ—Å–æ–ø–∏–ª–∫–æ–π).
         * @param {THREE.Group} barn - –û–±—ä–µ–∫—Ç —Å–∞—Ä–∞–π—á–∏–∫–∞, —Ä—è–¥–æ–º —Å –∫–æ—Ç–æ—Ä—ã–º –±—É–¥–µ—Ç —Ä–∞–∑–º–µ—â–µ–Ω–∞ –ø–æ–ª–µ–Ω–Ω–∏—Ü–∞.
         */
        function createFirewoodPile(barn) {
            logDropOffPileGroup = new THREE.Group(); // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –≥—Ä—É–ø–ø—É –¥–ª—è –ø–æ–ª–µ–Ω–Ω–∏—Ü—ã
            
            // –†–∞–∑–º–µ—â–∞–µ–º –ø–æ–ª–µ–Ω–Ω–∏—Ü—É —Ä—è–¥–æ–º —Å —Å–∞—Ä–∞–π—á–∏–∫–æ–º
            logDropOffPileGroup.position.set(barn.position.x + 3.5, 0, barn.position.z + 0.5); // –°–º–µ—â–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Å–∞—Ä–∞–π—á–∏–∫–∞
            logDropOffPileGroup.rotation.y = Math.PI / 6; // –ù–µ–º–Ω–æ–≥–æ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º
            scene.add(logDropOffPileGroup);
            console.log("Log drop-off pile (at sawmill) created at:", logDropOffPileGroup.position);

            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—å–Ω—ã—Ö –±—Ä–µ–≤–µ–Ω –∫ –ø–æ–ª–µ–Ω–Ω–∏—Ü–µ
            const initialLogsCount = 20; // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±—Ä–µ–≤–µ–Ω
            for (let i = 0; i < initialLogsCount; i++) {
                const log = createCollectibleLog(); // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –±—Ä–µ–≤–Ω–∞
                // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∏—Ö –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã logDropOffPileGroup
                const logsPerRow = 8;
                const logHeight = 0.3;
                const row = Math.floor(i / logsPerRow);
                const col = i % logsPerRow;
                const xOffset = (col * 0.3) - (logsPerRow * 0.3 / 2) + 0.15;
                const yOffset = (row * logHeight) + 0.15;
                const zOffset = (Math.random() - 0.5) * 0.1;
                log.position.set(xOffset, yOffset, zOffset);
                log.rotation.z = Math.PI / 2;
                log.rotation.y = (Math.random() - 0.5) * 0.2;
                logDropOffPileGroup.add(log);
            }
            console.log("Initial logs added to log pile. Total children in group:", logDropOffPileGroup.children.length);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –æ–¥–Ω–æ –±—Ä–µ–≤–Ω–æ, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–¥–æ–±—Ä–∞–Ω–æ –∏–≥—Ä–æ–∫–æ–º.
         * @returns {THREE.Mesh} –ú–µ—à –±—Ä–µ–≤–Ω–∞.
         */
        function createCollectibleLog() {
            const logGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.0, 8);
            const logMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });
            const log = new THREE.Mesh(logGeometry, logMaterial);
            log.rotation.z = Math.PI / 2; // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ
            log.castShadow = true;
            log.receiveShadow = true;
            log.userData.type = 'log'; // –ü–æ–º–µ—á–∞–µ–º —Ç–∏–ø —Ä–µ—Å—É—Ä—Å–∞
            return log;
        }

        /**
         * –î–æ–±–∞–≤–ª—è–µ—Ç –±—Ä–µ–≤–Ω–æ –∫ –ø–æ–ª–µ–Ω–Ω–∏—Ü–µ.
         * @param {THREE.Mesh} logMesh - –ú–µ—à –±—Ä–µ–≤–Ω–∞, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å.
         */
        function addLogToPile(logMesh) {
            if (!logDropOffPileGroup) return;

            // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –Ω–æ–≤–æ–≥–æ –±—Ä–µ–≤–Ω–∞ –≤ –ø–æ–ª–µ–Ω–Ω–∏—Ü–µ
            const currentLogs = collectedLogsCount; // –ò—Å–ø–æ–ª—å–∑—É–µ–º collectedLogsCount –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏
            const logsPerRow = 8; 
            const logHeight = 0.3; 

            const row = Math.floor(currentLogs / logsPerRow);
            const col = currentLogs % logsPerRow;

            // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º X-–ø–æ–∑–∏—Ü–∏—é, —á—Ç–æ–±—ã –±—Ä–µ–≤–Ω–∞ —Å–∫–ª–∞–¥—ã–≤–∞–ª–∏—Å—å –∞–∫–∫—É—Ä–∞—Ç–Ω–æ
            const xOffset = (col * 0.3) - (logsPerRow * 0.3 / 2) + 0.15; 
            const yOffset = (row * logHeight) + 0.15; 
            const zOffset = (Math.random() - 0.5) * 0.1; // –ù–µ–±–æ–ª—å—à–æ–µ —Å–ª—É—á–∞–π–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –ø–æ Z

            logMesh.position.set(xOffset, yOffset, zOffset);
            logMesh.rotation.z = Math.PI / 2; // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ
            logMesh.rotation.y = (Math.random() - 0.5) * 0.2; // –ù–µ–±–æ–ª—å—à–æ–π —Å–ª—É—á–∞–π–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç

            logDropOffPileGroup.add(logMesh);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω—é (–Ω–æ–≤—ã–π –¥–æ–º–∏–∫).
         */
        function createQuarry() {
            quarryHouse = new THREE.Group();
            const quarryStoneMaterial = new THREE.MeshStandardMaterial({ color: 0x708090, roughness: 0.8 }); // –°–µ—Ä—ã–π –∫–∞–º–µ–Ω—å
            const quarryRoofMaterial = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.7 }); // –¢–µ–º–Ω–æ-—Å–µ—Ä—ã–π

            // –¢–µ–ª–æ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
            const quarryBodyGeometry = new THREE.BoxGeometry(6, 4, 5);
            const quarryBody = new THREE.Mesh(quarryBodyGeometry, quarryStoneMaterial);
            quarryBody.position.y = 2;
            quarryBody.castShadow = true;
            quarryBody.receiveShadow = true;
            quarryHouse.add(quarryBody);

            // –ö—Ä—ã—à–∞ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏ (–ø–ª–æ—Å–∫–∞—è, –Ω–æ —Å –Ω–µ–±–æ–ª—å—à–∏–º —É–∫–ª–æ–Ω–æ–º)
            const quarryRoofGeometry = new THREE.BoxGeometry(6.2, 0.5, 5.2);
            const quarryRoof = new THREE.Mesh(quarryRoofGeometry, quarryRoofMaterial);
            quarryRoof.position.y = 4 + 0.25;
            quarryRoof.rotation.x = -Math.PI / 60; // –ù–µ–±–æ–ª—å—à–æ–π –Ω–∞–∫–ª–æ–Ω
            quarryRoof.castShadow = true;
            quarryHouse.add(quarryRoof);

            // –í—Ö–æ–¥ –≤ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω—é
            const quarryDoorGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.1);
            const quarryDoorMaterial = new THREE.MeshStandardMaterial({ color: 0x303030, roughness: 0.6 });
            const quarryDoor = new THREE.Mesh(quarryDoorGeometry, quarryDoorMaterial);
            quarryDoor.position.set(0, 1.25, 2.55);
            quarryDoor.castShadow = true;
            quarryHouse.add(quarryDoor);

            // –†–∞–∑–º–µ—â–∞–µ–º –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω—é
            quarryHouse.position.set(40, 0, -40); // –í –¥—Ä—É–≥–æ–π —Å—Ç–æ—Ä–æ–Ω–µ –æ—Ç –¥–æ–º–∏–∫–æ–≤
            scene.add(quarryHouse);

            return quarryHouse;
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –æ–¥–∏–Ω –∫–∞–º–µ–Ω—å, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–¥–æ–±—Ä–∞–Ω –∏–≥—Ä–æ–∫–æ–º.
         * @returns {THREE.Mesh} –ú–µ—à –∫–∞–º–Ω—è.
         */
        function createCollectibleStone() {
            const stoneGeometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.2, 8, 8);
            const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9, metalness: 0.0 });
            const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
            stone.castShadow = true;
            stone.receiveShadow = true;
            stone.userData.type = 'stone'; // –ü–æ–º–µ—á–∞–µ–º —Ç–∏–ø —Ä–µ—Å—É—Ä—Å–∞
            return stone;
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –∫—É—á—É –∫–∞–º–Ω–µ–π —Ä—è–¥–æ–º —Å –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–µ–π.
         * @param {THREE.Group} quarry - –û–±—ä–µ–∫—Ç –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏.
         */
        function createStoneDropOffPile(quarry) {
            stoneDropOffPileGroup = new THREE.Group();
            stoneDropOffPileGroup.position.set(quarry.position.x - 3.5, 0, quarry.position.z - 0.5); // –ú–µ—Å—Ç–æ –¥–ª—è —Å–∫–ª–∞–¥—ã–≤–∞–Ω–∏—è –∫–∞–º–Ω–µ–π
            stoneDropOffPileGroup.rotation.y = -Math.PI / 4; // –ù–µ–º–Ω–æ–≥–æ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º
            scene.add(stoneDropOffPileGroup);

            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—å–Ω—ã—Ö –∫–∞–º–Ω–µ–π –∫ –∫—É—á–µ
            const initialStonesCount = 10; // –ù–∞–ø—Ä–∏–º–µ—Ä, 10 –∫–∞–º–Ω–µ–π –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ
            for (let i = 0; i < initialStonesCount; i++) {
                const stone = createCollectibleStone(); // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞–º–Ω—è
                // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∏—Ö –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã stoneDropOffPileGroup
                const stonesPerRow = 6;
                const stoneHeight = 0.6;
                const row = Math.floor(i / stonesPerRow);
                const col = i % stonesPerRow;
                const xOffset = (col * 0.5) - (stonesPerRow * 0.5 / 2) + 0.25;
                const yOffset = (row * stoneHeight) + 0.15;
                const zOffset = (Math.random() - 0.5) * 0.1;
                stone.position.set(xOffset, yOffset, zOffset);
                stone.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                stoneDropOffPileGroup.add(stone);
            }
        }

        /**
         * –î–æ–±–∞–≤–ª—è–µ—Ç –∫–∞–º–µ–Ω—å –∫ –∫—É—á–µ –∫–∞–º–Ω–µ–π.
         * @param {THREE.Mesh} stoneMesh - –ú–µ—à –∫–∞–º–Ω—è, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å.
         */
        function addStoneToPile(stoneMesh) {
            if (!stoneDropOffPileGroup) return;

            const currentStones = collectedStonesCount;
            const stonesPerRow = 6; // –ö–∞–º–Ω–∏ –º–µ–Ω—å—à–µ, –º–æ–∂–Ω–æ –±–æ–ª—å—à–µ –≤ —Ä—è–¥
            const stoneHeight = 0.6; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –∫–∞–º–Ω—è
            const stoneWidth = 0.6; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –∫–∞–º–Ω—è

            const row = Math.floor(currentStones / stonesPerRow);
            const col = currentStones % stonesPerRow;

            const xOffset = (col * 0.5) - (stonesPerRow * 0.5 / 2) + 0.25;
            const yOffset = (row * stoneHeight) + 0.15;
            const zOffset = (Math.random() - 0.5) * 0.1;

            stoneMesh.position.set(xOffset, yOffset, zOffset);
            stoneMesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI); // –°–ª—É—á–∞–π–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
            
            stoneDropOffPileGroup.add(stoneMesh);
        }


        /**
         * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –æ—Å–≤–µ—â–µ–Ω–∏–µ —Å—Ü–µ–Ω—ã (–æ–∫—Ä—É–∂–∞—é—â–µ–µ, –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–µ, –ø–æ–ª—É—Å—Ñ–µ—Ä–Ω–æ–µ).
         */
        function setupLighting() {
            // –£–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
            scene.children.forEach(obj => {
                if (obj instanceof THREE.Light) {
                    scene.remove(obj);
                }
            });

            const ambientLight = new THREE.AmbientLight(0x404040, daySettings.ambientIntensity);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(daySettings.directionalColor, daySettings.directionalIntensity);
            // –ü–æ–∑–∏—Ü–∏—è DirectionalLight —Ç–µ–ø–µ—Ä—å –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞, –æ–Ω–∞ –Ω–µ –±—É–¥–µ—Ç –º–µ–Ω—è—Ç—å—Å—è –º–µ–∂–¥—É –¥–Ω–µ–º –∏ –Ω–æ—á—å—é.
            directionalLight.position.copy(daySettings.directionalPosition); 
            directionalLight.castShadow = true;

            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200; // –£–≤–µ–ª–∏—á–µ–Ω–∞ –¥–∞–ª—å–Ω—è—è –ø–ª–æ—Å–∫–æ—Å—Ç—å –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –º–∏—Ä–∞
            directionalLight.shadow.camera.left = -90; // –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –º–∏—Ä–∞
            directionalLight.shadow.camera.right = 90; // –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –º–∏—Ä–∞
            directionalLight.shadow.camera.top = 90; // –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –º–∏—Ä–∞
            directionalLight.shadow.camera.bottom = -90; // –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –º–∏—Ä–∞
            scene.add(directionalLight);

            const hemisphereLight = new THREE.HemisphereLight(daySettings.hemisphereSkyColor, daySettings.hemisphereGroundColor, daySettings.hemisphereIntensity);
            scene.add(hemisphereLight);
        }

        /**
         * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π.
         */
        function setupControls() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            window.addEventListener('resize', onWindowResize);

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            document.getElementById('toggleDayNightButton').addEventListener('click', toggleDayNight);
        }

        // --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π ---

        function onKeyDown(event) {
            keys[event.code] = true;
            if (event.code === 'KeyE') { // –ö–ª–∞–≤–∏—à–∞ E –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
                console.log("–ö–ª–∞–≤–∏—à–∞ 'E' –Ω–∞–∂–∞—Ç–∞.");
                handleInteraction();
            }
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                
                // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –º–∏—Ä–æ–≤–∞—è Y-–ø–æ–∑–∏—Ü–∏—è, –∫–æ—Ç–æ—Ä—É—é –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å –∫–∞–º–µ—Ä–∞.
                // –≠—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –æ–ø—É—Å–∫–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã –ø–æ–¥ –∑–µ–º–ª—é.
                // –ó–Ω–∞—á–µ–Ω–∏–µ 1.5 –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç, —á—Ç–æ –∫–∞–º–µ—Ä–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–µ–º–Ω–æ–≥–æ –≤—ã—à–µ —É—Ä–æ–≤–Ω—è –∑–µ–º–ª–∏.
                const minCameraY = 1.5; 

                // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º—É—é –º–∏—Ä–æ–≤—É—é Y-–ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã.
                // camera.position.y = playerPosition.y + (Math.sin(cameraAngleX) * cameraDistance + 3)
                const currentCameraYOffset = Math.sin(cameraAngleX) * cameraDistance + 3;
                const projectedCameraWorldY = playerPosition.y + currentCameraYOffset;

                // –ï—Å–ª–∏ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º–∞—è Y-–ø–æ–∑–∏—Ü–∏—è –Ω–∏–∂–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–π, –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º cameraAngleX.
                if (projectedCameraWorldY < minCameraY) {
                    // –í—ã—á–∏—Å–ª—è–µ–º —Ç—Ä–µ–±—É–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ sin(cameraAngleX) –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è minCameraY.
                    const requiredSinAngle = (minCameraY - 3 - playerPosition.y) / cameraDistance;
                    
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º Math.asin –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É–≥–ª–∞, –Ω–æ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç -1 –¥–æ 1,
                    // —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å NaN (–Ω–µ —á–∏—Å–ª–æ) –æ—à–∏–±–æ–∫.
                    cameraAngleX = Math.asin(Math.max(-1, Math.min(1, requiredSinAngle)));
                }
                
                // –¢–∞–∫–∂–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫–æ –≤–≤–µ—Ä—Ö, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∏–Ω–≤–µ—Ä—Å–∏–∏ –∫–∞–º–µ—Ä—ã.
                cameraAngleX = Math.min(Math.PI / 2 - 0.01, cameraAngleX); 

                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onWheel(event) {
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(3, Math.min(200, cameraDistance)); // –£–≤–µ–ª–∏—á–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∫–∞–º–µ—Ä—ã –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –º–∏—Ä–∞
        }

        /**
         * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –∏–≥—Ä–æ–∫–∞ (–ø–æ–¥–±–æ—Ä/–≤—ã–≥—Ä—É–∑–∫–∞ —Ä–µ—Å—É—Ä—Å–∞).
         */
        function handleInteraction() {
            if (playerHasResource) {
                // –ò–≥—Ä–æ–∫ –¥–µ—Ä–∂–∏—Ç —Ä–µ—Å—É—Ä—Å, –ø—ã—Ç–∞–µ—Ç—Å—è –≤—ã–≥—Ä—É–∑–∏—Ç—å –µ–≥–æ
                let deposited = false;
                if (currentResourceType === 'log') {
                    // –ü–æ–ø—ã—Ç–∫–∞ –≤—ã–≥—Ä—É–∑–∏—Ç—å –±—Ä–µ–≤–Ω–æ —É –ø–æ–ª–µ–Ω–Ω–∏—Ü—ã —Å–∞—Ä–∞–π—á–∏–∫–∞ (–ª–µ—Å–æ–ø–∏–ª–∫–∏)
                    const distanceToLogPile = playerPosition.distanceTo(logDropOffPileGroup.position);
                    console.log('–ò–≥—Ä–æ–∫ –¥–µ—Ä–∂–∏—Ç –±—Ä–µ–≤–Ω–æ. –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –ø–æ–ª–µ–Ω–Ω–∏—Ü—ã (–¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏): ' + distanceToLogPile.toFixed(2));
                    if (distanceToLogPile < interactDistance + 2) { 
                        player.userData.hand.remove(currentHeldResource);
                        addLogToPile(currentHeldResource); 
                        collectedLogsCount++;
                        document.getElementById('collectedLogsCount').textContent = collectedLogsCount;
                        console.log('–ë—Ä–µ–≤–Ω–æ –≤—ã–≥—Ä—É–∂–µ–Ω–æ! –í—Å–µ–≥–æ —Å–æ–±—Ä–∞–Ω–æ: ' + collectedLogsCount);
                        deposited = true;
                    } else {
                        console.log('–í—ã —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –æ—Ç –ø–æ–ª–µ–Ω–Ω–∏—Ü—ã, —á—Ç–æ–±—ã –≤—ã–≥—Ä—É–∑–∏—Ç—å –±—Ä–µ–≤–Ω–æ. –ü–æ–¥–æ–π–¥–∏—Ç–µ –±–ª–∏–∂–µ.');
                    }
                } else if (currentResourceType === 'stone') {
                    // –ü–æ–ø—ã—Ç–∫–∞ –≤—ã–≥—Ä—É–∑–∏—Ç—å –∫–∞–º–µ–Ω—å —É –∫—É—á–∏ –∫–∞–º–Ω–µ–π –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
                    const distanceToStonePile = playerPosition.distanceTo(stoneDropOffPileGroup.position);
                    console.log('–ò–≥—Ä–æ–∫ –¥–µ—Ä–∂–∏—Ç –∫–∞–º–µ–Ω—å. –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –∫—É—á–∏ –∫–∞–º–Ω–µ–π (–¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏): ' + distanceToStonePile.toFixed(2));
                    if (distanceToStonePile < interactDistance + 2) { 
                        player.userData.hand.remove(currentHeldResource);
                        addStoneToPile(currentHeldResource);
                        collectedStonesCount++;
                        document.getElementById('collectedStonesCount').textContent = collectedStonesCount;
                        console.log('–ö–∞–º–µ–Ω—å –≤—ã–≥—Ä—É–∂–µ–Ω! –í—Å–µ–≥–æ —Å–æ–±—Ä–∞–Ω–æ: ' + collectedStonesCount);
                        deposited = true;
                    } else {
                        console.log('–í—ã —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –æ—Ç –∫—É—á–∏ –∫–∞–º–Ω–µ–π, —á—Ç–æ–±—ã –≤—ã–≥—Ä—É–∑–∏—Ç—å –∫–∞–º–µ–Ω—å. –ü–æ–¥–æ–π–¥–∏—Ç–µ –±–ª–∏–∂–µ.');
                    }
                }

                if (deposited) {
                    currentHeldResource = null;
                    playerHasResource = false;
                    currentResourceType = null;
                }
            } else {
                // –ò–≥—Ä–æ–∫ –Ω–µ –¥–µ—Ä–∂–∏—Ç —Ä–µ—Å—É—Ä—Å, –ø—ã—Ç–∞–µ—Ç—Å—è –ø–æ–¥–æ–±—Ä–∞—Ç—å –µ–≥–æ
                let pickedUp = false;
                
                // –ü–æ–∏—Å–∫ –¥–µ—Ä–µ–≤–∞ –¥–ª—è –±—Ä–µ–≤–Ω–∞
                for (let i = 0; i < collectibleTrees.length; i++) {
                    const tree = collectibleTrees[i];
                    if (tree.userData.isCollectible && tree.userData.logsRemaining > 0) {
                        const distanceToTree = playerPosition.distanceTo(tree.position);
                        console.log('–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –¥–µ—Ä–µ–≤–∞ (–¥–ª—è –ø–æ–¥–±–æ—Ä–∞): ' + distanceToTree.toFixed(2) + '. –ë—Ä–µ–≤–Ω–∞ –æ—Å—Ç–∞–ª–∏—Å—å: ' + tree.userData.logsRemaining);
                        if (distanceToTree < interactDistance) {
                            currentHeldResource = createCollectibleLog();
                            player.userData.hand.add(currentHeldResource);
                            playerHasResource = true;
                            currentResourceType = 'log';
                            tree.userData.logsRemaining--;
                            
                            if (tree.userData.logsRemaining === 0) {
                                console.log('–î–µ—Ä–µ–≤–æ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ –ø–µ–Ω–µ–∫!');
                                tree.userData.originalFoliage.forEach(foliagePart => {
                                    tree.remove(foliagePart);
                                });
                                const stump = createStump();
                                tree.add(stump);
                                tree.userData.isCollectible = false; // –ë–æ–ª—å—à–µ –Ω–µ —Å–æ–±–∏—Ä–∞–µ–º–æ–µ
                            }
                            pickedUp = true;
                            break; 
                        }
                    } else if (tree.userData.isCollectible && tree.userData.logsRemaining === 0) {
                        const distanceToTree = playerPosition.distanceTo(tree.position);
                        if (distanceToTree < interactDistance) {
                            console.log('–≠—Ç–æ –¥–µ—Ä–µ–≤–æ —É–∂–µ –ø—Ä–µ–≤—Ä–∞—Ç–∏–ª–æ—Å—å –≤ –ø–µ–Ω–µ–∫. –ë–æ–ª—å—à–µ –±—Ä–µ–≤–µ–Ω –Ω–µ—Ç.');
                        }
                    }
                }

                // –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–æ–±—Ä–∞–ª –±—Ä–µ–≤–Ω–æ, –∏—â–µ–º –∫–∞–º–µ–Ω—å
                if (!pickedUp) {
                    for (let i = 0; i < collectibleStones.length; i++) {
                        const stone = collectibleStones[i];
                        if (stone.userData.isCollectible && stone.userData.logsRemaining > 0) { // –ò—Å–ø–æ–ª—å–∑—É–µ–º logsRemaining –∫–∞–∫ —Å—á–µ—Ç—á–∏–∫ "—É–¥–∞—Ä–æ–≤" –¥–ª—è –∫–∞–º–Ω—è
                            const distanceToStone = playerPosition.distanceTo(stone.position);
                            console.log('–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –∫–∞–º–Ω—è (–¥–ª—è –ø–æ–¥–±–æ—Ä–∞): ' + distanceToStone.toFixed(2) + '. –ö–∞–º–Ω–∏ –æ—Å—Ç–∞–ª–∏—Å—å: ' + stone.userData.logsRemaining);
                            if (distanceToStone < interactDistance) {
                                currentHeldResource = createCollectibleStone();
                                player.userData.hand.add(currentHeldResource);
                                playerHasResource = true;
                                currentResourceType = 'stone';
                                stone.userData.logsRemaining--;

                                if (stone.userData.logsRemaining === 0) {
                                    console.log('–ö–∞–º–µ–Ω—å –∏—Å—á–µ–∑!');
                                    scene.remove(stone); // –ö–∞–º–µ–Ω—å –ø—Ä–æ–ø–∞–¥–∞–µ—Ç
                                    stone.userData.isCollectible = false; // –ë–æ–ª—å—à–µ –Ω–µ —Å–æ–±–∏—Ä–∞–µ–º—ã–π
                                }
                                pickedUp = true;
                                break;
                            }
                        } else if (stone.userData.isCollectible && stone.userData.logsRemaining === 0) {
                             const distanceToStone = playerPosition.distanceTo(stone.position);
                             if (distanceToStone < interactDistance) {
                                console.log('–≠—Ç–æ—Ç –∫–∞–º–µ–Ω—å —É–∂–µ –∏—Å—á–µ—Ä–ø–∞–Ω –∏ –∏—Å—á–µ–∑.');
                            }
                        }
                    }
                }

                if (!pickedUp) {
                    console.log('–ù–µ—Ç —Ä–µ—Å—É—Ä—Å–æ–≤ –¥–ª—è –ø–æ–¥–±–æ—Ä–∞ –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏ –∏–ª–∏ –≤—ã —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ. –ü–æ–¥–æ–π–¥–∏—Ç–µ –∫ –¥–µ—Ä–µ–≤—É –∏–ª–∏ –∫–∞–º–Ω—é.');
                }
            }
        }

        /**
         * –ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –º–µ–∂–¥—É –¥–Ω–µ–≤–Ω—ã–º–∏ –∏ –Ω–æ—á–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ —Å –ø–ª–∞–≤–Ω—ã–º –ø–µ—Ä–µ—Ö–æ–¥–æ–º.
         */
        function toggleDayNight() {
            isDayTime = !isDayTime;
            targetTransitionProgress = isDayTime ? 1 : 0; 

            const button = document.getElementById('toggleDayNightButton');
            if (button) {
                button.textContent = isDayTime ? '‚òÄÔ∏è' : 'üåô';
            }
        }

        /**
         * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞ –∏ –∫–∞–º–µ—Ä—ã.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –∞–Ω–∏–º–∞—Ü–∏–∏.
         */
        function animate() {
            requestAnimationFrame(animate);

            // –õ–æ–≥–∏–∫–∞ –ø–ª–∞–≤–Ω–æ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥–∞ –¥–Ω—è/–Ω–æ—á–∏
            if (transitionProgress !== targetTransitionProgress) {
                const delta = targetTransitionProgress - transitionProgress;
                transitionProgress += Math.sign(delta) * transitionSpeed;

                transitionProgress = Math.max(0, Math.min(1, transitionProgress));

                const fogColorDay = new THREE.Color(daySettings.fogColor);
                const fogColorNight = new THREE.Color(nightSettings.fogColor);
                scene.fog.color.copy(fogColorNight).lerp(fogColorDay, transitionProgress);

                const clearColorDay = new THREE.Color(daySettings.clearColor);
                const clearColorNight = new THREE.Color(nightSettings.clearColor);
                const currentClearColor = new THREE.Color().copy(clearColorNight).lerp(clearColorDay, transitionProgress);
                renderer.setClearColor(currentClearColor, 1);

                const ambientLight = scene.children.find(obj => obj instanceof THREE.AmbientLight);
                const directionalLight = scene.children.find(obj => obj instanceof THREE.DirectionalLight);
                const hemisphereLight = scene.children.find(obj => obj instanceof THREE.HemisphereLight);

                if (ambientLight) {
                    ambientLight.intensity = nightSettings.ambientIntensity + (daySettings.ambientIntensity - nightSettings.ambientIntensity) * transitionProgress;
                }
                if (directionalLight) {
                    const dirColorDay = new THREE.Color(daySettings.directionalColor);
                    const dirColorNight = new THREE.Color(nightSettings.directionalColor);
                    directionalLight.color.copy(dirColorNight).lerp(dirColorDay, transitionProgress);
                    // –ü–æ–∑–∏—Ü–∏—è DirectionalLight —Ç–µ–ø–µ—Ä—å –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞, –æ–Ω–∞ –Ω–µ –±—É–¥–µ—Ç –º–µ–Ω—è—Ç—å—Å—è –º–µ–∂–¥—É –¥–Ω–µ–º –∏ –Ω–æ—á—å—é.
                    // directionalLight.position.lerpVectors(nightSettings.directionalPosition, daySettings.directionalPosition, transitionProgress);
                }
                if (hemisphereLight) {
                    const hemiSkyColorDay = new THREE.Color(daySettings.hemisphereSkyColor);
                    const hemiSkyColorNight = new THREE.Color(nightSettings.hemisphereSkyColor);
                    hemisphereLight.color.copy(hemiSkyColorNight).lerp(hemiSkyColorDay, transitionProgress);

                    const hemiGroundColorDay = new THREE.Color(daySettings.hemisphereGroundColor);
                    const hemiGroundColorNight = new THREE.Color(nightSettings.hemisphereGroundColor);
                    hemisphereLight.groundColor.copy(hemiGroundColorNight).lerp(hemiGroundColorDay, transitionProgress);
                    hemisphereLight.intensity = nightSettings.hemisphereIntensity + (daySettings.hemisphereIntensity - nightSettings.hemisphereIntensity) * transitionProgress;
                }

                windowLights.forEach(light => {
                    light.intensity = nightSettings.windowLightIntensity + (daySettings.windowLightIntensity - nightSettings.windowLightIntensity) * transitionProgress;
                });

                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ —Å–≤–µ—Ç–ª—è—á–∫–æ–≤ –≤–æ –≤—Ä–µ–º—è –ø–µ—Ä–µ—Ö–æ–¥–∞
                fireflies.forEach(firefly => {
                    firefly.material.opacity = (1 - transitionProgress) * 0.8; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –Ω–æ—á—å—é
                });
            }

            updatePlayer();

            const cameraOffset = new THREE.Vector3(
                Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance,
                Math.sin(cameraAngleX) * cameraDistance + 3,
                Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance
            );

            camera.position.copy(playerPosition).add(cameraOffset);
            camera.lookAt(playerPosition.x, playerPosition.y + 1, playerPosition.z);

            // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü –¥—ã–º–∞
            particles.forEach((particle, idx) => { 
                particle.position.add(particle.userData.velocity);
                particle.userData.life += 0.01;

                if (particle.userData.life > 1 || particle.position.y > 15) {
                    particle.position.set(-1.2, 5.2 + idx * 0.3, -1.2); 
                    particle.userData.life = 0;
                    particle.userData.velocity.set(
                        (Math.random() - 0.5) * 0.02,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.02
                    );
                }

                particle.material.opacity = 0.6 * (1 - particle.userData.life);
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è —Ä—ã–±—ã
            const lakeCenter = new THREE.Vector3(60, 0.01, 0); // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–æ
            const fishBoundaryRadius = 36; // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–æ
            fish.forEach(f => {
                f.position.add(f.userData.velocity);
                
                const distanceToCenter = f.position.distanceTo(lakeCenter);
                if (distanceToCenter > fishBoundaryRadius) { 
                    const directionToCenter = new THREE.Vector3().subVectors(lakeCenter, f.position).normalize();
                    f.userData.velocity.copy(directionToCenter).multiplyScalar(0.025 + Math.random() * 0.01); 
                    
                    f.userData.velocity.x += (Math.random() - 0.5) * 0.005; 
                    f.userData.velocity.z += (Math.random() - 0.5) * 0.005; 
                    f.userData.velocity.normalize().multiplyScalar(0.025); 
                }

                f.position.y += Math.sin(f.userData.swimCycle) * 0.005; 
                f.userData.swimCycle += 0.05;

                f.rotation.y = Math.atan2(f.userData.velocity.x, f.userData.velocity.z);
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –∫—Ä–æ–ª–∏–∫–æ–≤ (–ø–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –≤–ø–µ—Ä–µ–¥/–Ω–∞–∑–∞–¥ –∏ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ)
            rabbits.forEach(rabbit => {
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é Z-–ø–æ–∑–∏—Ü–∏—é –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∏–Ω—É—Å–æ–∏–¥—ã –¥–ª—è –ø–ª–∞–≤–Ω–æ–π –æ—Å—Ü–∏–ª–ª—è—Ü–∏–∏
                const newZ = rabbit.userData.initialPosition.z + Math.sin(Date.now() * rabbit.userData.oscillationSpeed + rabbit.userData.oscillationOffset) * rabbit.userData.oscillationAmplitude;
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è
                const prevZ = rabbit.position.z;
                rabbit.position.z = newZ;

                // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∫—Ä–æ–ª–∏–∫–∞ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è
                // –ï—Å–ª–∏ –¥–≤–∏–∂–µ—Ç—Å—è –≤–ø–µ—Ä–µ–¥ (newZ > prevZ), –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É, –∏–Ω–∞—á–µ –≤ –¥—Ä—É–≥—É—é
                if (newZ > prevZ) { 
                    rabbit.rotation.y = rabbit.userData.initialRotationY; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –≤–ø–µ—Ä–µ–¥
                } else { 
                    rabbit.rotation.y = rabbit.userData.initialRotationY + Math.PI; // –î–æ–±–∞–≤–ª—è–µ–º PI –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –Ω–∞–∑–∞–¥
                }

                // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∑–µ–º–ª–∏ (y=0)
                rabbit.position.y = Math.sin(Date.now() * 0.005 + rabbit.userData.offset) * 0.05; 
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –æ–±–ª–∞–∫–æ–≤
            clouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speed;
                // –ó–∞–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –æ–±–ª–∞–∫–∞ –≤–æ–∫—Ä—É–≥ –º–∏—Ä–∞
                if (cloud.position.x > 100) cloud.position.x = -100;
                if (cloud.position.x < -100) cloud.position.x = 100;
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –ø—Ç–∏—Ü—ã
            if (bird) {
                bird.userData.flightAngle += bird.userData.flightSpeed;
                bird.position.x = bird.userData.flightRadius * Math.cos(bird.userData.flightAngle);
                bird.position.z = bird.userData.flightRadius * Math.sin(bird.userData.flightAngle);
                bird.rotation.y = -bird.userData.flightAngle + Math.PI / 2; // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ø—Ç–∏—Ü—É –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é –ø–æ–ª–µ—Ç–∞

                // –ê–Ω–∏–º–∞—Ü–∏—è –º–∞—Ö–∞ –∫—Ä—ã–ª—å—è–º–∏
                const wingAngle = Math.sin(Date.now() * bird.userData.wingFlapSpeed) * bird.userData.wingFlapAmplitude;
                if (bird.userData.leftWing) bird.userData.leftWing.rotation.x = Math.PI / 4 + wingAngle;
                if (bird.userData.rightWing) bird.userData.rightWing.rotation.x = -Math.PI / 4 - wingAngle; 
            }

            // –ê–Ω–∏–º–∞—Ü–∏—è —Å–≤–µ—Ç–ª—è—á–∫–æ–≤
            fireflies.forEach(firefly => {
                // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
                firefly.position.x = firefly.userData.initialPosition.x + Math.sin(Date.now() * firefly.userData.speed + firefly.userData.offset) * 0.5;
                firefly.position.y = firefly.userData.initialPosition.y + Math.cos(Date.now() * firefly.userData.speed * 0.8 + firefly.userData.offset) * 0.3;
                firefly.position.z = firefly.userData.initialPosition.z + Math.sin(Date.now() * firefly.userData.speed * 1.2 + firefly.userData.offset) * 0.5;

                // –ú–µ—Ä—Ü–∞–Ω–∏–µ (—Ç–æ–ª—å–∫–æ –Ω–æ—á—å—é)
                if (!isDayTime) {
                    firefly.material.opacity = 0.5 + Math.sin(Date.now() * 0.01 + firefly.userData.offset) * 0.5;
                } else {
                    firefly.material.opacity = 0; // –°–≤–µ—Ç–ª—è—á–∫–∏ –Ω–µ–≤–∏–¥–∏–º—ã –¥–Ω–µ–º
                }
            });


            house.rotation.y = Math.sin(Date.now() * 0.0005) * 0.02;

            renderer.render(scene, camera);
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç –ø–æ–∑–∏—Ü–∏—é –∏ –≤—Ä–∞—â–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–≤–æ–¥–∞ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã.
         */
        function updatePlayer() {
            let isMoving = false;
            const speed = keys['ShiftLeft'] || keys['ShiftRight'] ? 0.15 : 0.08;
            const moveDirection = new THREE.Vector3(); 
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection); 

            // –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
            cameraDirection.y = 0;
            cameraDirection.normalize();

            const cameraRight = new THREE.Vector3();
            // –í–µ–∫—Ç–æ—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞ "–≤–≤–µ—Ä—Ö" –∫–∞–º–µ—Ä—ã –∏ –≤–µ–∫—Ç–æ—Ä–∞ "–≤–ø–µ—Ä–µ–¥" –¥–∞–µ—Ç –≤–µ–∫—Ç–æ—Ä "–≤–ø—Ä–∞–≤–æ"
            cameraRight.crossVectors(camera.up, cameraDirection); 
            cameraRight.normalize();

            // –í—ã—á–∏—Å–ª—è–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–∂–∞—Ç—ã—Ö –∫–ª–∞–≤–∏—à –∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ –∫–∞–º–µ—Ä—ã
            if (keys['KeyW'] || keys['ArrowUp']) {
                moveDirection.add(cameraDirection);
                isMoving = true;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                moveDirection.sub(cameraDirection);
                isMoving = true;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                moveDirection.add(cameraRight); // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞–º–µ—Ä—ã
                isMoving = true;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                moveDirection.sub(cameraRight); // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ª–µ–≤–æ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞–º–µ—Ä—ã
                isMoving = true;
            }

            if (isMoving) {
                moveDirection.normalize().multiplyScalar(speed);
                playerPosition.add(moveDirection);

                // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞, —á—Ç–æ–±—ã –æ–Ω —Å–º–æ—Ç—Ä–µ–ª –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è
                if (Math.abs(moveDirection.x) > 0.0001 || Math.abs(moveDirection.z) > 0.0001) {
                    player.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);
                }

                walkAnimation += 0.2;
                if (player.userData.leftLeg && player.userData.rightLeg) {
                    player.userData.leftLeg.rotation.x = Math.sin(walkAnimation) * 0.3;
                    player.userData.rightLeg.rotation.x = -Math.sin(walkAnimation) * 0.3;
                }
            } else {
                if (player.userData.leftLeg && player.userData.rightLeg) {
                    player.userData.leftLeg.rotation.x = 0;
                    player.userData.rightLeg.rotation.x = 0;
                }
            }

            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∏–≥—Ä–æ–∫–∞ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –≥—Ä–∞–Ω–∏—Ü —Å—Ü–µ–Ω—ã
            playerPosition.x = Math.max(-90, Math.min(90, playerPosition.x)); // –£–¥–≤–æ–µ–Ω–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã
            playerPosition.z = Math.max(-90, Math.min(90, playerPosition.z)); // –£–¥–≤–æ–µ–Ω–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã

            player.position.copy(playerPosition);
        }

        // --- –§—É–Ω–∫—Ü–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ---
        // –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑, –∫–æ–≥–¥–∞ –æ–∫–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≥—Ä—É–∑–∏—Ç—Å—è.
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(daySettings.fogColor, 20, 200); // –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç—É–º–∞–Ω: –±–ª–∏–∂–Ω–∏–π 20, –¥–∞–ª—å–Ω–∏–π 200

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(daySettings.clearColor, 1); 
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('container').appendChild(renderer.domElement);

            // –°–æ–∑–¥–∞–µ–º –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å—Ü–µ–Ω—ã
            createHouse();
            createPlayer();
            createGround();
            createTrees();  // –¢–µ–ø–µ—Ä—å —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–µ—Ç –≤—Å–µ –ª–∏—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏ –µ–ª–æ–≤—ã–µ –¥–µ—Ä–µ–≤—å—è –∫–∞–∫ —Å–æ–±–∏—Ä–∞–µ–º—ã–µ
            createRocks();  // –¢–µ–ø–µ—Ä—å —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–µ—Ç –≤—Å–µ –∫–∞–º–Ω–∏ –∫–∞–∫ —Å–æ–±–∏—Ä–∞–µ–º—ã–µ
            createLake();   
            createSmokeParticles();
            createLakeVegetation(); 
            createPierAndBoat(); 
            createFence(); 
            createRabbits(); 
            createClouds(); // –î–æ–±–∞–≤–ª—è–µ–º –æ–±–ª–∞–∫–∞
            createMailbox(); // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—á—Ç–æ–≤—ã–π —è—â–∏–∫
            createPath(); // –î–æ–±–∞–≤–ª—è–µ–º –¥–æ—Ä–æ–∂–∫—É
            createBench(); // –î–æ–±–∞–≤–ª—è–µ–º —Å–∫–∞–º–µ–π–∫—É
            createLilyPads(); // –î–æ–±–∞–≤–ª—è–µ–º –∫—É–≤—à–∏–Ω–∫–∏
            createBird(); // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ç–∏—Ü—É
            createFireflies(); // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—Ç–ª—è—á–∫–æ–≤

            // –°–æ–∑–¥–∞–µ–º —Å–∞—Ä–∞–π—á–∏–∫ (–ª–µ—Å–æ–ø–∏–ª–∫—É)
            const barn = createBarn();
            // –°–æ–∑–¥–∞–µ–º –ø–æ–ª–µ–Ω–Ω–∏—Ü—É —É —Å–∞—Ä–∞–π—á–∏–∫–∞
            createFirewoodPile(barn);

            // –°–æ–∑–¥–∞–µ–º –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω—é –∏ –∫—É—á—É –∫–∞–º–Ω–µ–π
            const quarry = createQuarry();
            createStoneDropOffPile(quarry);
            
            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ—Å–≤–µ—â–µ–Ω–∏–µ –∏ —ç–ª–µ–º–µ–Ω—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            setupLighting(); 
            setupControls();

            // –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–Ω—è/–Ω–æ—á–∏
            targetTransitionProgress = isDayTime ? 1 : 0;
            const button = document.getElementById('toggleDayNightButton');
            if (button) {
                button.textContent = isDayTime ? '‚òÄÔ∏è' : 'üåô';
            }

            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ü–∏–∫–ª –∞–Ω–∏–º–∞—Ü–∏–∏
            animate();
        }

        // –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ init –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –æ–∫–Ω–∞ (–≤–∫–ª—é—á–∞—è –≤—Å–µ —Å–∫—Ä–∏–ø—Ç—ã)
        window.onload = function() {
            init();
        }; 
    </script>
</body>
</html>

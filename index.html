<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –î–æ–º–∏–∫ - –° –∫—Ä—É–≥–ª—ã–º –∑–∞–≥–æ–Ω–æ–º –∏ –∫–æ—Ä–æ–≤–æ–π</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        #controls h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }

        #controls p {
            margin: 5px 0;
            color: #666;
            font-size: 12px;
        }

        .key {
            display: inline-block;
            background: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 0 2px;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px; /* Reduced padding */
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-width: 250px;
            display: flex; /* Use flexbox for button alignment */
            flex-direction: column; /* Stack items vertically */
            align-items: flex-start; /* Align items to the start */
        }

        #info h3 { 
            margin: 0 0 0px 0; 
            color: #333;
            font-size: 16px;
        }

        #info p {
            margin: 5px 0;
            color: #666;
            font-size: 12px;
            line-height: 1.4;
        }

        #toggleDayNightButton {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            padding: 5px 10px; /* Reduced padding for the button */
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 24px; /* Increased font size for emoji */
            margin-top: 5px; /* Reduced top margin */
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: auto; /* Automatic width */
            height: auto; /* Automatic height */
            line-height: 1; /* Removed extra line height */
        }

        #toggleDayNightButton:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>üè† –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
            <p>üñ±Ô∏è –ú—ã—à—å: –ø–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</p>
            <p>üîÑ –ö–æ–ª–µ—Å–æ: –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ</p>
            <p>üö∂ <span class="key">WASD</span> –∏–ª–∏ <span class="key">‚Üë‚Üì‚Üê‚Üí</span>: –¥–≤–∏–∂–µ–Ω–∏–µ</p>
            <p>üèÉ <span class="key">Shift</span>: –±–µ–≥</p>
        </div>

        <div id="info">
            <button id="toggleDayNightButton">‚òÄÔ∏è</button> 
        </div>
    </div>

    <script>
        let scene, camera, renderer, house, particles = [], player;
        let isMouseDown = false, mouseX = 0, mouseY = 0;
        let cameraAngleX = 0.3, cameraAngleY = 0;
        let cameraDistance = 20; 
        let isDayTime = true;
        let keys = {};
        let playerPosition = new THREE.Vector3(0, 0.8, 6); 
        let playerRotation = 0;
        let walkAnimation = 0;
        let windowLights = []; 
        let fish = []; 

        let transitionProgress = 1; 
        let transitionSpeed = 0.02; 
        let targetTransitionProgress = 1; 

        const daySettings = {
            fogColor: 0xA0D0FF, 
            clearColor: 0xA0D0FF, 
            ambientIntensity: 0.4, 
            directionalColor: 0xffffff,
            directionalIntensity: 0.8, 
            directionalPosition: new THREE.Vector3(10, 15, 10),
            hemisphereSkyColor: 0xC0E0FF, 
            hemisphereGroundColor: 0xA9D9A9, 
            hemisphereIntensity: 0.6, 
            windowLightIntensity: 0.0 
        };

        const nightSettings = {
            fogColor: 0x101040, 
            clearColor: 0x101040, 
            ambientIntensity: 0.25, 
            directionalColor: 0x404080, 
            directionalIntensity: 0.3, 
            directionalPosition: new THREE.Vector3(-10, 15, -10),
            hemisphereSkyColor: 0x202050, 
            hemisphereGroundColor: 0x101010, 
            hemisphereIntensity: 0.2, 
            windowLightIntensity: 2.0 
        };

        const textureLoader = new THREE.TextureLoader();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(daySettings.fogColor, 10, 100); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(daySettings.clearColor, 1); 
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('container').appendChild(renderer.domElement);

            createHouse();
            createPlayer();
            createGround();
            createTrees(); ¬†
            createLake(); ¬†
            createSmokeParticles();
            createLakeVegetation(); 
            createPierAndBoat(); 
            createEnclosureAndCow(); // Add enclosure and cow
            setupLighting(); 
            setupControls();

            targetTransitionProgress = isDayTime ? 1 : 0;
            const button = document.getElementById('toggleDayNightButton');
            if (button) {
                button.textContent = isDayTime ? '‚òÄÔ∏è' : 'üåô';
            }

            animate();
        }

        function createHouse() {
            house = new THREE.Group();

            const brickTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg',
                function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
                    texture.repeat.set(2, 2); 
                    wallMaterial.map = texture; 
                    wallMaterial.needsUpdate = true; 
                },
                undefined,
                function (err) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ–∫—Å—Ç—É—Ä—ã –∫–∏—Ä–ø–∏—á–∞:', err);
                    wallMaterial.color.set(0x8B4513); 
                    wallMaterial.needsUpdate = true;
                }
            );

            // Revert house walls to original size
            const wallGeometry = new THREE.BoxGeometry(4, 3, 4); 
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 0.8, metalness: 0.1 });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 1.5;
            walls.castShadow = true;
            walls.receiveShadow = true;
            house.add(walls);

            // Revert roof to original size and shape
            const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.7, metalness: 0.0 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 4;
            roof.rotation.y = Math.PI / 4; // Revert rotation
            roof.castShadow = true;
            house.add(roof);

            const doorGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.1);
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.6, metalness: 0.0 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.9, 2.05); 
            door.castShadow = true;
            house.add(door);

            const handleGeometry = new THREE.SphereGeometry(0.05);
            const handleMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3, metalness: 0.8 });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(-0.3, 0.9, 2.1);
            handle.castShadow = true;
            house.add(handle);

            const windowGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.1);
            const windowMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.7, roughness: 0.2, metalness: 0.1 });
            
            // Revert to one front window
            const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow.position.set(1.2, 1.8, 2.05); 
            frontWindow.castShadow = true;
            house.add(frontWindow);
            // Clear windowLights and add only one for the front window
            windowLights = []; 
            const frontWindowLight = new THREE.PointLight(0xFFE0B2, daySettings.windowLightIntensity, 5); 
            frontWindowLight.position.set(1.2, 1.8, 1.95); 
            frontWindowLight.castShadow = true;
            house.add(frontWindowLight);
            windowLights.push(frontWindowLight); 


            const sideWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            sideWindow.position.set(2.05, 1.8, 0); // Side window
            sideWindow.rotation.y = Math.PI / 2; 
            sideWindow.castShadow = true;
            house.add(sideWindow);

            const sideWindowLight = new THREE.PointLight(0xFFE0B2, daySettings.windowLightIntensity, 5); 
            sideWindowLight.position.set(1.95, 1.8, 0); 
            sideWindowLight.castShadow = true;
            house.add(sideWindowLight);
            windowLights.push(sideWindowLight); 

            const chimneyGeometry = new THREE.BoxGeometry(0.6, 1.5, 0.6);
            const chimneyMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.7, metalness: 0.0 });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(-1.2, 4.5, -1.2); // Revert chimney position
            chimney.castShadow = true;
            house.add(chimney);

            scene.add(house);
        }

        function createPlayer() {
            player = new THREE.Group();

            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1, roughness: 0.5 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6; 
            body.castShadow = true;
            player.add(body);

            const headGeometry = new THREE.SphereGeometry(0.25);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3, roughness: 0.6 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.45; 
            head.castShadow = true;
            player.add(head);

            const eyeGeometry = new THREE.SphereGeometry(0.05);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.5, 0.2); 
            player.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.5, 0.2); 
            player.add(rightEye);

            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3, roughness: 0.6 });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.45, 0.8, 0); 
            leftArm.castShadow = true;
            player.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.45, 0.8, 0); 
            rightArm.castShadow = true;
            player.add(rightArm);

            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8); 
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.7 });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, -0.4, 0); 
            leftLeg.castShadow = true;
            player.add(leftLeg);
            player.userData.leftLeg = leftLeg; 

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, -0.4, 0); 
            rightLeg.castShadow = true;
            player.add(rightLeg);
            player.userData.rightLeg = rightLeg; 

            player.position.copy(playerPosition); 
            scene.add(player);
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100); 
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x90EE90, roughness: 0.9, metalness: 0.0 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createTrees() {
            const numDeciduousTrees = 30; // Number of deciduous trees
            const numFirTrees = 40; ¬† ¬† // Number of fir trees

            // Define house bounding box for collision detection
            // House dimensions: width 4, depth 4. Position: (0, 0, 0)
            const houseMinX = -2;
            const houseMaxX = 2;
            const houseMinZ = -2;
            const houseMaxZ = 2;

            // Define lake bounding circle for collision detection
            const lakeCenterX = 30;
            const lakeCenterZ = 0;
            const lakeRadius = 15;
            const lakeBuffer = 3; // Buffer zone around the lake

            // Deciduous trees
            const deciduousTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const deciduousFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });

            for (let i = 0; i < numDeciduousTrees; i++) {
                const tree = new THREE.Group();
                let treeX, treeZ;
                let isValidPosition = false;

                // Keep generating random positions until it's outside the house and lake
                while (!isValidPosition) {
                    treeX = -45 + Math.random() * 90; 
                    treeZ = -45 + Math.random() * 90;

                    // Check if the tree is too close to the house
                    const isNearHouse = (treeX >= houseMinX - 3 && treeX <= houseMaxX + 3 && 
                                        treeZ >= houseMinZ - 3 && treeZ <= houseMaxZ + 3);

                    // Check if the tree is too close to the lake
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(treeX - lakeCenterX, 2) + 
                        Math.pow(treeZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (lakeRadius + lakeBuffer);

                    if (!isNearHouse && !isNearLake) {
                        isValidPosition = true;
                    }
                }
                
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2);
                const trunk = new THREE.Mesh(trunkGeometry, deciduousTrunkMaterial);
                trunk.position.y = 1;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                tree.add(trunk);

                const foliageGeometry = new THREE.SphereGeometry(1.2);
                const foliage = new THREE.Mesh(foliageGeometry, deciduousFoliageMaterial);
                foliage.position.y = 2.5;
                foliage.castShadow = true;
                tree.add(foliage);

                tree.position.x = treeX; 
                tree.position.z = treeZ; 
                tree.scale.setScalar(0.7 + Math.random() * 0.6); 

                scene.add(tree);
            }

            // Fir trees (coniferous)
            const firTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.8 }); 
            const firFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 0.7 }); 

            for (let i = 0; i < numFirTrees; i++) {
                const firTree = new THREE.Group();
                let treeX, treeZ;
                let isValidPosition = false;

                // Keep generating random positions until it's outside the house and lake
                while (!isValidPosition) {
                    treeX = -45 + Math.random() * 90; 
                    treeZ = -45 + Math.random() * 90;

                    // Check if the tree is too close to the house
                    const isNearHouse = (treeX >= houseMinX - 3 && treeX <= houseMaxX + 3 && 
                                        treeZ >= houseMinZ - 3 && treeZ <= houseMaxZ + 3);

                    // Check if the tree is too close to the lake
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(treeX - lakeCenterX, 2) + 
                        Math.pow(treeZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (lakeRadius + lakeBuffer);

                    if (!isNearHouse && !isNearLake) {
                        isValidPosition = true;
                    }
                }

                const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.25, 2.5); 
                const trunk = new THREE.Mesh(trunkGeometry, firTrunkMaterial);
                trunk.position.y = 1.25;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                firTree.add(trunk);

                // Use a single variable for foliage meshes within the loop
                let foliageGeometry;
                let foliageMesh;

                foliageGeometry = new THREE.ConeGeometry(1.5, 2, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial);
                foliageMesh.position.y = 2.5;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                foliageGeometry = new THREE.ConeGeometry(1.0, 1.5, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial);
                foliageMesh.position.y = 3.5;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                foliageGeometry = new THREE.ConeGeometry(0.6, 1.0, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial); 
                foliageMesh.position.y = 4.2;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                firTree.position.x = treeX; 
                firTree.position.z = treeZ; 
                firTree.scale.setScalar(0.8 + Math.random() * 0.7); 

                scene.add(firTree);
            }
        }

        function createLake() {
            const shapePoints = [
                new THREE.Vector2(0, 15),
                new THREE.Vector2(8, 12),
                new THREE.Vector2(13, 5),
                new THREE.Vector2(15, -5),
                new THREE.Vector2(10, -12),
                new THREE.Vector2(0, -15),
                new THREE.Vector2(-10, -12),
                new THREE.Vector2(-15, -5),
                new THREE.Vector2(-13, 5),
                new THREE.Vector2(-8, 12)
            ];

            const lakeShape = new THREE.Shape(shapePoints);
            const lakeGeometry = new THREE.ShapeGeometry(lakeShape); 
            
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x0066FF, 
                transparent: true,
                opacity: 0.7,
                roughness: 0.1, 
                metalness: 0.8, 
                side: THREE.DoubleSide 
            });
            const lake = new THREE.Mesh(lakeGeometry, waterMaterial);
            lake.rotation.x = -Math.PI / 2; 
            lake.position.set(30, 0.01, 0); 
            scene.add(lake);

            const numFish = 10;
            const fishGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.2); 
            const fishMaterial = new THREE.MeshStandardMaterial({ color: 0xFF8C00 }); 

            const fishBoundaryRadius = 18; 

            for (let i = 0; i < numFish; i++) {
                const f = new THREE.Mesh(fishGeometry, fishMaterial);
                f.position.set(
                    lake.position.x + (Math.random() - 0.5) * fishBoundaryRadius * 1.8, 
                    lake.position.y - (0.1 + Math.random() * 0.3), 
                    lake.position.z + (Math.random() - 0.5) * fishBoundaryRadius * 1.8
                );
                f.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.025, 
                    0,
                    (Math.random() - 0.5) * 0.025 
                );
                f.userData.swimCycle = Math.random() * Math.PI * 2; 
                scene.add(f);
                fish.push(f);
            }
        }

        function createLakeVegetation() {
            const lakeCenter = new THREE.Vector3(30, 0, 0); 
            const lakeRadius = 15; 
            const numBushes = 30;
            const numReeds = 50;

            const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x558B2F, roughness: 0.8 });
            for (let i = 0; i < numBushes; i++) {
                const bushGeometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.3, 8, 8);
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = lakeRadius + 2 + Math.random() * 5; 
                bush.position.set(
                    lakeCenter.x + Math.cos(angle) * distance,
                    0.15, 
                    lakeCenter.z + Math.sin(angle) * distance
                );
                bush.scale.y = 0.7 + Math.random() * 0.6; 
                bush.castShadow = true;
                bush.receiveShadow = true;
                scene.add(bush);
            }

            const reedStemMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
            const reedHeadMaterial = new THREE.MeshStandardMaterial({ color: 0x6B8E23, roughness: 0.7 });
            for (let i = 0; i < numReeds; i++) {
                const reed = new THREE.Group();
                const height = 0.8 + Math.random() * 0.7;

                const stemGeometry = new THREE.CylinderGeometry(0.02, 0.03, height, 4);
                const stem = new THREE.Mesh(stemGeometry, reedStemMaterial);
                stem.position.y = height / 2;
                stem.castShadow = true;
                stem.receiveShadow = true;
                reed.add(stem);

                const headGeometry = new THREE.BoxGeometry(0.08, 0.2, 0.08);
                const head = new THREE.Mesh(headGeometry, reedHeadMaterial);
                head.position.y = height + 0.1;
                head.rotation.y = Math.random() * Math.PI;
                head.castShadow = true;
                reed.add(head);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = lakeRadius - 1 + Math.random() * 2; 
                reed.position.set(
                    lakeCenter.x + Math.cos(angle) * distance,
                    0, 
                    lakeCenter.z + Math.sin(angle) * distance
                );
                reed.rotation.y = Math.random() * Math.PI * 2; 
                reed.rotation.z = (Math.random() - 0.5) * 0.2; 
                scene.add(reed);
            }
        }

        function createPierAndBoat() {
            const lakeCenter = new THREE.Vector3(30, 0.01, 0); // Center of the lake, Y = 0.01

            // Create pier
            const pierMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6 }); // Dark brown
            
            // Main part of the pier
            const pierBaseGeometry = new THREE.BoxGeometry(1.5, 0.2, 5); // Width, height, length
            const pierBase = new THREE.Mesh(pierBaseGeometry, pierMaterial);
            // Position the pier slightly above the lake level
            pierBase.position.set(lakeCenter.x + 10, lakeCenter.y + pierBaseGeometry.parameters.height / 2 + 0.01, lakeCenter.z + 10); 
            pierBase.castShadow = true;
            pierBase.receiveShadow = true;
            scene.add(pierBase);

            // Pier supports
            const pierLegGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
            for (let i = 0; i < 3; i++) {
                const leg1 = new THREE.Mesh(pierLegGeometry, pierMaterial);
                // Supports should go underwater
                leg1.position.set(pierBase.position.x - 0.5, lakeCenter.y - 0.4, pierBase.position.z - 1.5 + i * 1.5);
                leg1.castShadow = true;
                scene.add(leg1);

                const leg2 = new THREE.Mesh(pierLegGeometry, pierMaterial);
                leg2.position.set(pierBase.position.x + 0.5, lakeCenter.y - 0.4, pierBase.position.z - 1.5 + i * 1.5);
                leg2.castShadow = true;
                scene.add(leg2);
            }

            // Create boat
            const boat = new THREE.Group();
            const boatMaterial = new THREE.MeshStandardMaterial({ color: 0x6A5ACD, roughness: 0.4, metalness: 0.1 }); // Bluish-purple
            const boatInsideMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6 }); // Inside of the boat

            // Boat hull (main part)
            const boatHullGeometry = new THREE.BoxGeometry(0.8, 0.3, 2.5);
            const boatHull = new THREE.Mesh(boatHullGeometry, boatMaterial);
            boatHull.position.y = 0; // Center of the hull will be at the boat group's Y level
            boat.add(boatHull);

            // Boat front (cone or more complex shape)
            const boatFrontGeometry = new THREE.ConeGeometry(0.4, 0.5, 4); // Radius, height, segments
            const boatFront = new THREE.Mesh(boatFrontGeometry, boatMaterial);
            boatFront.rotation.x = Math.PI / 2; // Rotate to face forward
            boatFront.position.set(0, 0, 1.25); // Position in front of the hull
            boat.add(boatFront);

            // Inside part (seat)
            const seatGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.5);
            const seat = new THREE.Mesh(seatGeometry, boatInsideMaterial);
            seat.position.set(0, 0.1, 0); // Inside the hull, slightly above the bottom
            boat.add(seat);

            // Position the boat at lake level
            // Boat Y-position: lake level + half of the boat hull height
            boat.position.set(pierBase.position.x + 1.2, lakeCenter.y + boatHullGeometry.parameters.height / 2, pierBase.position.z + 1.5); 
            boat.rotation.y = -Math.PI / 4; // Rotate the boat slightly
            boat.castShadow = true;
            boat.receiveShadow = true;
            scene.add(boat);
        }

        function createEnclosureAndCow() {
            const fenceRadius = 6; // Radius of the circular fence, close to the house
            const fenceHeight = 0.8;
            const postRadius = 0.08;
            const numPosts = 16; // Number of posts for the circular fence

            const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.7 }); // Brown color for the fence

            const posts = [];
            for (let i = 0; i < numPosts; i++) {
                const angle = (i / numPosts) * Math.PI * 2;
                const x = Math.cos(angle) * fenceRadius;
                const z = Math.sin(angle) * fenceRadius;
                posts.push(new THREE.Vector3(x, fenceHeight / 2, z));
            }

            // Create fence posts
            const fencePostGeometry = new THREE.CylinderGeometry(postRadius, postRadius, fenceHeight, 8);
            posts.forEach(pos => {
                const post = new THREE.Mesh(fencePostGeometry, fenceMaterial);
                post.position.copy(pos);
                post.castShadow = true;
                post.receiveShadow = true;
                scene.add(post);
            });

            // Create cow
            const cow = new THREE.Group();
            const cowBodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 }); // Brown body
            const cowSpotMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.7 }); // White spots
            const cowHornMaterial = new THREE.MeshStandardMaterial({ color: 0xD3D3D3, roughness: 0.5 }); // Grey horns
            const cowHoofMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 }); // Black hooves

            // Body
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.7);
            const body = new THREE.Mesh(bodyGeometry, cowBodyMaterial);
            body.position.y = 0.4;
            body.castShadow = true;
            body.receiveShadow = true;
            cow.add(body);

            // Head
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.4);
            const head = new THREE.Mesh(headGeometry, cowBodyMaterial);
            head.position.set(0.7, 0.6, 0);
            head.castShadow = true;
            cow.add(head);

            // Snout (lighter)
            const snoutGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.3);
            const snoutMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDAB9, roughness: 0.7 }); // Peach color
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(0.9, 0.5, 0);
            snout.castShadow = true;
            cow.add(snout);

            // Ears
            const earGeometry = new THREE.ConeGeometry(0.1, 0.2, 4);
            const leftEar = new THREE.Mesh(earGeometry, cowBodyMaterial);
            leftEar.position.set(0.6, 0.9, 0.2);
            leftEar.rotation.z = Math.PI / 2;
            leftEar.rotation.x = Math.PI / 6;
            leftEar.castShadow = true;
            cow.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, cowBodyMaterial);
            rightEar.position.set(0.6, 0.9, -0.2);
            rightEar.rotation.z = Math.PI / 2;
            rightEar.rotation.x = -Math.PI / 6;
            rightEar.castShadow = true;
            cow.add(rightEar);

            // Horns
            const hornGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
            const leftHorn = new THREE.Mesh(hornGeometry, cowHornMaterial);
            leftHorn.position.set(0.6, 0.8, 0.15);
            leftHorn.rotation.x = Math.PI / 2;
            leftHorn.rotation.y = Math.PI / 6;
            leftHorn.castShadow = true;
            cow.add(leftHorn);

            const rightHorn = new THREE.Mesh(hornGeometry, cowHornMaterial);
            rightHorn.position.set(0.6, 0.8, -0.15);
            rightHorn.rotation.x = Math.PI / 2;
            rightHorn.rotation.y = -Math.PI / 6;
            rightHorn.castShadow = true;
            cow.add(rightHorn);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
            const legs = [
                new THREE.Vector3(-0.5, 0.25, 0.3),
                new THREE.Vector3(0.5, 0.25, 0.3),
                new THREE.Vector3(-0.5, 0.25, -0.3),
                new THREE.Vector3(0.5, 0.25, -0.3)
            ];
            legs.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, cowBodyMaterial);
                leg.position.copy(pos);
                leg.castShadow = true;
                cow.add(leg);

                // Hooves
                const hoofGeometry = new THREE.BoxGeometry(0.12, 0.05, 0.12);
                const hoof = new THREE.Mesh(hoofGeometry, cowHoofMaterial);
                hoof.position.set(pos.x, 0.025, pos.z);
                hoof.castShadow = true;
                cow.add(hoof);
            });

            // Tail
            const tailGeometry = new THREE.CylinderGeometry(0.02, 0.01, 0.4, 8);
            const tail = new THREE.Mesh(tailGeometry, cowBodyMaterial);
            tail.position.set(-0.7, 0.6, 0);
            tail.rotation.x = Math.PI / 4;
            tail.castShadow = true;
            cow.add(tail);

            const tailTuftGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const tailTuft = new THREE.Mesh(tailTuftGeometry, cowSpotMaterial); // White tail tip
            tailTuft.position.set(-0.7 - Math.sin(Math.PI/4) * 0.4, 0.6 + Math.cos(Math.PI/4) * 0.4, 0);
            tailTuft.castShadow = true;
            cow.add(tailTuft);


            // Position the cow inside the enclosure
            cow.position.set(0, 0, 0); // Cow will be at the center of the enclosure
            cow.rotation.y = Math.PI / 2; // Rotate the cow
            scene.add(cow);
        }

        function createSmokeParticles() {
            const particleGeometry = new THREE.SphereGeometry(0.1);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0xDDDDDD,
                transparent: true,
                opacity: 0.6
            });

            for (let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(-1.2, 5.2 + i * 0.3, -1.2);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.02
                    ),
                    life: Math.random()
                };
                particles.push(particle);
                scene.add(particle);
            }
        }

        function setupLighting() {
            scene.children.forEach(obj => {
                if (obj instanceof THREE.Light) {
                    scene.remove(obj);
                }
            });

            const ambientLight = new THREE.AmbientLight(0x404040, daySettings.ambientIntensity);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(daySettings.directionalColor, daySettings.directionalIntensity);
            directionalLight.position.copy(daySettings.directionalPosition);
            directionalLight.castShadow = true;

            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            const hemisphereLight = new THREE.HemisphereLight(daySettings.hemisphereSkyColor, daySettings.hemisphereGroundColor, daySettings.hemisphereIntensity);
            scene.add(hemisphereLight);
        }

        function setupControls() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            window.addEventListener('resize', onWindowResize);

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            document.getElementById('toggleDayNightButton').addEventListener('click', toggleDayNight);
        }

        function onKeyDown(event) {
            keys[event.code] = true;
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX));

                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onWheel(event) {
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(3, Math.min(50, cameraDistance)); 
        }

        function toggleDayNight() {
            isDayTime = !isDayTime;
            targetTransitionProgress = isDayTime ? 1 : 0; 

            const button = document.getElementById('toggleDayNightButton');
            if (button) {
                button.textContent = isDayTime ? '‚òÄÔ∏è' : 'üåô';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (transitionProgress !== targetTransitionProgress) {
                const delta = targetTransitionProgress - transitionProgress;
                transitionProgress += Math.sign(delta) * transitionSpeed;

                transitionProgress = Math.max(0, Math.min(1, transitionProgress));

                const fogColorDay = new THREE.Color(daySettings.fogColor);
                const fogColorNight = new THREE.Color(nightSettings.fogColor);
                scene.fog.color.copy(fogColorNight).lerp(fogColorDay, transitionProgress);

                const clearColorDay = new THREE.Color(daySettings.clearColor);
                const clearColorNight = new THREE.Color(nightSettings.clearColor);
                const currentClearColor = new THREE.Color().copy(clearColorNight).lerp(clearColorDay, transitionProgress);
                renderer.setClearColor(currentClearColor, 1);

                const ambientLight = scene.children.find(obj => obj instanceof THREE.AmbientLight);
                const directionalLight = scene.children.find(obj => obj instanceof THREE.DirectionalLight);
                const hemisphereLight = scene.children.find(obj => obj instanceof THREE.HemisphereLight);

                if (ambientLight) {
                    ambientLight.intensity = nightSettings.ambientIntensity + (daySettings.ambientIntensity - nightSettings.ambientIntensity) * transitionProgress;
                }
                if (directionalLight) {
                    const dirColorDay = new THREE.Color(daySettings.directionalColor);
                    const dirColorNight = new THREE.Color(nightSettings.directionalColor);
                    directionalLight.color.copy(dirColorNight).lerp(dirColorDay, transitionProgress);
                    directionalLight.intensity = nightSettings.directionalIntensity + (daySettings.directionalIntensity - nightSettings.directionalIntensity) * transitionProgress;
                    directionalLight.position.lerpVectors(nightSettings.directionalPosition, daySettings.directionalPosition, transitionProgress);
                }
                if (hemisphereLight) {
                    const hemiSkyColorDay = new THREE.Color(daySettings.hemisphereSkyColor);
                    const hemiSkyColorNight = new THREE.Color(nightSettings.hemisphereSkyColor);
                    hemisphereLight.color.copy(hemiSkyColorNight).lerp(hemiSkyColorDay, transitionProgress);

                    const hemiGroundColorDay = new THREE.Color(daySettings.hemisphereGroundColor);
                    const hemiGroundColorNight = new THREE.Color(nightSettings.hemisphereGroundColor);
                    hemisphereLight.groundColor.copy(hemiGroundColorNight).lerp(hemiGroundColorDay, transitionProgress);
                    hemisphereLight.intensity = nightSettings.hemisphereIntensity + (daySettings.hemisphereIntensity - nightSettings.hemisphereIntensity) * transitionProgress;
                }

                windowLights.forEach(light => {
                    light.intensity = nightSettings.windowLightIntensity + (daySettings.windowLightIntensity - nightSettings.windowLightIntensity) * transitionProgress;
                });
            }

            updatePlayer();

            const cameraOffset = new THREE.Vector3(
                Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance,
                Math.sin(cameraAngleX) * cameraDistance + 3,
                Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance
            );

            camera.position.copy(playerPosition).add(cameraOffset);
            camera.lookAt(playerPosition.x, playerPosition.y + 1, playerPosition.z);

            // Corrected: Use 'particle' and 'idx' from forEach callback
            particles.forEach((particle, idx) => { // Changed 'i' to 'idx' for clarity and correct scope
                particle.position.add(particle.userData.velocity);
                particle.userData.life += 0.01;

                if (particle.userData.life > 1 || particle.position.y > 15) {
                    particle.position.set(-1.2, 5.2 + idx * 0.3, -1.2); // Use idx here
                    particle.userData.life = 0;
                    particle.userData.velocity.set(
                        (Math.random() - 0.5) * 0.02,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.02
                    );
                }

                particle.material.opacity = 0.6 * (1 - particle.userData.life);
            });

            const lakeCenter = new THREE.Vector3(30, 0.01, 0); 
            const fishBoundaryRadius = 18; 
            fish.forEach(f => {
                f.position.add(f.userData.velocity);
                
                const distanceToCenter = f.position.distanceTo(lakeCenter);
                if (distanceToCenter > fishBoundaryRadius) { 
                    const directionToCenter = new THREE.Vector3().subVectors(lakeCenter, f.position).normalize();
                    f.userData.velocity.copy(directionToCenter).multiplyScalar(0.025 + Math.random() * 0.01); 
                    
                    f.userData.velocity.x += (Math.random() - 0.5) * 0.005; 
                    f.userData.velocity.z += (Math.random() - 0.5) * 0.005; 
                    f.userData.velocity.normalize().multiplyScalar(0.025); 
                }

                f.position.y += Math.sin(f.userData.swimCycle) * 0.005; 
                f.userData.swimCycle += 0.05;

                f.rotation.y = Math.atan2(f.userData.velocity.x, f.userData.velocity.z);
            });


            house.rotation.y = Math.sin(Date.now() * 0.0005) * 0.02;

            renderer.render(scene, camera);
        }

        function updatePlayer() {
            let isMoving = false;
            const speed = keys['ShiftLeft'] || keys['ShiftRight'] ? 0.15 : 0.08;
            const moveDirection = new THREE.Vector3(); // –í–µ–∫—Ç–æ—Ä –¥–ª—è –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection); // –ü–æ–ª—É—á–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ, –∫—É–¥–∞ —Å–º–æ—Ç—Ä–∏—Ç –∫–∞–º–µ—Ä–∞

            // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –¥–≤–∏–∂–µ–Ω–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ç–æ–ª—å–∫–æ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º Y-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É –∫–∞–º–µ—Ä—ã)
            cameraDirection.y = 0;
            cameraDirection.normalize();

            const cameraRight = new THREE.Vector3();
            // –í–µ–∫—Ç–æ—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ up-–≤–µ–∫—Ç–æ—Ä–∞ –∫–∞–º–µ—Ä—ã –∏ forward-–≤–µ–∫—Ç–æ—Ä–∞ –¥–∞–µ—Ç right-–≤–µ–∫—Ç–æ—Ä
            cameraRight.crossVectors(camera.up, cameraDirection); 
            cameraRight.normalize();

            // –í—ã—á–∏—Å–ª—è–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–∂–∞—Ç—ã—Ö –∫–ª–∞–≤–∏—à
            if (keys['KeyW'] || keys['ArrowUp']) {
                moveDirection.add(cameraDirection);
                isMoving = true;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                moveDirection.sub(cameraDirection);
                isMoving = true;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                moveDirection.add(cameraRight); // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ (–±—ã–ª–æ –≤–ª–µ–≤–æ)
                isMoving = true;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                moveDirection.sub(cameraRight); // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ª–µ–≤–æ (–±—ã–ª–æ –≤–ø—Ä–∞–≤–æ)
                isMoving = true;
            }

            if (isMoving) {
                moveDirection.normalize().multiplyScalar(speed);
                playerPosition.add(moveDirection);

                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç –∏–≥—Ä–æ–∫–∞, —á—Ç–æ–±—ã –æ–Ω —Å–º–æ—Ç—Ä–µ–ª –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è
                // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
                if (Math.abs(moveDirection.x) > 0.0001 || Math.abs(moveDirection.z) > 0.0001) {
                    player.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);
                }

                walkAnimation += 0.2;
                if (player.userData.leftLeg && player.userData.rightLeg) {
                    player.userData.leftLeg.rotation.x = Math.sin(walkAnimation) * 0.3;
                    player.userData.rightLeg.rotation.x = -Math.sin(walkAnimation) * 0.3;
                }
            } else {
                if (player.userData.leftLeg && player.userData.rightLeg) {
                    player.userData.leftLeg.rotation.x = 0;
                    player.userData.rightLeg.rotation.x = 0;
                }
            }

            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∏–≥—Ä–æ–∫–∞ –≥—Ä–∞–Ω–∏—Ü–∞–º–∏
            playerPosition.x = Math.max(-45, Math.min(45, playerPosition.x));
            playerPosition.z = Math.max(-45, Math.min(45, playerPosition.z));

            player.position.copy(playerPosition);
        }

        window.onload = init; 
    </script>
</body>
</html>

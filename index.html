<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –î–æ–º–∏–∫ - –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç—å —Å –∫—Ä–∞—Ñ—Ç–æ–º –∏ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ–º</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        #controls h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }

        #controls p {
            margin: 5px 0;
            color: #666;
            font-size: 12px;
        }

        .key {
            display: inline-block;
            background: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 0 2px;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px; /* Reduced padding */
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-width: 250px;
            display: flex; /* Use flexbox for button alignment */
            flex-direction: column; /* Stack items vertically */
            align-items: flex-start; /* Align items to the start */
        }

        #info h3 { 
            margin: 0 0 0px 0; 
            color: #333;
            font-size: 16px;
        }

        #info p {
            margin: 5px 0;
            color: #666;
            font-size: 12px;
            line-height: 1.4;
        }

        #dayNightSliderContainer {
            margin-top: 10px;
            width: 100%;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #dayNightSlider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: linear-gradient(to right, #101040, #87CEEB);
            border-radius: 5px;
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
        }

        #dayNightSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #dayNightSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #dayNightIcon {
            font-size: 24px;
            line-height: 1;
        }

        #game-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            color: #333;
            font-size: 16px;
            font-weight: bold;
        }

        #resource-counters {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
        }

        #inventory-ui {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            color: #333;
            font-size: 14px;
            display: none; /* –°–∫—Ä—ã—Ç–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
        }

        #inventory-ui h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
            font-size: 16px;
        }

        #inventory-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 2 –∫–æ–ª–æ–Ω–∫–∏ */
            gap: 5px;
        }

        #inventory-list li {
            background: #f0f0f0;
            padding: 5px 8px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #crafting-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 101;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
            color: #333;
            width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            display: none; /* –°–∫—Ä—ã—Ç–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
            flex-direction: column;
            gap: 15px;
        }

        #crafting-ui h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 20px;
            text-align: center;
        }

        .crafting-recipe {
            display: flex;
            flex-direction: column;
            background: #f8f8f8;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease-in-out;
        }

        .crafting-recipe:hover {
            background: #eef;
            border-color: #cdd;
            transform: translateY(-2px);
        }

        .recipe-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .recipe-header strong {
            font-size: 16px;
            color: #555;
        }

        .recipe-ingredients {
            font-size: 12px;
            color: #777;
            margin-bottom: 10px;
        }

        .craft-button {
            padding: 8px 15px;
            background: linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(76, 175, 80, 0.3);
        }

        .craft-button:hover {
            background: linear-gradient(135deg, #45a049 0%, #5cb860 100%);
            box-shadow: 0 6px 15px rgba(76, 175, 80, 0.4);
        }

        .craft-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        #crafting-close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff4d4d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background 0.2s ease-in-out;
        }

        #crafting-close-button:hover {
            background: #cc0000;
        }

        #toggle-inventory-button, #toggle-crafting-button {
            padding: 10px 15px;
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(0, 123, 255, 0.3);
            margin-top: 10px;
            width: 100%;
        }

        #toggle-inventory-button:hover, #toggle-crafting-button:hover {
            background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
            box-shadow: 0 6px 15px rgba(0, 123, 255, 0.4);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>üè† –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
            <p>üñ±Ô∏è –ú—ã—à—å: –ø–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</p>
            <p>üîÑ –ö–æ–ª–µ—Å–æ: –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ</p>
            <p>üö∂ <span class="key">WASD</span> –∏–ª–∏ <span class="key">‚Üë‚Üì‚Üê‚Üí</span>: –¥–≤–∏–∂–µ–Ω–∏–µ</p>
            <p>üèÉ <span class="key">Shift</span>: –±–µ–≥</p>
            <p>ü™µ <span class="key">E</span>: –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ (–≤–∑—è—Ç—å/–ø–æ–ª–æ–∂–∏—Ç—å —Ä–µ—Å—É—Ä—Å)</p>
            <p>üì¶ <span class="key">I</span>: –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</p>
            <p>üõ†Ô∏è <span class="key">C</span>: –ö—Ä–∞—Ñ—Ç</p>
        </div>

        <div id="info">
            <div id="dayNightSliderContainer">
                <span id="dayNightIcon">‚òÄÔ∏è</span>
                <input type="range" id="dayNightSlider" min="0" max="100" value="100">
            </div>
        </div>

        <div id="game-ui">
            <div id="resource-counters">
                <span>–ë—Ä–µ–≤–Ω–∞ —Å–æ–±—Ä–∞–Ω—ã: <span id="collectedLogsCount">0</span></span>
                <span>–ö–∞–º–Ω–∏ —Å–æ–±—Ä–∞–Ω—ã: <span id="collectedStonesCount">0</span></span>
            </div>
            <button id="toggle-inventory-button">–û—Ç–∫—Ä—ã—Ç—å –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å</button>
            <button id="toggle-crafting-button">–û—Ç–∫—Ä—ã—Ç—å –∫—Ä–∞—Ñ—Ç</button>
        </div>

        <div id="inventory-ui">
            <h3>üì¶ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</h3>
            <ul id="inventory-list">
                </ul>
        </div>

        <div id="crafting-ui">
            <h3>üõ†Ô∏è –ö—Ä–∞—Ñ—Ç</h3>
            <div id="crafting-recipes">
                </div>
            <button id="crafting-close-button">‚úñ</button>
        </div>
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Å—Ü–µ–Ω—ã
        let scene, camera, renderer, house, particles = [], player;
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–≤–µ—Ç–∞, —á—Ç–æ–±—ã –∏—Ö –º–æ–∂–Ω–æ –±—ã–ª–æ –æ–±–Ω–æ–≤–ª—è—Ç—å –Ω–∞–ø—Ä—è–º—É—é
        let ambientLight, directionalLight, hemisphereLight; 
        let isMouseDown = false, mouseX = 0, mouseY = 0;
        let cameraAngleX = 0.3, cameraAngleY = 0;
        let cameraDistance = 40; // –ù–∞—á–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∫–∞–º–µ—Ä—ã
        let isDayTime = true; // –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ª–æ–≥–∏–∫–∏ —Å–≤–µ—Ç–ª—è—á–∫–æ–≤ –∏ –∏–∫–æ–Ω–∫–∏
        let keys = {};
        let playerPosition = new THREE.Vector3(-10, 0.8, 0); 
        let playerRotation = 0;
        let walkAnimation = 0;
        let windowLights = []; // –û–≥–Ω–∏ –≥–ª–∞–≤–Ω–æ–≥–æ –¥–æ–º–∞
        let barnLights = []; // –û–≥–Ω–∏ —Å–∞—Ä–∞–π—á–∏–∫–∞
        let quarryLights = []; // –û–≥–Ω–∏ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
        let fish = []; 
        let rabbits = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ –∫—Ä–æ–ª–∏–∫–æ–≤
        let clouds = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ –æ–±–ª–∞–∫–æ–≤
        let fireflies = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ —Å–≤–µ—Ç–ª—è—á–∫–æ–≤
        let bird; // –û–±—ä–µ–∫—Ç –ø—Ç–∏—Ü—ã
        let deer = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ –æ–ª–µ–Ω–µ–π

        // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let playerHasResource = false; // –ú–æ–∂–µ—Ç –¥–µ—Ä–∂–∞—Ç—å –ª–∏–±–æ –±—Ä–µ–≤–Ω–æ, –ª–∏–±–æ –∫–∞–º–µ–Ω—å
        let currentHeldResource = null; // –¢–µ–∫—É—â–∏–π —É–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ä–µ—Å—É—Ä—Å (THREE.Mesh)
        let currentResourceType = null; // 'log' –∏–ª–∏ 'stone'
        let logDropOffPileGroup = null; // –ì—Ä—É–ø–ø–∞ –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º—ã—Ö –±—Ä–µ–≤–µ–Ω —É —Å–∞—Ä–∞–π—á–∏–∫–∞ (–ª–µ—Å–æ–ø–∏–ª–∫–∏)
        let stoneDropOffPileGroup = null; // –ì—Ä—É–ø–ø–∞ –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º—ã—Ö –∫–∞–º–Ω–µ–π —É –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
        let quarryHouse = null; // –î–æ–º –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
        const interactDistance = 3; // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è (–ø–æ–¥–±–æ—Ä–∞/–≤—ã–≥—Ä—É–∑–∫–∏)
        let collectibleTrees = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –≤—Å–µ—Ö —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤
        let collectibleStones = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è –≤—Å–µ—Ö —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –∫–∞–º–Ω–µ–π (—Ç–µ–ø–µ—Ä—å –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –≤ createRocks)
        let collectibleBerryBushes = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö —è–≥–æ–¥–Ω—ã—Ö –∫—É—Å—Ç–æ–≤
        let collectibleMetalOres = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –º–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏—Ö —Ä—É–¥
        let collectibleFlowers = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö —Ü–≤–µ—Ç–æ–≤
        let collectibleMushrooms = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –≥—Ä–∏–±–æ–≤
        let placedBuildingBlocks = []; // –ù–æ–≤—ã–π –º–∞—Å—Å–∏–≤ –¥–ª—è –±–ª–æ–∫–æ–≤, —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–æ–º –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞

        let transitionProgress = 1; // 1 = –¥–µ–Ω—å, 0 = –Ω–æ—á—å
        const transitionSpeed = 0.02; // –°–∫–æ—Ä–æ—Å—Ç—å –ø–µ—Ä–µ—Ö–æ–¥–∞
        const dayNightCycleDuration = 20 * 60 * 1000; // 20 –º–∏–Ω—É—Ç –≤ –º–∏–ª–ª–∏—Å–µ—Å–µ–∫—É–Ω–¥–∞—Ö
        const halfDayNightCycle = dayNightCycleDuration / 2; // 10 –º–∏–Ω—É—Ç

        let isSliderDragging = false; // –§–ª–∞–≥ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è –ø–æ–ª–∑—É–Ω–∫–∞
        let isManualTimeControl = false; // –§–ª–∞–≥, –∫–æ—Ç–æ—Ä—ã–π —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è true, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—Ä—É—á–Ω—É—é –∏–∑–º–µ–Ω–∏–ª –ø–æ–ª–∑—É–Ω–æ–∫

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —Ä–∞–∑–º–µ—Ä–æ–≤ –º–∏—Ä–∞ –∏ –æ–±—ä–µ–∫—Ç–æ–≤
        const worldSize = 200; // –†–∞–∑–º–µ—Ä –∑–µ–º–ª–∏
        const forestRange = 90; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –¥–ª—è –¥–µ—Ä–µ–≤—å–µ–≤ –∏ –∫–∞–º–Ω–µ–π
        const lakeCenterX = 60; // –¶–µ–Ω—Ç—Ä –æ–∑–µ—Ä–∞ X
        const lakeCenterZ = 0; // –¶–µ–Ω—Ç—Ä –æ–∑–µ—Ä–∞ Z
        const lakeRadius = 30; // –†–∞–¥–∏—É—Å –æ–∑–µ—Ä–∞ (–¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ñ–æ—Ä–º—ã)
        const lakeReedsOffset = 0.5; // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∫–∞–º—ã—à–µ–π –æ—Ç –∫—Ä–∞—è –æ–∑–µ—Ä–∞
        const sunLoungerOffset = 2; // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ª–µ–∂–∞–∫–∞ –æ—Ç –∫–∞–º—ã—à–µ–π

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–Ω—è –∏ –Ω–æ—á–∏ –¥–ª—è –æ—Å–≤–µ—â–µ–Ω–∏—è –∏ —Ç—É–º–∞–Ω–∞
        const daySettings = {
            fogColor: 0xA0D0FF, // –°–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–æ–π —Ç—É–º–∞–Ω
            clearColor: 0xA0D0FF, // –°–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–æ–π —Ü–≤–µ—Ç –æ—á–∏—Å—Ç–∫–∏
            ambientIntensity: 0.4, // –£–º–µ—Ä–µ–Ω–Ω—ã–π –æ–∫—Ä—É–∂–∞—é—â–∏–π —Å–≤–µ—Ç
            directionalColor: 0xffffff, // –ë–µ–ª—ã–π —Å–æ–ª–Ω–µ—á–Ω—ã–π —Å–≤–µ—Ç
            directionalIntensity: 0.8, // –°–∏–ª—å–Ω—ã–π —Å–æ–ª–Ω–µ—á–Ω—ã–π —Å–≤–µ—Ç
            directionalPosition: new THREE.Vector3(10, 15, 10), // –ü–æ–∑–∏—Ü–∏—è —Å–æ–ª–Ω—Ü–∞
            hemisphereSkyColor: 0xC0E0FF, // –°–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–æ–µ –Ω–µ–±–æ –¥–ª—è –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            hemisphereGroundColor: 0xA9D9A9, // –°–≤–µ—Ç–ª–æ-–∑–µ–ª–µ–Ω–∞—è –∑–µ–º–ª—è –¥–ª—è –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            hemisphereIntensity: 0.6, // –£–º–µ—Ä–µ–Ω–Ω—ã–π —Å–≤–µ—Ç –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            windowLightIntensity: 0.0 // –û–∫–Ω–∞ –≤—ã–∫–ª—é—á–µ–Ω—ã –¥–Ω–µ–º
        };

        const nightSettings = {
            fogColor: 0x101040, // –¢–µ–º–Ω–æ-—Å–∏–Ω–∏–π/—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π —Ç—É–º–∞–Ω
            clearColor: 0x101040, // –¢–µ–º–Ω–æ-—Å–∏–Ω–∏–π/—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π —Ü–≤–µ—Ç –æ—á–∏—Å—Ç–∫–∏
            ambientIntensity: 0.25, // –¢—É—Å–∫–ª—ã–π –æ–∫—Ä—É–∂–∞—é—â–∏–π —Å–≤–µ—Ç
            directionalColor: 0x404080, // –ì–æ–ª—É–±–æ–≤–∞—Ç—ã–π –ª—É–Ω–Ω—ã–π —Å–≤–µ—Ç
            directionalIntensity: 0.3, // –¢—É—Å–∫–ª—ã–π –ª—É–Ω–Ω—ã–π —Å–≤–µ—Ç
            directionalPosition: new THREE.Vector3(-10, 15, -10), // –ü–æ–∑–∏—Ü–∏—è –ª—É–Ω—ã
            hemisphereSkyColor: 0x202050, // –¢–µ–º–Ω–æ-—Å–∏–Ω–µ–µ –Ω–µ–±–æ –¥–ª—è –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            hemisphereGroundColor: 0x101010, // –û—á–µ–Ω—å —Ç–µ–º–Ω–∞—è –∑–µ–º–ª—è –¥–ª—è –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            hemisphereIntensity: 0.2, // –û—á–µ–Ω—å —Ç—É—Å–∫–ª—ã–π —Å–≤–µ—Ç –ø–æ–ª—É—Å—Ñ–µ—Ä—ã
            windowLightIntensity: 2.0 // –û–∫–Ω–∞ –≤–∫–ª—é—á–µ–Ω—ã –Ω–æ—á—å—é
        };

        let textureLoader;
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ç–µ–∫—Å—Ç—É—Ä
        let grassTexture, grassNormalMap, woodDiffuseTexture, woodBumpTexture;

        // --- –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –∏ –∫—Ä–∞—Ñ—Ç ---
        let playerInventory = {
            log: 0,
            stone: 0,
            berry: 0,
            flower: 0,
            mushroom: 0,
            ore: 0,
            plank: 0,
            brick: 0,
            'small-wall': 0
        };

        const craftingRecipes = [
            {
                id: 'plank',
                name: '–î–æ—Å–∫–∞',
                output: { type: 'plank', amount: 4 },
                ingredients: { log: 1 }
            },
            {
                id: 'brick',
                name: '–ö–∏—Ä–ø–∏—á',
                output: { type: 'brick', amount: 2 },
                ingredients: { stone: 1 }
            },
            {
                id: 'small-wall',
                name: '–ú–∞–ª–∞—è —Å—Ç–µ–Ω–∞',
                output: { type: 'small-wall', amount: 1 },
                ingredients: { plank: 2, brick: 2 }
            },
            {
                id: 'basic-pickaxe',
                name: '–ë–∞–∑–æ–≤–∞—è –∫–∏—Ä–∫–∞',
                output: { type: 'basic-pickaxe', amount: 1 },
                ingredients: { log: 1, stone: 2 }
            }
        ];

        // --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (–æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –¥–æ init –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏) ---

        /**
         * –°–æ–∑–¥–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω—É—é –º–æ–¥–µ–ª—å –¥–æ–º–∞ —Å–æ —Å—Ç–µ–Ω–∞–º–∏, –∫—Ä—ã—à–µ–π, –¥–≤–µ—Ä—å—é, —Ä—É—á–∫–æ–π, –æ–∫–Ω–∞–º–∏ –∏ –¥—ã–º–æ—Ö–æ–¥–æ–º.
         */
        function createHouse() {
            house = new THREE.Group();

            // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä—ã –∫–∏—Ä–ø–∏—á–∞ –¥–ª—è —Å—Ç–µ–Ω
            const brickTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg',
                function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
                    texture.repeat.set(2, 2); 
                    wallMaterial.map = texture; 
                    wallMaterial.needsUpdate = true; 
                },
                undefined,
                function (err) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ–∫—Å—Ç—É—Ä—ã –∫–∏—Ä–ø–∏—á–∞:', err);
                    wallMaterial.color.set(0x8B4513); // –†–µ–∑–µ—Ä–≤–Ω—ã–π —Ü–≤–µ—Ç, –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å
                    wallMaterial.needsUpdate = true;
                }
            );

            // –°—Ç–µ–Ω—ã
            const wallGeometry = new THREE.BoxGeometry(4, 3, 4); 
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 0.8, metalness: 0.1 });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 1.5;
            walls.castShadow = true;
            walls.receiveShadow = true;
            house.add(walls);

            // –ö—Ä—ã—à–∞
            const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –¥–ª—è –±–æ–ª–µ–µ –≥–ª–∞–¥–∫–æ–≥–æ –∫–æ–Ω—É—Å–∞
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.7, metalness: 0.0 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 4;
            roof.rotation.y = Math.PI / 4; 
            roof.castShadow = true;
            house.add(roof);

            // –î–≤–µ—Ä—å
            const doorGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.1);
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.6, metalness: 0.0 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.9, 2.05); 
            door.castShadow = true;
            house.add(door);

            // –†—É—á–∫–∞ –¥–≤–µ—Ä–∏
            const handleGeometry = new THREE.SphereGeometry(0.05, 16, 16); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –¥–ª—è –±–æ–ª–µ–µ –≥–ª–∞–¥–∫–æ–π —Å—Ñ–µ—Ä—ã
            const handleMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.3, metalness: 0.8 });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(-0.3, 0.9, 2.1);
            handle.castShadow = true;
            house.add(handle);

            // –û–∫–Ω–∞
            const windowGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.1);
            // –î–æ–±–∞–≤–ª–µ–Ω—ã polygonOffset –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            const windowMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.7, roughness: 0.2, metalness: 0.1, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: 1 });
            // –î–æ–±–∞–≤–ª–µ–Ω—ã polygonOffset –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            const windowFrameMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.5, polygonOffset: true, polygonOffsetFactor: -2, polygonOffsetUnits: 1 }); 

            // –ü–µ—Ä–µ–¥–Ω–µ–µ –æ–∫–Ω–æ
            const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow.position.set(1.2, 1.8, 2.05); 
            frontWindow.castShadow = true;
            house.add(frontWindow);
            // –†–∞–º—ã –¥–ª—è –ø–µ—Ä–µ–¥–Ω–µ–≥–æ –æ–∫–Ω–∞
            const frontWindowFrameH1 = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 0.1), windowFrameMaterial);
            frontWindowFrameH1.position.set(1.2, 1.8 + 0.4, 2.05);
            house.add(frontWindowFrameH1);
            const frontWindowFrameH2 = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 0.1), windowFrameMaterial);
            frontWindowFrameH2.position.set(1.2, 1.8 - 0.4, 2.05);
            house.add(frontWindowFrameH2);
            const frontWindowFrameV1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.1), windowFrameMaterial);
            frontWindowFrameV1.position.set(1.2 + 0.4, 1.8, 2.05);
            house.add(frontWindowFrameV1);
            const frontWindowFrameV2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.1), windowFrameMaterial);
            frontWindowFrameV2.position.set(1.2 - 0.4, 1.8, 2.05);
            house.add(frontWindowFrameV2);

            // –¢–æ—á–µ—á–Ω—ã–π —Å–≤–µ—Ç –¥–ª—è –ø–µ—Ä–µ–¥–Ω–µ–≥–æ –æ–∫–Ω–∞
            windowLights = []; 
            const frontWindowLight = new THREE.PointLight(0xFFE0B2, daySettings.windowLightIntensity, 5); 
            frontWindowLight.position.set(1.2, 1.8, 1.95); 
            frontWindowLight.castShadow = true;
            house.add(frontWindowLight);
            windowLights.push(frontWindowLight); 

            // –ë–æ–∫–æ–≤–æ–µ –æ–∫–Ω–æ
            const sideWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            sideWindow.position.set(2.05, 1.8, 0); 
            sideWindow.rotation.y = Math.PI / 2; 
            sideWindow.castShadow = true;
            house.add(sideWindow);
            // –†–∞–º—ã –¥–ª—è –±–æ–∫–æ–≤–æ–≥–æ –æ–∫–Ω–∞
            const sideWindowFrameH1 = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 0.1), windowFrameMaterial);
            sideWindowFrameH1.position.set(2.05, 1.8 + 0.4, 0);
            sideWindowFrameH1.rotation.y = Math.PI / 2;
            house.add(sideWindowFrameH1);
            const sideWindowFrameH2 = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 0.1), windowFrameMaterial);
            sideWindowFrameH2.position.set(2.05, 1.8 - 0.4, 0);
            sideWindowFrameH2.rotation.y = Math.PI / 2;
            house.add(sideWindowFrameH2);
            const sideWindowFrameV1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.1), windowFrameMaterial);
            sideWindowFrameV1.position.set(2.05, 1.8, 0 + 0.4);
            sideWindowFrameV1.rotation.y = Math.PI / 2;
            house.add(sideWindowFrameV1);
            const sideWindowFrameV2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.1), windowFrameMaterial);
            sideWindowFrameV2.position.set(2.05, 1.8, 0 - 0.4);
            sideWindowFrameV2.rotation.y = Math.PI / 2;
            house.add(sideWindowFrameV2);

            // –¢–æ—á–µ—á–Ω—ã–π —Å–≤–µ—Ç –¥–ª—è –±–æ–∫–æ–≤–æ–≥–æ –æ–∫–Ω–∞
            const sideWindowLight = new THREE.PointLight(0xFFE0B2, daySettings.windowLightIntensity, 5); 
            sideWindowLight.position.set(1.95, 1.8, 0); 
            sideWindowLight.castShadow = true;
            house.add(sideWindowLight);
            windowLights.push(sideWindowLight); 

            // –î—ã–º–æ—Ö–æ–¥
            const chimneyGeometry = new THREE.BoxGeometry(0.6, 1.5, 0.6);
            const chimneyMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.7, metalness: 0.0 });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(-1.2, 4.5, -1.2); 
            chimney.castShadow = true;
            house.add(chimney);

            // –°—Ç—É–ø–µ–Ω–∏
            // –î–æ–±–∞–≤–ª–µ–Ω—ã polygonOffset –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            const stepsMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, polygonOffset: true, polygonOffsetFactor: -3, polygonOffsetUnits: 1 });
            const step1 = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.4), stepsMaterial);
            step1.position.set(0, 0.05, 2.2);
            step1.castShadow = true;
            step1.receiveShadow = true;
            house.add(step1);
            const step2 = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.1, 0.4), stepsMaterial);
            step2.position.set(0, -0.05, 2.5);
            step2.castShadow = true;
            step2.receiveShadow = true;
            house.add(step2);

            // –î–µ—Ä–µ–≤—è–Ω–Ω—ã–π –Ω–∞—Å—Ç–∏–ª –≤–æ–∫—Ä—É–≥ –¥–æ–º–∞
            const deckGeometry = new THREE.BoxGeometry(5, 0.1, 5); // –ë–æ–ª—å—à–µ, —á–µ–º –¥–æ–º
            // –î–æ–±–∞–≤–ª–µ–Ω—ã polygonOffset –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            const deckMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0xA0522D, // Keep the base color for tinting
                roughness: 0.6,
                metalness: 0.0,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: 1
            });
            const deck = new THREE.Mesh(deckGeometry, deckMaterial);
            deck.position.y = 0.01; // –ß—É—Ç—å –≤—ã—à–µ —É—Ä–æ–≤–Ω—è –∑–µ–º–ª–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            deck.castShadow = true;
            deck.receiveShadow = true;
            house.add(deck);


            scene.add(house);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∏–≥—Ä–æ–∫–∞.
         */
        function createPlayer() {
            player = new THREE.Group();

            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 16); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1, roughness: 0.5 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6; 
            body.castShadow = true;
            player.add(body);

            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3, roughness: 0.6 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.45; 
            head.castShadow = true;
            player.add(head);

            // –ì–ª–∞–∑–∞
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.5, 0.2); 
            player.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.5, 0.2); 
            player.add(rightEye);

            // –†—É–∫–∏
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBB3, roughness: 0.6 });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.45, 0.8, 0); 
            leftArm.castShadow = true;
            player.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.45, 0.8, 0); 
            rightArm.castShadow = true;
            player.add(rightArm);

            // –ù–æ–≥–∏
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.7 });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, -0.4, 0); 
            leftLeg.castShadow = true;
            player.add(leftLeg);
            player.userData.leftLeg = leftLeg; 

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, -0.4, 0); 
            rightLeg.castShadow = true;
            player.add(rightLeg);
            player.userData.rightLeg = rightLeg; 

            // –¢–æ—á–∫–∞ –∫—Ä–µ–ø–ª–µ–Ω–∏—è –¥–ª—è –±—Ä–µ–≤–Ω–∞/–∫–∞–º–Ω—è –≤ —Ä—É–∫–µ –∏–≥—Ä–æ–∫–∞
            player.userData.hand = new THREE.Group();
            player.userData.hand.position.set(0.4, 1.0, 0.3); // –ü—Ä–∏–º–µ—Ä–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ä—É–∫–µ
            player.add(player.userData.hand);

            player.position.copy(playerPosition); 
            scene.add(player);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–ª–æ—Å–∫–æ—Å—Ç—å –∑–µ–º–ª–∏.
         */
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize); 
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: grassTexture,
                normalMap: grassNormalMap,
                roughness: 0.9,
                metalness: 0.0
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–µ–Ω–µ–∫, –∫–æ—Ç–æ—Ä—ã–π –ø–æ—è–≤–ª—è–µ—Ç—Å—è –ø–æ—Å–ª–µ —Å–±–æ—Ä–∞ –≤—Å–µ—Ö –±—Ä–µ–≤–µ–Ω —Å –¥–µ—Ä–µ–≤–∞.
         * @returns {THREE.Mesh} –ú–µ—à –ø–µ–Ω—å–∫–∞.
         */
        function createStump() {
            const stumpGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.5, 8); // –®–∏—Ä–µ –∏ –∫–æ—Ä–æ—á–µ —Å—Ç–≤–æ–ª–∞
            const stumpMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x5C4033, // Keep the base color for tinting
                roughness: 0.8
            }); // –¢–µ–º–Ω–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π
            const stump = new THREE.Mesh(stumpGeometry, stumpMaterial);
            stump.position.y = 0.25; // –ü–æ–ª–æ–≤–∏–Ω–∞ –≤—ã—Å–æ—Ç—ã –ø–µ–Ω—å–∫–∞
            stump.castShadow = true;
            stump.receiveShadow = true;
            return stump;
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ç–∏–ø—ã –¥–µ—Ä–µ–≤—å–µ–≤ (–ª–∏—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏ –µ–ª–∏) –∏ —Ä–∞–∑–º–µ—â–∞–µ—Ç –∏—Ö, –∏–∑–±–µ–≥–∞—è –¥–æ–º–∞ –∏ –æ–∑–µ—Ä–∞.
         */
        function createTrees() {
            const numDeciduousTrees = 60; 
            const numFirTrees = 80;      

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –¥–æ–º–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const houseMinX = -2;
            const houseMaxX = 2;
            const houseMinZ = -2;
            const houseMaxZ = 2;

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –∫—Ä—É–≥ –æ–∑–µ—Ä–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π (–º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –∏ —Ä–∞–¥–∏—É—Å)
            const currentLakeRadius = lakeRadius; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
            const lakeBuffer = 6; 

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ —Å–∞—Ä–∞–π—á–∏–∫–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const barnMinX = -40 - 2; 
            const barnMaxX = -40 + 2;
            const barnMinZ = 40 - 2;
            const barnMaxZ = 40 + 2;
            const barnBuffer = 3; 

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const quarryMinX = 40 - 2;
            const quarryMaxX = 40 + 2;
            const quarryMinZ = -40 - 2;
            const quarryMaxZ = -40 + 2;
            const quarryBuffer = 3;


            // –õ–∏—Å—Ç–≤–µ–Ω–Ω—ã–µ –¥–µ—Ä–µ–≤—å—è
            const deciduousTrunkMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x8B4513, // Keep the base color for tinting
                roughness: 0.8
            });
            const deciduousFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });
            const appleMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.5 }); // –ö—Ä–∞—Å–Ω—ã–µ —è–±–ª–æ–∫–∏

            for (let i = 0; i < numDeciduousTrees; i++) {
                const tree = new THREE.Group();
                let treeX, treeZ;
                let isValidPosition = false;

                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏, –ø–æ–∫–∞ –æ–Ω–∞ –Ω–µ –æ–∫–∞–∂–µ—Ç—Å—è –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–æ–º–∞, –æ–∑–µ—Ä–∞, —Å–∞—Ä–∞–π—á–∏–∫–∞ –∏ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
                while (!isValidPosition) {
                    treeX = -forestRange + Math.random() * (forestRange * 2); 
                    treeZ = -forestRange + Math.random() * (forestRange * 2); 

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –¥–æ–º—É
                    const isNearHouse = (treeX >= houseMinX - 3 && treeX <= houseMaxX + 3 && 
                                         treeZ >= houseMinZ - 3 && treeZ <= houseMaxZ + 3);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –æ–∑–µ—Ä—É
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(treeX - lakeCenterX, 2) + 
                        Math.pow(treeZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (currentLakeRadius + lakeBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ —Å–∞—Ä–∞–π—á–∏–∫—É
                    const isNearBarn = (treeX >= barnMinX - barnBuffer && treeX <= barnMaxX + barnBuffer &&
                                         treeZ >= barnMinZ - barnBuffer && treeZ <= barnMaxZ + barnBuffer);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–µ
                    const isNearQuarry = (treeX >= quarryMinX - quarryBuffer && treeX <= quarryMaxX + quarryBuffer &&
                                          treeZ >= quarryMinZ - quarryBuffer && treeZ <= quarryMaxZ + quarryBuffer);

                    if (!isNearHouse && !isNearLake && !isNearBarn && !isNearQuarry) {
                        isValidPosition = true;
                    }
                }
                
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                const trunk = new THREE.Mesh(trunkGeometry, deciduousTrunkMaterial); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª —Å—Ç–≤–æ–ª–∞
                trunk.position.y = 1;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                tree.add(trunk);

                // –õ–∏—Å—Ç–≤–∞ –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Ñ–µ—Ä
                const numFoliageSpheres = 3 + Math.floor(Math.random() * 3); // 3-5 —Å—Ñ–µ—Ä
                for (let j = 0; j < numFoliageSpheres; j++) {
                    const foliageGeometry = new THREE.SphereGeometry(0.8 + Math.random() * 0.4, 16, 16); // –í–∞—Ä—å–∏—Ä—É—é—â–∏–µ—Å—è —Ä–∞–∑–º–µ—Ä—ã
                    const foliage = new THREE.Mesh(foliageGeometry, deciduousFoliageMaterial); 
                    foliage.position.set(
                        (Math.random() - 0.5) * 1.5, // –ù–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑–±—Ä–æ—Å –ø–æ X
                        2.5 + (Math.random() - 0.5) * 0.5, // –ù–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑–±—Ä–æ—Å –ø–æ Y
                        (Math.random() - 0.5) * 1.5  // –ù–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑–±—Ä–æ—Å –ø–æ Z
                    );
                    foliage.castShadow = true;
                    tree.add(foliage);
                }

                // –î–æ–±–∞–≤–ª—è–µ–º —è–±–ª–æ–∫–∏ –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –¥–µ—Ä–µ–≤—å—è
                if (Math.random() < 0.8) { // –£–≤–µ–ª–∏—á–µ–Ω —à–∞–Ω—Å –Ω–∞ —è–±–ª–æ–∫–∏ (80%)
                    const numApples = 8 + Math.floor(Math.random() * 7); // 8-14 —è–±–ª–æ–∫
                    for (let k = 0; k < numApples; k++) {
                        const appleGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                        const apple = new THREE.Mesh(appleGeometry, appleMaterial);
                        apple.position.set(
                            (Math.random() - 0.5) * 1.2,
                            2.0 + Math.random() * 1.5,
                            (Math.random() - 0.5) * 1.2
                        );
                        apple.castShadow = true;
                        tree.add(apple);
                    }
                }

                tree.position.x = treeX; 
                tree.position.z = treeZ; 
                tree.scale.setScalar(0.7 + Math.random() * 0.6); 
                tree.userData.isCollectible = true; // –ü–æ–º–µ—á–∞–µ–º, —á—Ç–æ —ç—Ç–æ –¥–µ—Ä–µ–≤–æ, —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –º–æ–∂–Ω–æ –≤–∑—è—Ç—å –±—Ä–µ–≤–Ω–æ
                tree.userData.type = 'log'; // –¢–∏–ø —Ä–µ—Å—É—Ä—Å–∞
                tree.userData.logsRemaining = 10; // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –∏–º–µ–µ—Ç 10 –±—Ä–µ–≤–µ–Ω
                tree.userData.originalFoliage = tree.children.filter(c => c.isMesh && c.geometry.type === 'SphereGeometry'); // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ –ª–∏—Å—Ç–≤—É
                collectibleTrees.push(tree); // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤ —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤
                scene.add(tree);
            }

            // –ï–ª–∏ (—Ö–≤–æ–π–Ω—ã–µ)
            const firTrunkMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x5C4033, // Keep the base color for tinting
                roughness: 0.8
            }); 
            const firFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 0.7 }); 

            for (let i = 0; i < numFirTrees; i++) {
                const firTree = new THREE.Group();
                let treeX, treeZ;
                let isValidPosition = false;

                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏, –ø–æ–∫–∞ –æ–Ω–∞ –Ω–µ –æ–∫–∞–∂–µ—Ç—Å—è –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–æ–º–∞, –æ–∑–µ—Ä–∞, —Å–∞—Ä–∞–π—á–∏–∫–∞ –∏ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
                while (!isValidPosition) {
                    treeX = -forestRange + Math.random() * (forestRange * 2); 
                    treeZ = -forestRange + Math.random() * (forestRange * 2); 

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –¥–æ–º—É
                    const isNearHouse = (treeX >= houseMinX - 3 && treeX <= houseMaxX + 3 && 
                                         treeZ >= houseMinZ - 3 && treeZ <= houseMaxZ + 3);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –æ–∑–µ—Ä—É
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(treeX - lakeCenterX, 2) + 
                        Math.pow(treeZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (currentLakeRadius + lakeBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ —Å–∞—Ä–∞–π—á–∏–∫—É
                    const isNearBarn = (treeX >= barnMinX - barnBuffer && treeX <= barnMaxX + barnBuffer &&
                                         treeZ >= barnMinZ - barnBuffer && treeZ <= barnMaxZ + barnBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–µ—Ä–µ–≤–æ –±–ª–∏–∑–∫–æ –∫ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–µ
                    const isNearQuarry = (treeX >= quarryMinX - quarryBuffer && treeX <= quarryMaxX + quarryBuffer &&
                                          treeZ >= quarryMinZ - quarryBuffer && treeZ <= quarryMaxZ + quarryBuffer);


                    if (!isNearHouse && !isNearLake && !isNearBarn && !isNearQuarry) {
                        isValidPosition = true;
                    }
                }

                const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.25, 2.5, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                const trunk = new THREE.Mesh(trunkGeometry, firTrunkMaterial);
                trunk.position.y = 1.25;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                firTree.add(trunk);

                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–¥–Ω—É –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –¥–ª—è –º–µ—à–µ–π –ª–∏—Å—Ç–≤—ã –≤–Ω—É—Ç—Ä–∏ —Ü–∏–∫–ª–∞
                let foliageGeometry;
                let foliageMesh;

                foliageGeometry = new THREE.ConeGeometry(1.5, 2, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial);
                foliageMesh.position.y = 2.5;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                foliageGeometry = new THREE.ConeGeometry(1.0, 1.5, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial);
                foliageMesh.position.y = 3.5;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                foliageGeometry = new THREE.ConeGeometry(0.6, 1.0, 8); 
                foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial); 
                foliageMesh.position.y = 4.2;
                foliageMesh.castShadow = true;
                firTree.add(foliageMesh);

                firTree.position.x = treeX; 
                firTree.position.z = treeZ; 
                firTree.scale.setScalar(0.8 + Math.random() * 0.7); 
                firTree.userData.isCollectible = true; // –ü–æ–º–µ—á–∞–µ–º, —á—Ç–æ —ç—Ç–æ –¥–µ—Ä–µ–≤–æ, —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –º–æ–∂–Ω–æ –≤–∑—è—Ç—å –±—Ä–µ–≤–Ω–æ
                firTree.userData.type = 'log'; // –¢–∏–ø —Ä–µ—Å—É—Ä—Å–∞
                firTree.userData.logsRemaining = 10; // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –∏–º–µ–µ—Ç 10 –±—Ä–µ–≤–µ–Ω
                firTree.userData.originalFoliage = firTree.children.filter(c => c.isMesh && c.geometry.type.includes('ConeGeometry')); // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ –ª–∏—Å—Ç–≤—É
                collectibleTrees.push(firTree); // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤ —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤
                scene.add(firTree);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –æ–∑–µ—Ä–æ —Å —Ä—ã–±–æ–π.
         */
        function createLake() {
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–æ—á–∫–∏ –¥–ª—è –Ω–µ—Ä–µ–≥—É–ª—è—Ä–Ω–æ–π —Ñ–æ—Ä–º—ã –æ–∑–µ—Ä–∞
            const shapePoints = [
                new THREE.Vector2(0, 15),
                new THREE.Vector2(8, 12),
                new THREE.Vector2(13, 5),
                new THREE.Vector2(15, -5),
                new THREE.Vector2(10, -12),
                new THREE.Vector2(0, -15),
                new THREE.Vector2(-10, -12),
                new THREE.Vector2(-15, -5),
                new THREE.Vector2(-13, 5),
                new THREE.Vector2(-8, 12)
            ];
            // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º —Ç–æ—á–∫–∏, —á—Ç–æ–±—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å lakeRadius
            const scaleFactor = lakeRadius / 15; // 15 - —ç—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–¥–∏—É—Å –∏—Å—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º—ã
            const scaledShapePoints = shapePoints.map(p => new THREE.Vector2(p.x * scaleFactor, p.y * scaleFactor)); 

            const lakeShape = new THREE.Shape(scaledShapePoints);
            const lakeGeometry = new THREE.ShapeGeometry(lakeShape); 
            
            // –ú–∞—Ç–µ—Ä–∏–∞–ª –≤–æ–¥—ã —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é –∏ –æ—Ç—Ä–∞–∂–∞—Ç–µ–ª—å–Ω–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å—é
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x0066FF, 
                transparent: true,
                opacity: 0.7,
                roughness: 0.1, // –ù–∏–∑–∫–∞—è —à–µ—Ä–æ—Ö–æ–≤–∞—Ç–æ—Å—Ç—å –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –æ—Ç—Ä–∞–∂–µ–Ω–∏—è
                metalness: 0.8, // –í—ã—Å–æ–∫–∞—è –º–µ—Ç–∞–ª–ª–∏—á–Ω–æ—Å—Ç—å –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –æ—Ç—Ä–∞–∂–µ–Ω–∏—è
                side: THREE.DoubleSide 
            });
            const lake = new THREE.Mesh(lakeGeometry, waterMaterial);
            lake.rotation.x = -Math.PI / 2; 
            lake.position.set(lakeCenterX, 0.01, lakeCenterZ); 
            lake.receiveShadow = true; // –û–∑–µ—Ä–æ –º–æ–∂–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ç–µ–Ω–∏
            scene.add(lake);

            // –†—ã–±–∞
            const numFish = 10;
            const fishGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.2); 
            const fishMaterial = new THREE.MeshStandardMaterial({ color: 0xFF8C00 }); 

            const fishBoundaryRadius = lakeRadius * 0.8; // –ì—Ä–∞–Ω–∏—Ü–∞ —Ä—ã–±—ã –≤–Ω—É—Ç—Ä–∏ –æ–∑–µ—Ä–∞

            for (let i = 0; i < numFish; i++) {
                const f = new THREE.Mesh(fishGeometry, fishMaterial);
                f.position.set(
                    lakeCenterX + (Math.random() - 0.5) * fishBoundaryRadius * 1.8, 
                    lakeCenterZ - (0.1 + Math.random() * 0.3), 
                    lakeCenterZ + (Math.random() - 0.5) * fishBoundaryRadius * 1.8
                );
                f.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.025, 
                    0,
                    (Math.random() - 0.5) * 0.025 
                );
                f.userData.swimCycle = Math.random() * Math.PI * 2; 
                scene.add(f);
                fish.push(f);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —Ä–∞—Å—Ç–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤–æ–∫—Ä—É–≥ –æ–∑–µ—Ä–∞ (–∫—É—Å—Ç—ã –∏ –∫–∞–º—ã—à–∏).
         */
        function createLakeVegetation() {
            const numBushes = 60; 
            const numReeds = 100; 

            const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x558B2F, roughness: 0.8 });
            for (let i = 0; i < numBushes; i++) {
                const bush = new THREE.Mesh(new THREE.SphereGeometry(0.3 + Math.random() * 0.3, 12, 12), bushMaterial); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                
                const angle = Math.random() * Math.PI * 2;
                const distance = lakeRadius + 4 + Math.random() * 10; 
                bush.position.set(
                    lakeCenterX + Math.cos(angle) * distance,
                    0.15, 
                    lakeCenterZ + Math.sin(angle) * distance
                );
                bush.scale.y = 0.7 + Math.random() * 0.6; 
                bush.castShadow = true;
                bush.receiveShadow = true;
                scene.add(bush);
            }

            const reedStemMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
            const reedHeadMaterial = new THREE.MeshStandardMaterial({ color: 0x6B8E23, roughness: 0.7 });
            for (let i = 0; i < numReeds; i++) {
                const reed = new THREE.Group();
                const height = 0.8 + Math.random() * 0.7;

                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, height, 8), reedStemMaterial); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                stem.position.y = height / 2;
                stem.castShadow = true;
                stem.receiveShadow = true;
                reed.add(stem);

                const head = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.08), reedHeadMaterial);
                head.position.y = height + 0.1;
                head.rotation.y = Math.random() * Math.PI;
                head.castShadow = true;
                reed.add(head);
                
                const angle = Math.random() * Math.PI * 2;
                // –†–∞–∑–º–µ—â–∞–µ–º –∫–∞–º—ã—à–∏ –ø–æ –∫—Ä–∞—é –æ–∑–µ—Ä–∞
                const distance = lakeRadius + lakeReedsOffset + (Math.random() * 0.5); // –ö–∞–º—ã—à–∏ –ø–æ –∫—Ä–∞—é –æ–∑–µ—Ä–∞
                reed.position.set(
                    lakeCenterX + Math.cos(angle) * distance,
                    0, 
                    lakeCenterZ + Math.sin(angle) * distance
                );
                reed.rotation.y = Math.random() * Math.PI * 2; 
                reed.rotation.z = (Math.random() - 0.5) * 0.2; 
                scene.add(reed);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–∏—Ä—Å –∏ –ª–æ–¥–∫—É –Ω–∞ –æ–∑–µ—Ä–µ.
         */
        function createPierAndBoat() {
            // –¶–µ–Ω—Ç—Ä –æ–∑–µ—Ä–∞ —É–∂–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –∫–∞–∫ lakeCenterX, lakeCenterZ
            const pierMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x8B4513, // Keep the base color for tinting
                roughness: 0.6
            }); 
            
            // –û—Å–Ω–æ–≤–Ω–∞—è —á–∞—Å—Ç—å –ø–∏—Ä—Å–∞
            const pierBaseGeometry = new THREE.BoxGeometry(1.5, 0.2, 5); 
            const pierBase = new THREE.Mesh(pierBaseGeometry, pierMaterial);
            pierBase.position.set(lakeCenterX + 20, 0.01 + pierBaseGeometry.parameters.height / 2, lakeCenterZ + 10); 
            pierBase.castShadow = true;
            pierBase.receiveShadow = true;
            scene.add(pierBase);

            // –û–ø–æ—Ä—ã –ø–∏—Ä—Å–∞
            const pierLegGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
            for (let i = 0; i < 3; i++) {
                const leg1 = new THREE.Mesh(pierLegGeometry, pierMaterial);
                leg1.position.set(pierBase.position.x - 0.5, -0.4, pierBase.position.z - 1.5 + i * 1.5);
                leg1.castShadow = true;
                leg1.receiveShadow = true;
                scene.add(leg1);

                const leg2 = new THREE.Mesh(pierLegGeometry, pierMaterial);
                leg2.position.set(pierBase.position.x + 0.5, -0.4, pierBase.position.z - 1.5 + i * 1.5);
                leg2.castShadow = true;
                leg2.receiveShadow = true;
                scene.add(leg2);
            }

            // –°–æ–∑–¥–∞–µ–º –ª–æ–¥–∫—É
            const boat = new THREE.Group();
            const boatMaterial = new THREE.MeshStandardMaterial({ color: 0x6A5ACD, roughness: 0.4, metalness: 0.1 }); 
            const boatInsideMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x8B4513, // Keep the base color for tinting
                roughness: 0.6
            }); 

            // –ö–æ—Ä–ø—É—Å –ª–æ–¥–∫–∏ (–æ—Å–Ω–æ–≤–Ω–∞—è —á–∞—Å—Ç—å)
            const boatHullGeometry = new THREE.BoxGeometry(0.8, 0.3, 2.5);
            const boatHull = new THREE.Mesh(boatHullGeometry, boatMaterial);
            boatHull.position.y = 0; 
            boat.add(boatHull);

            // –ù–æ—Å –ª–æ–¥–∫–∏ (–∫–æ–Ω—É—Å –∏–ª–∏ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–∞—è —Ñ–æ—Ä–º–∞)
            const boatFrontGeometry = new THREE.ConeGeometry(0.4, 0.5, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const boatFront = new THREE.Mesh(boatFrontGeometry, boatMaterial);
            boatFront.rotation.x = Math.PI / 2; 
            boatFront.position.set(0, 0, 1.25); 
            boat.add(boatFront);

            // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —á–∞—Å—Ç—å (—Å–∏–¥–µ–Ω—å–µ)
            const seatGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.5);
            const seat = new THREE.Mesh(seatGeometry, boatInsideMaterial);
            seat.position.set(0, 0.1, 0); 
            boat.add(seat);

            // –†–∞–∑–º–µ—â–∞–µ–º –ª–æ–¥–∫—É –Ω–∞ —É—Ä–æ–≤–Ω–µ –æ–∑–µ—Ä–∞
            boat.position.set(pierBase.position.x + 2, 0.01 + boatHullGeometry.parameters.height / 2, pierBase.position.z + 1.5); 
            boat.rotation.y = -Math.PI / 4; 
            boat.castShadow = true;
            boat.receiveShadow = true;
            scene.add(boat);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –∫—Ä—É–≥–æ–≤–æ–π –∑–∞–±–æ—Ä –≤–æ–∫—Ä—É–≥ –¥–æ–º–∞.
         */
        function createFence() {
            const fenceRadius = 6; 
            const fenceHeight = 0.8;
            const postRadius = 0.08;
            const numPosts = 32; // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç–æ–ª–±–æ–≤ –¥–ª—è –±–æ–ª–µ–µ –≥–ª–∞–¥–∫–æ–≥–æ –∫—Ä—É–≥–∞

            const fenceMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x8B4513, // Keep the base color for tinting
                roughness: 0.7
            }); 

            const posts = [];
            for (let i = 0; i < numPosts; i++) {
                const angle = (i / numPosts) * Math.PI * 2;
                const x = Math.cos(angle) * fenceRadius;
                const z = Math.sin(angle) * fenceRadius;
                posts.push(new THREE.Vector3(x, fenceHeight / 2, z));
            }

            // –°–æ–∑–¥–∞–µ–º —Å—Ç–æ–ª–±—ã –∑–∞–±–æ—Ä–∞
            const fencePostGeometry = new THREE.CylinderGeometry(postRadius, postRadius, fenceHeight, 8);
            posts.forEach(pos => {
                const post = new THREE.Mesh(fencePostGeometry, fenceMaterial);
                post.position.copy(pos);
                post.castShadow = true;
                post.receiveShadow = true;
                scene.add(post);
            });
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –∫—Ä–æ–ª–∏–∫–æ–≤ —Å –ø–ª–∞–≤–Ω—ã–º –¥–≤–∏–∂–µ–Ω–∏–µ–º –≤–ø–µ—Ä–µ–¥/–Ω–∞–∑–∞–¥ –∏ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ–º.
         */
        function createRabbits() {
            const numRabbits = 3; 
            const rabbitMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5DC, roughness: 0.7 }); 
            const rabbitScale = 0.6; // –£–≤–µ–ª–∏—á–µ–Ω –º–∞—Å—à—Ç–∞–± –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∏/–∫—Ä—É–≥–∏ –¥–æ–º–∞ –∏ –æ–∑–µ—Ä–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const houseMinX = -2;
            const houseMaxX = 2;
            const houseMinZ = -2;
            const houseMaxZ = 2;

            const currentLakeRadius = lakeRadius; 
            const exclusionBuffer = 4; 

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ —Å–∞—Ä–∞–π—á–∏–∫–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const barnMinX = -40 - 2; 
            const barnMaxX = -40 + 2;
            const barnMinZ = 40 - 2;
            const barnMaxZ = 40 + 2;
            const barnBuffer = 3; 

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            const quarryMinX = 40 - 2;
            const quarryMaxX = 40 + 2;
            const quarryMinZ = -40 - 2;
            const quarryMaxZ = -40 + 2;
            const quarryBuffer = 3;

            // –°–≤–æ–π—Å—Ç–≤–∞ –¥–≤–∏–∂–µ–Ω–∏—è –¥–ª—è –∫—Ä–æ–ª–∏–∫–æ–≤ (–ø–ª–∞–≤–Ω–∞—è –æ—Å—Ü–∏–ª–ª—è—Ü–∏—è)
            const rabbitOscillationSpeed = 0.001; // –ë–æ–ª–µ–µ –Ω–∏–∑–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è –æ—Å—Ü–∏–ª–ª—è—Ü–∏–∏
            const rabbitOscillationAmplitude = 5; // –£–≤–µ–ª–∏—á–µ–Ω–∞ –∞–º–ø–ª–∏—Ç—É–¥–∞ –¥–ª—è –±–æ–ª–µ–µ –∑–∞–º–µ—Ç–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è

            for (let i = 0; i < numRabbits; i++) {
                const rabbit = new THREE.Group();
                let rabbitX, rabbitZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    rabbitX = -forestRange + Math.random() * (forestRange * 2); 
                    rabbitZ = -forestRange + Math.random() * (forestRange * 2); 

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –∫—Ä–æ–ª–∏–∫ –±–ª–∏–∑–∫–æ –∫ –¥–æ–º—É
                    const isNearHouse = (rabbitX >= houseMinX - exclusionBuffer && rabbitX <= houseMaxX + exclusionBuffer && 
                                         rabbitZ >= houseMinZ - exclusionBuffer && rabbitZ <= houseMaxZ + exclusionBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –∫—Ä–æ–ª–∏–∫ –±–ª–∏–∑–∫–æ –∫ –æ–∑–µ—Ä—É
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(rabbitX - lakeCenterX, 2) + 
                        Math.pow(rabbitZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (currentLakeRadius + exclusionBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –∫—Ä–æ–ª–∏–∫ –±–ª–∏–∑–∫–æ –∫ —Å–∞—Ä–∞–π—á–∏–∫—É
                    const isNearBarn = (rabbitX >= barnMinX - barnBuffer && rabbitX <= barnMaxX + barnBuffer &&
                                         rabbitZ >= barnMinZ - barnBuffer && rabbitZ <= barnMaxZ + barnBuffer);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –∫—Ä–æ–ª–∏–∫ –±–ª–∏–∑–∫–æ –∫ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–µ
                    const isNearQuarry = (rabbitX >= quarryMinX - quarryBuffer && rabbitX <= quarryMaxX + quarryBuffer &&
                                          rabbitZ >= quarryMinZ - quarryBuffer && rabbitZ <= quarryMaxZ + quarryBuffer);


                    if (!isNearHouse && !isNearLake && !isNearBarn && !isNearQuarry) {
                        isValidPosition = true;
                    }
                }

                // –¢–µ–ª–æ
                const bodyGeometry = new THREE.SphereGeometry(0.8 * rabbitScale, 24, 12); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                const body = new THREE.Mesh(bodyGeometry, rabbitMaterial);
                body.position.y = 0.4 * rabbitScale; 
                body.scale.z = 1.5; 
                body.castShadow = true;
                body.receiveShadow = true;
                rabbit.add(body);

                // –ì–æ–ª–æ–≤–∞
                const headGeometry = new THREE.SphereGeometry(0.5 * rabbitScale, 24, 12); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                const head = new THREE.Mesh(headGeometry, rabbitMaterial);
                head.position.set(0.6 * rabbitScale, 0.8 * rabbitScale, 0); 
                head.castShadow = true;
                rabbit.add(head);

                // –£—à–∏
                const earGeometry = new THREE.BoxGeometry(0.2 * rabbitScale, 1.2 * rabbitScale, 0.2 * rabbitScale); 
                const leftEar = new THREE.Mesh(earGeometry, rabbitMaterial);
                leftEar.position.set(0.7 * rabbitScale, 1.6 * rabbitScale, 0.3 * rabbitScale); 
                leftEar.rotation.z = Math.PI / 10;
                leftEar.castShadow = true;
                rabbit.add(leftEar);

                const rightEar = new THREE.Mesh(earGeometry, rabbitMaterial);
                rightEar.position.set(0.7 * rabbitScale, 1.6 * rabbitScale, -0.3 * rabbitScale); 
                rightEar.rotation.z = -Math.PI / 10;
                rightEar.castShadow = true;
                rabbit.add(rightEar);

                // –•–≤–æ—Å—Ç
                const tailGeometry = new THREE.SphereGeometry(0.3 * rabbitScale, 16, 16); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
                const tailMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.7 }); 
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.position.set(-1.0 * rabbitScale, 0.4 * rabbitScale, 0); 
                tail.castShadow = true;
                rabbit.add(tail);

                rabbit.position.set(rabbitX, 0, rabbitZ); 
                rabbit.rotation.y = Math.random() * Math.PI * 2; // –°–ª—É—á–∞–π–Ω–æ–µ –Ω–∞—á–∞–ª—å–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
                rabbit.userData.initialRotationY = rabbit.rotation.y; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
                rabbit.userData.offset = Math.random() * Math.PI * 2; // –£–Ω–∏–∫–∞–ª—å–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è
                
                rabbit.userData.initialPosition = rabbit.position.clone(); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –æ—Å—Ü–∏–ª–ª—è—Ü–∏–∏
                rabbit.userData.oscillationSpeed = rabbitOscillationSpeed + (Math.random() - 0.5) * 0.0002; // –ù–µ–º–Ω–æ–≥–æ –≤–∞—Ä—å–∏—Ä—É—é—â–∞—è—Å—è —Å–∫–æ—Ä–æ—Å—Ç—å
                rabbit.userData.oscillationAmplitude = rabbitOscillationAmplitude + (Math.random() - 0.5) * 0.5; // –ù–µ–º–Ω–æ–≥–æ –≤–∞—Ä—å–∏—Ä—É—é—â–∞—è—Å—è –∞–º–ø–ª–∏—Ç—É–¥–∞
                rabbit.userData.oscillationOffset = Math.random() * Math.PI * 2; // –£–Ω–∏–∫–∞–ª—å–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –æ—Å—Ü–∏–ª–ª—è—Ü–∏–∏

                scene.add(rabbit);
                rabbits.push(rabbit);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —á–∞—Å—Ç–∏—Ü—ã –¥—ã–º–∞ –¥–ª—è –¥—ã–º–æ—Ö–æ–¥–∞.
         */
        function createSmokeParticles() {
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0xDDDDDD,
                transparent: true,
                opacity: 0.6
            });

            for (let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(-1.2, 5.2 + i * 0.3, -1.2);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.02
                    ),
                    life: Math.random()
                };
                particles.push(particle);
                scene.add(particle);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —Ä–∞–∑–±—Ä–æ—Å–∞–Ω–Ω—ã–µ –∫–∞–º–Ω–∏/–∫–∞–º–Ω–∏ –ø–æ –º–µ—Å—Ç–Ω–æ—Å—Ç–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ç–µ–ø–µ—Ä—å —Ç–∞–∫–∂–µ —Å–æ–±–∏—Ä–∞–µ–º—ã.
         */
        function createRocks() {
            const numRocks = 150; 
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9, metalness: 0.0 }); // –°–µ—Ä—ã–π —Ü–≤–µ—Ç –∫–∞–º–Ω—è

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–æ–Ω—ã –∏—Å–∫–ª—é—á–µ–Ω–∏—è (–¥–æ–º, –æ–∑–µ—Ä–æ, —Å–∞—Ä–∞–π—á–∏–∫, –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω—è)
            const houseMinX = -2; const houseMaxX = 2;
            const houseMinZ = -2; const houseMaxZ = 2;
            const currentLakeRadius = lakeRadius;
            const exclusionBuffer = 5; 

            const barnMinX = -40 - 2;
            const barnMaxX = -40 + 2;
            const barnMinZ = 40 - 2;
            const barnMaxZ = 40 + 2;
            const barnBuffer = 3;

            const quarryMinX = 40 - 2;
            const quarryMaxX = 40 + 2;
            const quarryMinZ = -40 - 2;
            const quarryMaxZ = -40 + 2;
            const quarryBuffer = 3;

            // –î–æ–±–∞–≤–ª—è–µ–º –∑–æ–Ω—ã –∏—Å–∫–ª—é—á–µ–Ω–∏—è –¥–ª—è –Ω–æ–≤–æ–≥–æ –ª–µ—Å–∞
            const forestMinX = 60; const forestMaxX = 90; 
            const forestMinZ = -90; const forestMaxZ = -60; 
            const forestBuffer = 5;

            for (let i = 0; i < numRocks; i++) {
                let rockX, rockZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    rockX = -forestRange + Math.random() * (forestRange * 2); 
                    rockZ = -forestRange + Math.random() * (forestRange * 2); 

                    const isNearHouse = (rockX >= houseMinX - exclusionBuffer && rockX <= houseMaxX + exclusionBuffer && 
                                         rockZ >= houseMinZ - exclusionBuffer && rockZ <= houseMaxZ + exclusionBuffer);
                    const distanceToLakeCenter = Math.sqrt(
                        Math.pow(rockX - lakeCenterX, 2) + 
                        Math.pow(rockZ - lakeCenterZ, 2)
                    );
                    const isNearLake = distanceToLakeCenter < (currentLakeRadius + exclusionBuffer);

                    const isNearBarn = (rockX >= barnMinX - barnBuffer && rockX <= barnMaxX + barnBuffer &&
                                         rockZ >= barnMinZ - barnBuffer && rockZ <= barnMaxZ + barnBuffer);

                    const isNearQuarry = (rockX >= quarryMinX - quarryBuffer && rockX <= quarryMaxX + quarryBuffer &&
                                          rockZ >= quarryMinZ - quarryBuffer && rockZ <= quarryMaxZ + quarryBuffer);
                    
                    const isNearForest = (rockX >= forestMinX - forestBuffer && rockX <= forestMaxX + forestBuffer &&
                                          rockZ >= forestMinZ - forestBuffer && rockZ <= forestMaxZ + forestBuffer);

                    if (!isNearHouse && !isNearLake && !isNearBarn && !isNearQuarry && !isNearForest) {
                        isValidPosition = true;
                    }
                }

                // –°–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä –º–µ–∂–¥—É —Å—Ñ–µ—Ä–∏—á–µ—Å–∫–æ–π –∏–ª–∏ –∫—É–±–∏—á–µ—Å–∫–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–µ–π –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
                let rockGeometry;
                if (Math.random() > 0.5) {
                    rockGeometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.3, 8, 8); // –ù–µ–º–Ω–æ–≥–æ –±–æ–ª—å—à–µ –¥–ª—è –∑–∞–º–µ—Ç–Ω–æ—Å—Ç–∏
                } else {
                    rockGeometry = new THREE.BoxGeometry(0.4 + Math.random() * 0.6, 0.2 + Math.random() * 0.4, 0.4 + Math.random() * 0.6);
                }
                
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(rockX, rockGeometry.parameters.height / 2 || rockGeometry.parameters.radius || 0.15, rockZ); // –ù–µ–º–Ω–æ–≥–æ –≤—ã—à–µ
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.castShadow = true;
                rock.receiveShadow = true;

                // –ü–æ–º–µ—á–∞–µ–º –∫–∞–º–µ–Ω—å –∫–∞–∫ —Å–æ–±–∏—Ä–∞–µ–º—ã–π
                rock.userData.isCollectible = true;
                rock.userData.type = 'stone';
                rock.userData.collectibleAmount = 1; // –û–¥–∏–Ω –∫–∞–º–µ–Ω—å –∑–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ
                collectibleStones.push(rock); // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤ —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –∫–∞–º–Ω–µ–π
                scene.add(rock);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –æ–±–ª–∞–∫–∞ –≤ –Ω–µ–±–µ.
         */
        let cloudMeshes = []; // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –º–µ—à–µ–π –æ–±–ª–∞–∫–æ–≤ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
        function createClouds() {
            const numClouds = 10; 
            const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8, roughness: 0.5 });

            for (let i = 0; i < numClouds; i++) {
                const cloud = new THREE.Group();
                const numParts = 3 + Math.floor(Math.random() * 3); // 3-5 —á–∞—Å—Ç–µ–π –Ω–∞ –æ–±–ª–∞–∫–æ

                for (let j = 0; j < numParts; j++) {
                    const partGeometry = new THREE.SphereGeometry(3 + Math.random() * 2, 16, 16); // –í–∞—Ä—å–∏—Ä—É—é—â–∏–µ—Å—è —Ä–∞–∑–º–µ—Ä—ã
                    const part = new THREE.Mesh(partGeometry, cloudMaterial);
                    part.position.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 5
                    );
                    part.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    cloud.add(part);
                }

                cloud.position.set(
                    -forestRange - 10 + Math.random() * (forestRange * 2 + 20), // –î–∏–∞–ø–∞–∑–æ–Ω –º–∏—Ä–∞
                    30 + Math.random() * 10,  // –í—ã—Å–æ–∫–æ –≤ –Ω–µ–±–µ
                    -forestRange - 10 + Math.random() * (forestRange * 2 + 20)
                );
                cloud.scale.setScalar(0.5 + Math.random()); // –í–∞—Ä—å–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—Ä –æ–±–ª–∞–∫–∞
                cloud.userData.speed = (Math.random() - 0.5) * 0.05; // –°–ª—É—á–∞–π–Ω–∞—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                scene.add(cloud);
                clouds.push(cloud);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–æ—á—Ç–æ–≤—ã–π —è—â–∏–∫ —Ä—è–¥–æ–º —Å –¥–æ–º–æ–º.
         */
        function createMailbox() {
            const mailbox = new THREE.Group();
            const postMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x8B4513, // Keep the base color for tinting
                roughness: 0.7
            }); // –ö–æ—Ä–∏—á–Ω–µ–≤—ã–π —Å—Ç–æ–ª–±
            const boxMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.6 }); // –ö—Ä–∞—Å–Ω—ã–π —è—â–∏–∫

            // –°—Ç–æ–ª–±
            const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.0, 8);
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 0.5;
            post.castShadow = true;
            post.receiveShadow = true;
            mailbox.add(post);

            // –Ø—â–∏–∫
            const boxGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.6);
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(0, 1.2, 0);
            box.castShadow = true;
            box.receiveShadow = true;
            mailbox.add(box);

            // –§–ª–∞–∂–æ–∫ (–º–∞–ª–µ–Ω—å–∫–∏–π —Ü–∏–ª–∏–Ω–¥—Ä)
            const flagGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4);
            const flagMaterial = new THREE.MeshStandardMaterial({ color: 0x0000FF, roughness: 0.5 }); // –°–∏–Ω–∏–π —Ñ–ª–∞–∂–æ–∫
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(0.2, 1.35, 0.2);
            flag.rotation.z = Math.PI / 2; // –î–µ–ª–∞–µ–º –µ–≥–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–º
            flag.castShadow = true;
            mailbox.add(flag);

            mailbox.position.set(-3, 0, 3); // –ü–æ–∑–∏—Ü–∏—è —Ä—è–¥–æ–º —Å –¥–æ–º–æ–º
            mailbox.rotation.y = Math.PI / 4; // –ù–µ–º–Ω–æ–≥–æ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º
            scene.add(mailbox);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø—Ä–æ—Å—Ç—É—é –≥—Ä—É–Ω—Ç–æ–≤—É—é –¥–æ—Ä–æ–∂–∫—É, –≤–µ–¥—É—â—É—é –∫ –¥–æ–º—É.
         */
        function createPath() {
            const pathMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 }); // –ö–æ—Ä–∏—á–Ω–µ–≤—ã–π —Ü–≤–µ—Ç –∑–µ–º–ª–∏
            const pathGeometry = new THREE.BoxGeometry(1.5, 0.01, 10); // –®–∏—Ä–∏–Ω–∞, –≤—ã—Å–æ—Ç–∞, –¥–ª–∏–Ω–∞
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.position.set(-1, 0.02, 0); // –ü–æ–∑–∏—Ü–∏—è –ø–µ—Ä–µ–¥ –¥–æ–º–æ–º, Y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –Ω–µ–º–Ω–æ–≥–æ —É–≤–µ–ª–∏—á–µ–Ω–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è Z-—Ñ–∞–π—Ç–∏–Ω–≥–∞
            path.receiveShadow = true;
            scene.add(path);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø—Ä–æ—Å—Ç—É—é –¥–µ—Ä–µ–≤—è–Ω–Ω—É—é —Å–∫–∞–º–µ–π–∫—É.
         */
        function createBench() {
            const bench = new THREE.Group();
            const woodMaterialBench = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x8B4513, // Keep the base color for tinting
                roughness: 0.7
            }); // –î–µ—Ä–µ–≤—è–Ω–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª

            // –°–∏–¥–µ–Ω—å–µ
            const seatGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.4);
            const seat = new THREE.Mesh(seatGeometry, woodMaterialBench);
            seat.position.y = 0.4;
            seat.castShadow = true;
            seat.receiveShadow = true;
            bench.add(seat);

            // –ù–æ–∂–∫–∏
            const legGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);
            const leg1 = new THREE.Mesh(legGeometry, woodMaterialBench);
            leg1.position.set(-0.6, 0.2, 0.15);
            leg1.castShadow = true;
            leg1.receiveShadow = true;
            bench.add(leg1);
            const leg2 = new THREE.Mesh(legGeometry, woodMaterialBench);
            leg2.position.set(0.6, 0.2, 0.15);
            leg2.castShadow = true;
            leg2.receiveShadow = true;
            bench.add(leg2);
            const leg3 = new THREE.Mesh(legGeometry, woodMaterialBench);
            leg3.position.set(-0.6, 0.2, -0.15);
            leg3.castShadow = true;
            leg3.receiveShadow = true;
            bench.add(leg3);
            const leg4 = new THREE.Mesh(legGeometry, woodMaterialBench);
            leg4.position.set(0.6, 0.2, -0.15);
            leg4.castShadow = true;
            leg4.receiveShadow = true;
            bench.add(leg4);

            bench.position.set(-2, 0, -3); // –ü–æ–∑–∏—Ü–∏—è —Ä—è–¥–æ–º —Å –¥–æ–º–æ–º
            bench.rotation.y = Math.PI / 8;
            scene.add(bench);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –∫—É–≤—à–∏–Ω–∫–∏ –Ω–∞ –æ–∑–µ—Ä–µ.
         */
        function createLilyPads() {
            const lilyPadMaterial = new THREE.MeshStandardMaterial({ color: 0x32CD32, roughness: 0.7 }); // –ó–µ–ª–µ–Ω—ã–π —Ü–≤–µ—Ç –∫—É–≤—à–∏–Ω–∫–∏
            const flowerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFB6C1, roughness: 0.5 }); // –†–æ–∑–æ–≤—ã–π —Ü–≤–µ—Ç —Ü–≤–µ—Ç–∫–∞

            const numLilyPads = 20; 

            for (let i = 0; i < numLilyPads; i++) {
                const lilyPad = new THREE.Group();
                const radius = 0.4 + Math.random() * 0.2;
                const padGeometry = new THREE.CircleGeometry(radius, 16); // –ö—Ä—É–≥–ª–∞—è –∫—É–≤—à–∏–Ω–∫–∞
                const pad = new THREE.Mesh(padGeometry, lilyPadMaterial);
                pad.rotation.x = -Math.PI / 2;
                pad.position.y = 0.02; // –ß—É—Ç—å –≤—ã—à–µ –≤–æ–¥—ã
                lilyPad.add(pad);

                // –î–æ–±–∞–≤–ª—è–µ–º –º–∞–ª–µ–Ω—å–∫–∏–π —Ü–≤–µ—Ç–æ–∫ –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∫—É–≤—à–∏–Ω–∫–∏
                if (Math.random() > 0.5) {
                    const flowerGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.05, 8);
                    const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.y = 0.04;
                    lilyPad.add(flower);
                }

                // –†–∞–∑–º–µ—â–∞–µ–º –∫—É–≤—à–∏–Ω–∫–∏ —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –≤–Ω—É—Ç—Ä–∏ –æ–∑–µ—Ä–∞
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * lakeRadius;
                lilyPad.position.set(
                    lakeCenterX + Math.cos(angle) * distance,
                    0, 
                    lakeCenterZ + Math.sin(angle) * distance
                );
                lilyPad.rotation.z = Math.random() * Math.PI * 2; // –°–ª—É—á–∞–π–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
                lilyPad.scale.setScalar(0.8 + Math.random() * 0.4); // –°–ª—É—á–∞–π–Ω—ã–π —Ä–∞–∑–º–µ—Ä
                scene.add(lilyPad);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø—Ä–æ—Å—Ç—É—é –ø—Ç–∏—Ü—É, –∫–æ—Ç–æ—Ä–∞—è –ª–µ—Ç–∞–µ—Ç –ø–æ –∫—Ä—É–≥—É.
         */
        function createBird() {
            bird = new THREE.Group();
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4B0082, roughness: 0.5 }); // –¢–µ–º–Ω–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π

            // –¢–µ–ª–æ –ø—Ç–∏—Ü—ã
            const bodyGeometry = new THREE.SphereGeometry(0.3, 12, 12);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.scale.z = 2; // –í—ã—Ç—è–Ω—É—Ç–æ–µ —Ç–µ–ª–æ
            body.castShadow = true;
            bird.add(body);

            // –ö—Ä—ã–ª—å—è
            const wingGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.8);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x6A5ACD, roughness: 0.5 }); // –°–≤–µ—Ç–ª–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.2, 0, 0);
            leftWing.rotation.y = Math.PI / 2;
            leftWing.rotation.x = Math.PI / 4; // –ù–∞—á–∞–ª—å–Ω—ã–π —É–≥–æ–ª –∫—Ä—ã–ª–∞
            leftWing.castShadow = true;
            bird.add(leftWing);
            bird.userData.leftWing = leftWing; // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏

            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.2, 0, 0);
            rightWing.rotation.y = -Math.PI / 2;
            rightWing.rotation.x = -Math.PI / 4; // –ù–∞—á–∞–ª—å–Ω—ã–π —É–≥–æ–ª –∫—Ä—ã–ª–∞
            rightWing.castShadow = true;
            bird.add(rightWing);
            bird.userData.rightWing = rightWing; // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏

            bird.position.set(0, 15, -20); // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –ø—Ç–∏—Ü—ã
            bird.userData.flightRadius = 50; 
            bird.userData.flightSpeed = 0.005; // –°–∫–æ—Ä–æ—Å—Ç—å –ø–æ–ª–µ—Ç–∞
            bird.userData.flightAngle = Math.random() * Math.PI * 2; // –ù–∞—á–∞–ª—å–Ω—ã–π —É–≥–æ–ª –ø–æ–ª–µ—Ç–∞
            bird.userData.wingFlapSpeed = 0.2; // –°–∫–æ—Ä–æ—Å—Ç—å –º–∞—Ö–∞ –∫—Ä—ã–ª—å—è–º–∏
            bird.userData.wingFlapAmplitude = 0.5; // –ê–º–ø–ª–∏—Ç—É–¥–∞ –º–∞—Ö–∞ –∫—Ä—ã–ª—å—è–º–∏

            scene.add(bird);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —Å–≤–µ—Ç–ª—è—á–∫–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ—è–≤–ª—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –Ω–æ—á—å—é.
         */
        function createFireflies() {
            const fireflyMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, transparent: true, opacity: 0.0 }); // –ñ–µ–ª—Ç—ã–π, –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –Ω–µ–≤–∏–¥–∏–º—ã–π
            const fireflyGeometry = new THREE.SphereGeometry(0.05, 8, 8);

            const numFireflies = 50; 
            for (let i = 0; i < numFireflies; i++) {
                const firefly = new THREE.Mesh(fireflyGeometry, fireflyMaterial.clone()); // –ö–ª–æ–Ω–∏—Ä—É–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–π –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
                firefly.position.set(
                    -forestRange + Math.random() * (forestRange * 2), 
                    1 + Math.random() * 5, 
                    -forestRange + Math.random() * (forestRange * 2)
                );
                firefly.userData.speed = 0.01 + Math.random() * 0.02; // –°–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è
                firefly.userData.offset = Math.random() * Math.PI * 2; // –°–º–µ—â–µ–Ω–∏–µ –¥–ª—è –º–µ—Ä—Ü–∞–Ω–∏—è
                firefly.userData.initialPosition = firefly.position.clone(); // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
                fireflies.push(firefly);
                scene.add(firefly);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —Å–∞—Ä–∞–π—á–∏–∫ (–ª–µ—Å–æ–ø–∏–ª–∫—É).
         */
        function createBarn() {
            const barn = new THREE.Group();
            // –°–≤–µ—Ç–ª–µ–µ, —á–µ–º –±—Ä–µ–≤–Ω–∞ (0x654321)
            const barnWoodMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0xD2B48C, // Keep the base color for tinting
                roughness: 0.7,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: 1
            }); // Tan
            const barnRoofMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.6 }); // Sienna

            // –°—Ç–µ–Ω—ã —Å–∞—Ä–∞–π—á–∏–∫–∞
            const barnBodyGeometry = new THREE.BoxGeometry(5, 3, 4);
            const barnBody = new THREE.Mesh(barnBodyGeometry, barnWoodMaterial);
            barnBody.position.y = 1.5;
            barnBody.castShadow = true;
            barnBody.receiveShadow = true;
            barn.add(barnBody);

            // –ö—Ä—ã—à–∞ —Å–∞—Ä–∞–π—á–∏–∫–∞ (–¥–≤—É—Å–∫–∞—Ç–Ω–∞—è)
            const barnRoofGeometry = new THREE.ConeGeometry(3.5, 2, 4, 8); 
            const barnRoof = new THREE.Mesh(barnRoofGeometry, barnRoofMaterial);
            barnRoof.position.y = 3 + 1; 
            barnRoof.rotation.y = Math.PI / 4; 
            barnRoof.scale.set(1.1, 1, 1.1); 
            barnRoof.castShadow = true;
            barn.add(barnRoof);

            // –î–≤–µ—Ä—å —Å–∞—Ä–∞–π—á–∏–∫–∞ (–ø—Ä–æ—Å—Ç–∞—è)
            const barnDoorGeometry = new THREE.BoxGeometry(1.0, 2.0, 0.1);
            const barnDoorMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.6 });
            const barnDoor = new THREE.Mesh(barnDoorGeometry, barnDoorMaterial);
            barnDoor.position.set(0, 1.0, 2.05); 
            barnDoor.castShadow = true;
            barn.add(barnDoor);

            // –†–∞–∑–º–µ—â–∞–µ–º —Å–∞—Ä–∞–π—á–∏–∫ –≤ –ª–µ—Å—É
            barn.position.set(-40, 0, 40); 
            scene.add(barn);

            // –¢–æ—á–µ—á–Ω—ã–π —Å–≤–µ—Ç –¥–ª—è –ª–µ—Å–æ–ø–∏–ª–∫–∏ (–ª–æ–∫–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã barn)
            const barnLight = new THREE.PointLight(0xFFE0B2, nightSettings.windowLightIntensity, 10); 
            barnLight.position.set(0, 2, 0); // –¶–µ–Ω—Ç—Ä –∑–¥–∞–Ω–∏—è
            barnLight.castShadow = true;
            barn.add(barnLight); // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—Ç –∫ –≥—Ä—É–ø–ø–µ —Å–∞—Ä–∞–π—á–∏–∫–∞
            barnLights.push(barnLight); // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å—é

            return barn; 
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–æ–ª–µ–Ω–Ω–∏—Ü—É —Ä—è–¥–æ–º —Å —Å–∞—Ä–∞–π—á–∏–∫–æ–º (–ª–µ—Å–æ–ø–∏–ª–∫–∏).
         * @param {THREE.Group} barn - –û–±—ä–µ–∫—Ç —Å–∞—Ä–∞–π—á–∏–∫–∞, —Ä—è–¥–æ–º —Å –∫–æ—Ç–æ—Ä—ã–º –±—É–¥–µ—Ç —Ä–∞–∑–º–µ—â–µ–Ω–∞ –ø–æ–ª–µ–Ω–Ω–∏—Ü–∞.
         */
        function createFirewoodPile(barn) {
            logDropOffPileGroup = new THREE.Group(); // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –≥—Ä—É–ø–ø—É –¥–ª—è –ø–æ–ª–µ–Ω–Ω–∏—Ü—ã
            
            // –†–∞–∑–º–µ—â–∞–µ–º –ø–æ–ª–µ–Ω–Ω–∏—Ü—É —Ä—è–¥–æ–º —Å —Å–∞—Ä–∞–π—á–∏–∫–æ–º
            logDropOffPileGroup.position.set(barn.position.x + 3.5, 0, barn.position.z + 0.5); // –°–º–µ—â–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Å–∞—Ä–∞–π—á–∏–∫–∞
            logDropOffPileGroup.rotation.y = Math.PI / 6; // –ù–µ–º–Ω–æ–≥–æ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º
            scene.add(logDropOffPileGroup);
            console.log("–ü–æ–ª–µ–Ω–Ω–∏—Ü–∞ (—É –ª–µ—Å–æ–ø–∏–ª–∫–∏) —Å–æ–∑–¥–∞–Ω–∞ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º:", logDropOffPileGroup.position);

            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—å–Ω—ã—Ö –±—Ä–µ–≤–µ–Ω –∫ –ø–æ–ª–µ–Ω–Ω–∏—Ü–µ
            const initialLogsCount = 20; // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±—Ä–µ–≤–µ–Ω
            for (let i = 0; i < initialLogsCount; i++) {
                const log = createCollectibleLog(); // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –±—Ä–µ–≤–Ω–∞
                // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∏—Ö –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã logDropOffPileGroup
                const logsPerRow = 8;
                const logHeight = 0.3;
                const row = Math.floor(i / logsPerRow);
                const col = i % logsPerRow;
                const xOffset = (col * 0.3) - (logsPerRow * 0.3 / 2) + 0.15;
                const yOffset = (row * logHeight) + 0.15;
                const zOffset = (Math.random() - 0.5) * 0.1;
                log.position.set(xOffset, yOffset, zOffset);
                log.rotation.z = Math.PI / 2;
                log.rotation.y = (Math.random() - 0.5) * 0.2;
                logDropOffPileGroup.add(log);
            }
            console.log("–ù–∞—á–∞–ª—å–Ω—ã–µ –±—Ä–µ–≤–Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –ø–æ–ª–µ–Ω–Ω–∏—Ü—É. –í—Å–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –≥—Ä—É–ø–ø–µ:", logDropOffPileGroup.children.length);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –æ–¥–Ω–æ –±—Ä–µ–≤–Ω–æ, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–¥–æ–±—Ä–∞–Ω–æ –∏–≥—Ä–æ–∫–æ–º.
         * @returns {THREE.Mesh} –ú–µ—à –±—Ä–µ–≤–Ω–∞.
         */
        function createCollectibleLog() {
            const logGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.0, 8);
            const logMaterialCollectible = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x654321, // Keep the base color for tinting
                roughness: 0.8
            });
            const log = new THREE.Mesh(logGeometry, logMaterialCollectible);
            log.rotation.z = Math.PI / 2; // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ
            log.castShadow = true;
            log.receiveShadow = true;
            log.userData.type = 'log'; // –ü–æ–º–µ—á–∞–µ–º —Ç–∏–ø —Ä–µ—Å—É—Ä—Å–∞
            log.userData.collectibleAmount = 1; // –û–¥–Ω–æ –±—Ä–µ–≤–Ω–æ –∑–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ
            return log;
        }

        /**
         * –î–æ–±–∞–≤–ª—è–µ—Ç –±—Ä–µ–≤–Ω–æ –∫ –ø–æ–ª–µ–Ω–Ω–∏—Ü–µ.
         * @param {THREE.Mesh} logMesh - –ú–µ—à –±—Ä–µ–≤–Ω–∞, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å.
         */
        function addLogToPile(logMesh) {
            if (!logDropOffPileGroup) return;

            // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –Ω–æ–≤–æ–≥–æ –±—Ä–µ–≤–Ω–∞ –≤ –ø–æ–ª–µ–Ω–Ω–∏—Ü–µ
            const currentLogs = playerInventory.log; // –ò—Å–ø–æ–ª—å–∑—É–µ–º playerInventory.log –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏
            const logsPerRow = 8; 
            const logHeight = 0.3; 

            const row = Math.floor(currentLogs / logsPerRow);
            const col = currentLogs % logsPerRow;

            // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º X-–ø–æ–∑–∏—Ü–∏—é, —á—Ç–æ–±—ã –±—Ä–µ–≤–Ω–∞ —Å–∫–ª–∞–¥—ã–≤–∞–ª–∏—Å—å –∞–∫–∫—É—Ä–∞—Ç–Ω–æ
            const xOffset = (col * 0.3) - (logsPerRow * 0.3 / 2) + 0.15; 
            const yOffset = (row * logHeight) + 0.15; 
            const zOffset = (Math.random() - 0.5) * 0.1; // –ù–µ–±–æ–ª—å—à–æ–µ —Å–ª—É—á–∞–π–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –ø–æ Z

            logMesh.position.set(xOffset, yOffset, zOffset);
            logMesh.rotation.z = Math.PI / 2; // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ
            logMesh.rotation.y = (Math.random() - 0.5) * 0.2; // –ù–µ–±–æ–ª—å—à–æ–π —Å–ª—É—á–∞–π–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç

            logDropOffPileGroup.add(logMesh);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω—é (–Ω–æ–≤—ã–π –¥–æ–º–∏–∫).
         */
        function createQuarry() {
            quarryHouse = new THREE.Group();
            // –°–≤–µ—Ç–ª–µ–µ, —á–µ–º –∫–∞–º–Ω–∏ (0x808080)
            const quarryStoneMaterial = new THREE.MeshStandardMaterial({ color: 0xD3D3D3, roughness: 0.8, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: 1 }); // LightGray
            const quarryRoofMaterial = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.7 }); // DarkGray
            const buttressMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, roughness: 0.8, polygonOffset: true, polygonOffsetFactor: -2, polygonOffsetUnits: 1 }); // DarkGray –¥–ª—è –∫–æ–Ω—Ç—Ä—Ñ–æ—Ä—Å–æ–≤

            // –¢–µ–ª–æ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
            const quarryBodyGeometry = new THREE.BoxGeometry(6, 4, 5);
            const quarryBody = new THREE.Mesh(quarryBodyGeometry, quarryStoneMaterial);
            quarryBody.position.y = 2;
            quarryBody.castShadow = true;
            quarryBody.receiveShadow = true;
            quarryHouse.add(quarryBody);

            // –ö—Ä—ã—à–∞ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏ (–ø–ª–æ—Å–∫–∞—è, –Ω–æ —Å –Ω–µ–±–æ–ª—å—à–∏–º —É–∫–ª–æ–Ω–æ–º)
            const quarryRoofGeometry = new THREE.BoxGeometry(6.2, 0.5, 5.2);
            const quarryRoof = new THREE.Mesh(quarryRoofGeometry, quarryRoofMaterial);
            quarryRoof.position.y = 4 + 0.25;
            quarryRoof.rotation.x = -Math.PI / 60; // –ù–µ–±–æ–ª—å—à–æ–π –Ω–∞–∫–ª–æ–Ω
            quarryRoof.castShadow = true;
            quarryHouse.add(quarryRoof);

            // –í—Ö–æ–¥ –≤ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω—é
            const quarryDoorGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.1);
            const quarryDoorMaterial = new THREE.MeshStandardMaterial({ color: 0x303030, roughness: 0.6 });
            const quarryDoor = new THREE.Mesh(quarryDoorGeometry, quarryDoorMaterial);
            quarryDoor.position.set(0, 1.25, 2.55);
            quarryDoor.castShadow = true;
            quarryHouse.add(quarryDoor);

            // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç—Ä—Ñ–æ—Ä—Å—ã (–æ–ø–æ—Ä–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã) –¥–ª—è –±–æ–ª—å—à–µ–π –º–∞—Å—Å–∏–≤–Ω–æ—Å—Ç–∏
            const buttressGeometry = new THREE.BoxGeometry(1, 4, 1);
            

            const buttress1 = new THREE.Mesh(buttressGeometry, buttressMaterial);
            buttress1.position.set(3.0, 2, 2.0); // –ü–µ—Ä–µ–¥–Ω–∏–π –ø—Ä–∞–≤—ã–π
            buttress1.castShadow = true;
            buttress1.receiveShadow = true;
            quarryHouse.add(buttress1);
            const buttress2 = new THREE.Mesh(buttressGeometry, buttressMaterial);
            buttress2.position.set(-3.0, 2, 2.0); // –ü–µ—Ä–µ–¥–Ω–∏–π –ª–µ–≤—ã–π
            buttress2.castShadow = true;
            buttress2.receiveShadow = true;
            quarryHouse.add(buttress2);
            const buttress3 = new THREE.Mesh(buttressGeometry, buttressMaterial);
            buttress3.position.set(3.0, 2, -2.0); // –ó–∞–¥–Ω–∏–π –ø—Ä–∞–≤—ã–π
            buttress3.castShadow = true;
            buttress3.receiveShadow = true;
            quarryHouse.add(buttress3);
            const buttress4 = new THREE.Mesh(buttressGeometry, buttressMaterial);
            buttress4.position.set(-3.0, 2, -2.0); // –ó–∞–¥–Ω–∏–π –ª–µ–≤—ã–π
            buttress4.castShadow = true;
            buttress4.receiveShadow = true;
            quarryHouse.add(buttress4);


            // –†–∞–∑–º–µ—â–∞–µ–º –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω—é
            quarryHouse.position.set(40, 0, -40); 
            scene.add(quarryHouse);

            // –¢–æ—á–µ—á–Ω—ã–π —Å–≤–µ—Ç –¥–ª—è –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏ (–ª–æ–∫–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã quarryHouse)
            const quarryLight = new THREE.PointLight(0xFFE0B2, nightSettings.windowLightIntensity, 10); 
            quarryLight.position.set(0, 2, 0); // –¶–µ–Ω—Ç—Ä –∑–¥–∞–Ω–∏—è
            quarryLight.castShadow = true;
            quarryHouse.add(quarryLight); // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—Ç –∫ –≥—Ä—É–ø–ø–µ –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
            quarryLights.push(quarryLight); // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å—é

            return quarryHouse; 
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –æ–¥–∏–Ω –∫–∞–º–µ–Ω—å, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–¥–æ–±—Ä–∞–Ω –∏–≥—Ä–æ–∫–æ–º.
         * @returns {THREE.Mesh} –ú–µ—à –∫–∞–º–Ω—è.
         */
        function createCollectibleStone() {
            const stoneGeometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.2, 8, 8);
            const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9, metalness: 0.0 });
            const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
            stone.castShadow = true;
            stone.receiveShadow = true;
            stone.userData.type = 'stone'; // –ü–æ–º–µ—á–∞–µ–º —Ç–∏–ø —Ä–µ—Å—É—Ä—Å–∞
            stone.userData.collectibleAmount = 1; // –û–¥–∏–Ω –∫–∞–º–µ–Ω—å –∑–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ
            return stone;
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –∫—É—á—É –∫–∞–º–Ω–µ–π —Ä—è–¥–æ–º —Å –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–µ–π.
         * @param {THREE.Group} quarry - –û–±—ä–µ–∫—Ç –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏.
         */
        function createStoneDropOffPile(quarry) {
            stoneDropOffPileGroup = new THREE.Group();
            stoneDropOffPileGroup.position.set(quarry.position.x - 3.5, 0, quarry.position.z - 0.5); // –ú–µ—Å—Ç–æ –¥–ª—è —Å–∫–ª–∞–¥—ã–≤–∞–Ω–∏—è –∫–∞–º–Ω–µ–π
            stoneDropOffPileGroup.rotation.y = -Math.PI / 4; // –ù–µ–º–Ω–æ–≥–æ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º
            scene.add(stoneDropOffPileGroup);

            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—å–Ω—ã—Ö –∫–∞–º–Ω–µ–π –∫ –∫—É—á–µ
            const initialStonesCount = 10; // –ù–∞–ø—Ä–∏–º–µ—Ä, 10 –∫–∞–º–Ω–µ–π –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ
            for (let i = 0; i < initialStonesCount; i++) {
                const stone = createCollectibleStone(); // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞–º–Ω—è
                // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∏—Ö –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã stoneDropOffPileGroup
                const stonesPerRow = 6;
                const stoneHeight = 0.6;
                const row = Math.floor(i / stonesPerRow);
                const col = i % stonesPerRow;
                const xOffset = (col * 0.5) - (stonesPerRow * 0.5 / 2) + 0.25;
                const yOffset = (row * stoneHeight) + 0.15;
                const zOffset = (Math.random() - 0.5) * 0.1;
                stone.position.set(xOffset, yOffset, zOffset);
                stone.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                stoneDropOffPileGroup.add(stone);
            }
        }

        /**
         * –î–æ–±–∞–≤–ª—è–µ—Ç –∫–∞–º–µ–Ω—å –∫ –∫—É—á–µ –∫–∞–º–Ω–µ–π.
         * @param {THREE.Mesh} stoneMesh - –ú–µ—à –∫–∞–º–Ω—è, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å.
         */
        function addStoneToPile(stoneMesh) {
            if (!stoneDropOffPileGroup) return;

            const currentStones = playerInventory.stone;
            const stonesPerRow = 6; // –ö–∞–º–Ω–∏ –º–µ–Ω—å—à–µ, –º–æ–∂–Ω–æ –±–æ–ª—å—à–µ –≤ —Ä—è–¥
            const stoneHeight = 0.6; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –∫–∞–º–Ω—è

            const row = Math.floor(currentStones / stonesPerRow);
            const col = currentStones % stonesPerRow;

            const xOffset = (col * 0.5) - (stonesPerRow * 0.5 / 2) + 0.25;
            const yOffset = (row * stoneHeight) + 0.15;
            const zOffset = (Math.random() - 0.5) * 0.1;

            stoneMesh.position.set(xOffset, yOffset, zOffset);
            stoneMesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI); // –°–ª—É—á–∞–π–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
            
            stoneDropOffPileGroup.add(stoneMesh);
        }

        /**
         * –†–∞–∑–º–µ—â–∞–µ—Ç —Ä–µ—Å—É—Ä—Å –Ω–∞ –∑–µ–º–ª–µ –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞.
         * @param {THREE.Mesh} resourceMesh - –ú–µ—à —Ä–µ—Å—É—Ä—Å–∞.
         * @param {THREE.Vector3} playerPos - –ü–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞.
         * @param {string} resourceType - –¢–∏–ø —Ä–µ—Å—É—Ä—Å–∞ ('log' –∏–ª–∏ 'stone').
         */
        function placeResourceOnGround(resourceMesh, playerPos, resourceType) {
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –Ω–µ–º–Ω–æ–≥–æ –≤–ø–µ—Ä–µ–¥–∏ –∏–≥—Ä–æ–∫–∞
            const placementOffset = 1.5; // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–¥ –∏–≥—Ä–æ–∫–æ–º
            const playerForward = new THREE.Vector3();
            player.getWorldDirection(playerForward);
            playerForward.y = 0; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            playerForward.normalize();

            const placementX = playerPos.x + playerForward.x * placementOffset;
            const placementZ = playerPos.z + playerForward.z * placementOffset;

            let highestY = 0; // –£—Ä–æ–≤–µ–Ω—å –∑–µ–º–ª–∏
            const placementTolerance = 0.8; // –ù–∞—Å–∫–æ–ª—å–∫–æ –±–ª–∏–∑–∫–æ –æ–±—ä–µ–∫—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å, —á—Ç–æ–±—ã —Å—á–∏—Ç–∞—Ç—å—Å—è –¥–ª—è —Å—Ç–µ–∫–∞

            // –ù–∞—Ö–æ–¥–∏–º —Å–∞–º—É—é –≤—ã—Å–æ–∫—É—é —Ç–æ—á–∫—É –≤ –º–µ—Å—Ç–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –¥–ª—è —Å—Ç–µ–∫–∞
            placedBuildingBlocks.forEach(block => {
                const blockPos = block.position;
                const distance = Math.sqrt(
                    Math.pow(placementX - blockPos.x, 2) +
                    Math.pow(placementZ - blockPos.z, 2)
                );

                if (distance < placementTolerance) {
                    let blockHeight = 0;
                    if (block.geometry.type === 'CylinderGeometry') {
                        // –î–ª—è —Ü–∏–ª–∏–Ω–¥—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ª–µ–∂–∞—Ç –Ω–∞ –±–æ–∫—É, –≤—ã—Å–æ—Ç–∞ - —ç—Ç–æ –∏—Ö –¥–∏–∞–º–µ—Ç—Ä
                        blockHeight = block.geometry.parameters.radius * 2; 
                    } else if (block.geometry.type === 'SphereGeometry') {
                        blockHeight = block.geometry.parameters.radius * 2;
                    } else if (block.geometry.type === 'BoxGeometry') {
                        blockHeight = block.geometry.parameters.height;
                    }
                    // –í—ã—á–∏—Å–ª—è–µ–º –≤–µ—Ä—Ö–Ω—é—é –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –±–ª–æ–∫–∞
                    const blockTopY = blockPos.y + blockHeight / 2;
                    if (blockTopY > highestY) {
                        highestY = blockTopY;
                    }
                }
            });

            let resourceHeight = 0;
            if (resourceType === 'log') {
                resourceHeight = 0.3; // –ü—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω—ã–π –¥–∏–∞–º–µ—Ç—Ä, –∫–æ–≥–¥–∞ –ª–µ–∂–∏—Ç –ø–ª–∞—à–º—è
            } else if (resourceType === 'stone') {
                resourceHeight = resourceMesh.geometry.parameters.radius * 2; // –î–∏–∞–º–µ—Ç—Ä –∫–∞–º–Ω—è (—Å—Ñ–µ—Ä–∞)
            } else if (resourceType === 'plank') {
                resourceHeight = 0.15; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è —Ç–æ–ª—â–∏–Ω–∞ –¥–æ—Å–∫–∏
            } else if (resourceType === 'brick') {
                resourceHeight = 0.2; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –∫–∏—Ä–ø–∏—á–∞
            } else if (resourceType === 'small-wall') {
                resourceHeight = 1.0; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è –≤—ã—Å–æ—Ç–∞ —Å—Ç–µ–Ω—ã
            }


            resourceMesh.position.set(placementX, highestY + resourceHeight / 2, placementZ);
            // –û—Ä–∏–µ–Ω—Ç–∏—Ä—É–µ–º –±—Ä–µ–≤–Ω–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞, –∫–∞–º–Ω–∏ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–ª—É—á–∞–π–Ω—ã–º–∏
            if (resourceType === 'log' || resourceType === 'plank' || resourceType === 'small-wall') {
                resourceMesh.rotation.set(0, player.rotation.y, Math.PI / 2); // –õ–µ–∂–∏—Ç –ø–ª–∞—à–º—è, –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–æ –ø–æ –∏–≥—Ä–æ–∫—É
            } else {
                resourceMesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            }
            
            scene.add(resourceMesh);
            placedBuildingBlocks.push(resourceMesh);
            console.log(`–†–µ—Å—É—Ä—Å ${resourceType} —Ä–∞–∑–º–µ—â–µ–Ω –Ω–∞ –∑–µ–º–ª–µ –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞.`);
        }


        /**
         * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞ –≤ —Å—Ü–µ–Ω–µ.
         * –ò—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞ —Å–æ–∑–¥–∞—é—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑ –∏ –∑–∞—Ç–µ–º –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è –≤ —Ü–∏–∫–ª–µ animate.
         */
        function initializeLighting() {
            ambientLight = new THREE.AmbientLight(0x404040, daySettings.ambientIntensity);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(daySettings.directionalColor, daySettings.directionalIntensity);
            directionalLight.position.copy(daySettings.directionalPosition); 
            directionalLight.castShadow = true;

            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200; 
            directionalLight.shadow.camera.left = -90; 
            directionalLight.shadow.camera.right = 90; 
            directionalLight.shadow.camera.top = 90; 
            directionalLight.shadow.camera.bottom = -90; 
            scene.add(directionalLight);

            hemisphereLight = new THREE.HemisphereLight(daySettings.hemisphereSkyColor, daySettings.hemisphereGroundColor, daySettings.hemisphereIntensity);
            scene.add(hemisphereLight);
        }

        // --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π ---

        function onKeyDown(event) {
            keys[event.code] = true;
            if (event.code === 'KeyE') { // –ö–ª–∞–≤–∏—à–∞ E –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
                console.log("–ö–ª–∞–≤–∏—à–∞ 'E' –Ω–∞–∂–∞—Ç–∞.");
                handleInteraction();
            } else if (event.code === 'KeyI') { // –ö–ª–∞–≤–∏—à–∞ I –¥–ª—è –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
                toggleInventory();
            } else if (event.code === 'KeyC') { // –ö–ª–∞–≤–∏—à–∞ C –¥–ª—è –∫—Ä–∞—Ñ—Ç–∞
                toggleCrafting();
            }
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                
                // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –º–∏—Ä–æ–≤–∞—è Y-–ø–æ–∑–∏—Ü–∏—è, –∫–æ—Ç–æ—Ä—É—é –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å –∫–∞–º–µ—Ä–∞.
                // –≠—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –æ–ø—É—Å–∫–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã –ø–æ–¥ –∑–µ–º–ª—é.
                // –ó–Ω–∞—á–µ–Ω–∏–µ 1.5 –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç, —á—Ç–æ –∫–∞–º–µ—Ä–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–µ–º–Ω–æ–≥–æ –≤—ã—à–µ —É—Ä–æ–≤–Ω—è –∑–µ–º–ª–∏.
                const minCameraY = 1.5; 

                // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º—É—é –º–∏—Ä–æ–≤—É—é Y-–ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã.
                // camera.position.y = playerPosition.y + (Math.sin(cameraAngleX) * cameraDistance + 3)
                const currentCameraYOffset = Math.sin(cameraAngleX) * cameraDistance + 3;
                const projectedCameraWorldY = playerPosition.y + currentCameraYOffset;

                // –ï—Å–ª–∏ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º–∞—è Y-–ø–æ–∑–∏—Ü–∏—è –Ω–∏–∂–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–π, –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º cameraAngleX.
                if (projectedCameraWorldY < minCameraY) {
                    // –í—ã—á–∏—Å–ª—è–µ–º —Ç—Ä–µ–±—É–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ sin(cameraAngleX) –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è minCameraY.
                    const requiredSinAngle = (minCameraY - 3 - playerPosition.y) / cameraDistance;
                    
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º Math.asin –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É–≥–ª–∞, –Ω–æ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç -1 –¥–æ 1,
                    // —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å NaN (–Ω–µ —á–∏—Å–ª–æ) –æ—à–∏–±–æ–∫.
                    cameraAngleX = Math.asin(Math.max(-1, Math.min(1, requiredSinAngle)));
                }
                
                // –¢–∞–∫–∂–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫–æ –≤–≤–µ—Ä—Ö, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∏–Ω–≤–µ—Ä—Å–∏–∏ –∫–∞–º–µ—Ä—ã.
                cameraAngleX = Math.min(Math.PI / 2 - 0.01, cameraAngleX); 

                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onWheel(event) {
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(3, Math.min(200, cameraDistance)); 
        }

        /**
         * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞ –∏ –∫–∞–º–µ—Ä—ã.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π.
         */
        function setupControls() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            window.addEventListener('resize', onWindowResize); /* Moved this function definition here */

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            const dayNightSlider = document.getElementById('dayNightSlider');
            if (dayNightSlider) {
                dayNightSlider.addEventListener('input', (event) => {
                    isManualTimeControl = true; // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—Ä—É—á–Ω—É—é –∏–∑–º–µ–Ω—è–µ—Ç –≤—Ä–µ–º—è
                    transitionProgress = event.target.value / 100;
                    updateDayNightVisuals(transitionProgress); // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ
                });
                dayNightSlider.addEventListener('mousedown', () => {
                    isSliderDragging = true; // –ù–∞—á–∞–ª–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
                    isManualTimeControl = true; // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—Ä—É—á–Ω—É—é –∏–∑–º–µ–Ω—è–µ—Ç –≤—Ä–µ–º—è
                });
                dayNightSlider.addEventListener('mouseup', () => {
                    isSliderDragging = false; // –ö–æ–Ω–µ—Ü –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
                    // isManualTimeControl –æ—Å—Ç–∞–µ—Ç—Å—è true, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä—É—á–Ω—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É
                });
            }

            document.getElementById('toggle-inventory-button').addEventListener('click', toggleInventory);
            document.getElementById('toggle-crafting-button').addEventListener('click', toggleCrafting);
            document.getElementById('crafting-close-button').addEventListener('click', closeCraftingMenu);
        }

        /**
         * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –∏–≥—Ä–æ–∫–∞ (–ø–æ–¥–±–æ—Ä/–≤—ã–≥—Ä—É–∑–∫–∞ —Ä–µ—Å—É—Ä—Å–∞).
         */
        function handleInteraction() {
            if (playerHasResource) {
                // –ò–≥—Ä–æ–∫ –¥–µ—Ä–∂–∏—Ç —Ä–µ—Å—É—Ä—Å, –ø—ã—Ç–∞–µ—Ç—Å—è –≤—ã–≥—Ä—É–∑–∏—Ç—å –µ–≥–æ
                let deposited = false;
                if (currentResourceType === 'log') {
                    // –ü–æ–ø—ã—Ç–∫–∞ –≤—ã–≥—Ä—É–∑–∏—Ç—å –±—Ä–µ–≤–Ω–æ —É –ø–æ–ª–µ–Ω–Ω–∏—Ü—ã —Å–∞—Ä–∞–π—á–∏–∫–∞ (–ª–µ—Å–æ–ø–∏–ª–∫–∏)
                    const distanceToLogPile = playerPosition.distanceTo(logDropOffPileGroup.position);
                    console.log('–ò–≥—Ä–æ–∫ –¥–µ—Ä–∂–∏—Ç –±—Ä–µ–≤–Ω–æ. –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –ø–æ–ª–µ–Ω–Ω–∏—Ü—ã (–¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏): ' + distanceToLogPile.toFixed(2));
                    if (distanceToLogPile < interactDistance + 2) { 
                        player.userData.hand.remove(currentHeldResource);
                        // currentHeldResource.geometry.dispose(); // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–∞–º—è—Ç—å
                        // currentHeldResource.material.dispose();
                        // scene.remove(currentHeldResource); // –£–¥–∞–ª—è–µ–º –∏–∑ —Å—Ü–µ–Ω—ã, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–µ–Ω –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç
                        playerInventory.log++;
                        addLogToPile(currentHeldResource); // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫—É—á—É
                        console.log('–ë—Ä–µ–≤–Ω–æ –≤—ã–≥—Ä—É–∂–µ–Ω–æ! –í—Å–µ–≥–æ —Å–æ–±—Ä–∞–Ω–æ: ' + playerInventory.log);
                        deposited = true;
                    } else {
                        // –ò–≥—Ä–æ–∫ –Ω–µ —Ä—è–¥–æ–º —Å –ø–æ–ª–µ–Ω–Ω–∏—Ü–µ–π, —Ä–∞–∑–º–µ—â–∞–µ–º –±—Ä–µ–≤–Ω–æ –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                        player.userData.hand.remove(currentHeldResource);
                        placeResourceOnGround(currentHeldResource, playerPosition, currentResourceType);
                        deposited = true; // –°—á–∏—Ç–∞–µ–º —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –∫–∞–∫ —É—Å–ø–µ—à–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ
                    }
                } else if (currentResourceType === 'stone') {
                    // –ü–æ–ø—ã—Ç–∫–∞ –≤—ã–≥—Ä—É–∑–∏—Ç—å –∫–∞–º–µ–Ω—å —É –∫—É—á–∏ –∫–∞–º–Ω–µ–π –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω–∏
                    const distanceToStonePile = playerPosition.distanceTo(stoneDropOffPileGroup.position);
                    console.log('–ò–≥—Ä–æ–∫ –¥–µ—Ä–∂–∏—Ç –∫–∞–º–µ–Ω—å. –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –∫—É—á–∏ –∫–∞–º–Ω–µ–π (–¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏): ' + distanceToStonePile.toFixed(2));
                    if (distanceToStonePile < interactDistance + 2) { 
                        player.userData.hand.remove(currentHeldResource);
                        // currentHeldResource.geometry.dispose();
                        // currentHeldResource.material.dispose();
                        // scene.remove(currentHeldResource);
                        playerInventory.stone++;
                        addStoneToPile(currentHeldResource);
                        console.log('–ö–∞–º–µ–Ω—å –≤—ã–≥—Ä—É–∂–µ–Ω! –í—Å–µ–≥–æ —Å–æ–±—Ä–∞–Ω–æ: ' + playerInventory.stone);
                        deposited = true;
                    } else {
                        // –ò–≥—Ä–æ–∫ –Ω–µ —Ä—è–¥–æ–º —Å –∫—É—á–µ–π –∫–∞–º–Ω–µ–π, —Ä–∞–∑–º–µ—â–∞–µ–º –∫–∞–º–µ–Ω—å –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                        player.userData.hand.remove(currentHeldResource);
                        placeResourceOnGround(currentHeldResource, playerPosition, currentResourceType);
                        deposited = true; // –°—á–∏—Ç–∞–µ–º —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –∫–∞–∫ —É—Å–ø–µ—à–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ
                    }
                } else if (currentResourceType === 'plank' || currentResourceType === 'brick' || currentResourceType === 'small-wall') {
                    // –†–∞–∑–º–µ—â–∞–µ–º —Å–∫—Ä–∞—Ñ—á–µ–Ω–Ω—ã–µ –ø—Ä–µ–¥–º–µ—Ç—ã –Ω–∞ –∑–µ–º–ª–µ
                    player.userData.hand.remove(currentHeldResource);
                    placeResourceOnGround(currentHeldResource, playerPosition, currentResourceType);
                    deposited = true;
                }

                if (deposited) {
                    currentHeldResource = null;
                    playerHasResource = false;
                    currentResourceType = null;
                    updateInventoryUI(); // –û–±–Ω–æ–≤–ª—è–µ–º UI –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
                }
            } else {
                // –ò–≥—Ä–æ–∫ –Ω–µ –¥–µ—Ä–∂–∏—Ç —Ä–µ—Å—É—Ä—Å, –ø—ã—Ç–∞–µ—Ç—Å—è –ø–æ–¥–æ–±—Ä–∞—Ç—å –µ–≥–æ
                let pickedUp = false;
                
                // –ü–æ–∏—Å–∫ —É–∂–µ —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤ –¥–ª—è –ø–æ–¥–±–æ—Ä–∞
                for (let i = 0; i < placedBuildingBlocks.length; i++) {
                    const block = placedBuildingBlocks[i];
                    const distanceToBlock = playerPosition.distanceTo(block.position);
                    if (distanceToBlock < interactDistance) {
                        currentHeldResource = block; // –ü–æ–¥–±–∏—Ä–∞–µ–º —Å–∞–º –º–µ—à
                        currentResourceType = block.userData.type;
                        
                        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∏ –≤—Ä–∞—â–µ–Ω–∏–µ, —á—Ç–æ–±—ã –æ–Ω –ø–æ—è–≤–∏–ª—Å—è –≤ —Ä—É–∫–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
                        currentHeldResource.position.set(0, 0, 0); 
                        if (currentResourceType === 'log' || currentResourceType === 'plank' || currentResourceType === 'small-wall') {
                            currentHeldResource.rotation.set(0, 0, Math.PI / 2); // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ –≤ —Ä—É–∫–µ
                        } else {
                            currentHeldResource.rotation.set(0, 0, 0); // –ë–µ–∑ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è –≤ —Ä—É–∫–µ
                        }

                        player.userData.hand.add(currentHeldResource); // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Ä—É–∫—É
                        // –í–∞–∂–Ω–æ: –Ω–µ —É–¥–∞–ª—è–µ–º –∏–∑ —Å—Ü–µ–Ω—ã, —Ç–∞–∫ –∫–∞–∫ –æ–Ω —É–∂–µ –±—ã–ª —á–∞—Å—Ç—å—é —Å—Ü–µ–Ω—ã, –ø—Ä–æ—Å—Ç–æ –º–µ–Ω—è–µ–º —Ä–æ–¥–∏—Ç–µ–ª—è
                        placedBuildingBlocks.splice(i, 1); // –£–¥–∞–ª—è–µ–º –∏–∑ –º–∞—Å—Å–∏–≤–∞ —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤
                        playerHasResource = true;
                        pickedUp = true;
                        console.log(`–†–µ—Å—É—Ä—Å ${currentResourceType} –ø–æ–¥–æ–±—Ä–∞–Ω —Å –∑–µ–º–ª–∏.`);
                        break;
                    }
                }

                // –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–æ–±—Ä–∞–ª —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã–π –±–ª–æ–∫, –∏—â–µ–º —Å–æ–±–∏—Ä–∞–µ–º—ã–µ —Ä–µ—Å—É—Ä—Å—ã
                if (!pickedUp) {
                    // –ü–æ–∏—Å–∫ –¥–µ—Ä–µ–≤–∞ –¥–ª—è –±—Ä–µ–≤–Ω–∞
                    for (let i = 0; i < collectibleTrees.length; i++) {
                        const tree = collectibleTrees[i];
                        if (tree.userData.isCollectible && tree.userData.collectibleAmount > 0) {
                            const distanceToTree = playerPosition.distanceTo(tree.position);
                            console.log('–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –¥–µ—Ä–µ–≤–∞ (–¥–ª—è –ø–æ–¥–±–æ—Ä–∞): ' + distanceToTree.toFixed(2) + '. –ë—Ä–µ–≤–Ω–∞ –æ—Å—Ç–∞–ª–∏—Å—å: ' + tree.userData.collectibleAmount);
                            if (distanceToTree < interactDistance) {
                                playerInventory.log++;
                                tree.userData.collectibleAmount--;
                                
                                if (tree.userData.collectibleAmount === 0) {
                                    console.log('–î–µ—Ä–µ–≤–æ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ –ø–µ–Ω–µ–∫!');
                                    tree.userData.originalFoliage.forEach(foliagePart => {
                                        tree.remove(foliagePart);
                                    });
                                    const stump = createStump();
                                    tree.add(stump);
                                    tree.userData.isCollectible = false; // –ë–æ–ª—å—à–µ –Ω–µ —Å–æ–±–∏—Ä–∞–µ–º–æ–µ
                                }
                                pickedUp = true;
                                break; 
                            }
                        } else if (tree.userData.isCollectible === false) { // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É–∂–µ –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–Ω—ã–π –≤ –ø–µ–Ω–µ–∫
                            const distanceToTree = playerPosition.distanceTo(tree.position);
                            if (distanceToTree < interactDistance) {
                                console.log('–≠—Ç–æ –¥–µ—Ä–µ–≤–æ —É–∂–µ –ø—Ä–µ–≤—Ä–∞—Ç–∏–ª–æ—Å—å –≤ –ø–µ–Ω–µ–∫. –ë–æ–ª—å—à–µ –±—Ä–µ–≤–µ–Ω –Ω–µ—Ç.');
                            }
                        }
                    }
                }

                // –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–æ–±—Ä–∞–ª –±—Ä–µ–≤–Ω–æ, –∏—â–µ–º –∫–∞–º–µ–Ω—å
                if (!pickedUp) {
                    for (let i = 0; i < collectibleStones.length; i++) {
                        const stone = collectibleStones[i];
                        if (stone.userData.isCollectible && stone.userData.collectibleAmount > 0) { 
                            const distanceToStone = playerPosition.distanceTo(stone.position);
                            console.log('–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –∫–∞–º–Ω—è (–¥–ª—è –ø–æ–¥–±–æ—Ä–∞): ' + distanceToStone.toFixed(2) + '. –ö–∞–º–Ω–∏ –æ—Å—Ç–∞–ª–∏—Å—å: ' + stone.userData.collectibleAmount);
                            if (distanceToStone < interactDistance) {
                                playerInventory.stone++;
                                stone.userData.collectibleAmount--;

                                if (stone.userData.collectibleAmount === 0) {
                                    console.log('–ö–∞–º–µ–Ω—å –∏—Å—á–µ–∑!');
                                    scene.remove(stone); // –ö–∞–º–µ–Ω—å –ø—Ä–æ–ø–∞–¥–∞–µ—Ç
                                    stone.userData.isCollectible = false; // –ë–æ–ª—å—à–µ –Ω–µ —Å–æ–±–∏—Ä–∞–µ–º—ã–π
                                    collectibleStones.splice(i, 1); // –£–¥–∞–ª—è–µ–º –∏–∑ –º–∞—Å—Å–∏–≤–∞, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –∏—Å—á–µ–∑
                                }
                                pickedUp = true;
                                break;
                            }
                        } else if (stone.userData.isCollectible === false) { // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É–∂–µ –∏—Å—á–µ–∑–Ω—É–≤—à–∏–π –∫–∞–º–µ–Ω—å
                               const distanceToStone = playerPosition.distanceTo(stone.position);
                               if (distanceToStone < interactDistance) {
                                   console.log('–≠—Ç–æ—Ç –∫–∞–º–µ–Ω—å —É–∂–µ –∏—Å—á–µ—Ä–ø–∞–Ω –∏ –∏—Å—á–µ–∑.');
                               }
                        }
                    }
                }

                // –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–æ–±—Ä–∞–ª –∫–∞–º–µ–Ω—å, –∏—â–µ–º —è–≥–æ–¥—ã
                if (!pickedUp) {
                    for (let i = 0; i < collectibleBerryBushes.length; i++) {
                        const bush = collectibleBerryBushes[i];
                        if (bush.userData.isCollectible && bush.userData.collectibleAmount > 0) {
                            const distanceToBush = playerPosition.distanceTo(bush.position);
                            if (distanceToBush < interactDistance) {
                                playerInventory.berry++;
                                bush.userData.collectibleAmount--;
                                if (bush.userData.collectibleAmount === 0) {
                                    scene.remove(bush);
                                    bush.userData.isCollectible = false;
                                    collectibleBerryBushes.splice(i, 1);
                                }
                                pickedUp = true;
                                break;
                            }
                        }
                    }
                }

                // –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–æ–±—Ä–∞–ª —è–≥–æ–¥—ã, –∏—â–µ–º —Ä—É–¥—É
                if (!pickedUp) {
                    for (let i = 0; i < collectibleMetalOres.length; i++) {
                        const ore = collectibleMetalOres[i];
                        if (ore.userData.isCollectible && ore.userData.collectibleAmount > 0) {
                            const distanceToOre = playerPosition.distanceTo(ore.position);
                            if (distanceToOre < interactDistance) {
                                playerInventory.ore++;
                                ore.userData.collectibleAmount--;
                                if (ore.userData.collectibleAmount === 0) {
                                    scene.remove(ore);
                                    ore.userData.isCollectible = false;
                                    collectibleMetalOres.splice(i, 1);
                                }
                                pickedUp = true;
                                break;
                            }
                        }
                    }
                }

                // –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–æ–±—Ä–∞–ª —Ä—É–¥—É, –∏—â–µ–º —Ü–≤–µ—Ç—ã
                if (!pickedUp) {
                    for (let i = 0; i < collectibleFlowers.length; i++) {
                        const flower = collectibleFlowers[i];
                        if (flower.userData.isCollectible && flower.userData.collectibleAmount > 0) {
                            const distanceToFlower = playerPosition.distanceTo(flower.position);
                            if (distanceToFlower < interactDistance) {
                                playerInventory.flower++;
                                flower.userData.collectibleAmount--;
                                if (flower.userData.collectibleAmount === 0) {
                                    scene.remove(flower);
                                    flower.userData.isCollectible = false;
                                    collectibleFlowers.splice(i, 1);
                                }
                                pickedUp = true;
                                break;
                            }
                        }
                    }
                }

                // –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–æ–±—Ä–∞–ª —Ü–≤–µ—Ç—ã, –∏—â–µ–º –≥—Ä–∏–±—ã
                if (!pickedUp) {
                    for (let i = 0; i < collectibleMushrooms.length; i++) {
                        const mushroom = collectibleMushrooms[i];
                        if (mushroom.userData.isCollectible && mushroom.userData.collectibleAmount > 0) {
                            const distanceToMushroom = playerPosition.distanceTo(mushroom.position);
                            if (distanceToMushroom < interactDistance) {
                                playerInventory.mushroom++;
                                mushroom.userData.collectibleAmount--;
                                if (mushroom.userData.collectibleAmount === 0) {
                                    scene.remove(mushroom);
                                    mushroom.userData.isCollectible = false;
                                    collectibleMushrooms.splice(i, 1);
                                }
                                pickedUp = true;
                                break;
                            }
                        }
                    }
                }

                if (!pickedUp) {
                    console.log('–ù–µ—Ç —Ä–µ—Å—É—Ä—Å–æ–≤ –¥–ª—è –ø–æ–¥–±–æ—Ä–∞ –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏ –∏–ª–∏ –≤—ã —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ. –ü–æ–¥–æ–π–¥–∏—Ç–µ –∫ –¥–µ—Ä–µ–≤—É –∏–ª–∏ –∫–∞–º–Ω—é.');
                }
                updateInventoryUI(); // –û–±–Ω–æ–≤–ª—è–µ–º UI –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–ª–æ—Ç–Ω—ã–π –ª–µ—Å –≤ –ø—Ä–∞–≤–æ–º –¥–∞–ª—å–Ω–µ–º —É–≥–ª—É –∫–∞—Ä—Ç—ã –∏ —Ä–∞–∑–º–µ—â–∞–µ—Ç –≤ –Ω–µ–º –æ–ª–µ–Ω–µ–π.
         */
        function createDenseForestWithDeer() {
            const forestMinX = 60; 
            const forestMaxX = 90;
            const forestMinZ = -90; 
            const forestMaxZ = -60;
            const treeCount = 100; 

            const deciduousTrunkMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x8B4513, // Keep the base color for tinting
                roughness: 0.8
            });
            const deciduousFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });
            const firTrunkMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x5C4033, // Keep the base color for tinting
                roughness: 0.8
            }); 
            const firFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 0.7 }); 

            for (let i = 0; i < treeCount; i++) {
                const tree = new THREE.Group();
                const treeX = forestMinX + Math.random() * (forestMaxX - forestMinX);
                const treeZ = forestMinZ + Math.random() * (forestMaxZ - forestMinZ);

                if (Math.random() > 0.5) { // –õ–∏—Å—Ç–≤–µ–Ω–Ω–æ–µ –¥–µ—Ä–µ–≤–æ
                    const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
                    const trunk = new THREE.Mesh(trunkGeometry, deciduousTrunkMaterial);
                    trunk.position.y = 1;
                    trunk.castShadow = true;
                    trunk.receiveShadow = true;
                    tree.add(trunk);

                    const numFoliageSpheres = 3 + Math.floor(Math.random() * 3);
                    for (let j = 0; j < numFoliageSpheres; j++) {
                        const foliageGeometry = new THREE.SphereGeometry(0.8 + Math.random() * 0.4, 16, 16);
                        const foliage = new THREE.Mesh(foliageGeometry, deciduousFoliageMaterial); 
                        foliage.position.set(
                            (Math.random() - 0.5) * 1.5, 
                            2.5 + (Math.random() - 0.5) * 0.5, 
                            (Math.random() - 0.5) * 1.5  
                        );
                        foliage.castShadow = true;
                        tree.add(foliage);
                    }
                    tree.userData.originalFoliage = tree.children.filter(c => c.isMesh && c.geometry.type === 'SphereGeometry');
                } else { // –ï–ª—å
                    const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.25, 2.5, 8);
                    const trunk = new THREE.Mesh(trunkGeometry, firTrunkMaterial);
                    trunk.position.y = 1.25;
                    trunk.castShadow = true;
                    trunk.receiveShadow = true;
                    tree.add(trunk);

                    let foliageGeometry;
                    let foliageMesh;

                    foliageGeometry = new THREE.ConeGeometry(1.5, 2, 8); 
                    foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial);
                    foliageMesh.position.y = 2.5;
                    foliageMesh.castShadow = true;
                    tree.add(foliageMesh);

                    foliageGeometry = new THREE.ConeGeometry(1.0, 1.5, 8); 
                    foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial);
                    foliageMesh.position.y = 3.5;
                    foliageMesh.castShadow = true;
                    tree.add(foliageMesh);

                    foliageGeometry = new THREE.ConeGeometry(0.6, 1.0, 8); 
                    foliageMesh = new THREE.Mesh(foliageGeometry, firFoliageMaterial); 
                    foliageMesh.position.y = 4.2;
                    foliageMesh.castShadow = true;
                    tree.add(foliageMesh);
                    tree.userData.originalFoliage = tree.children.filter(c => c.isMesh && c.geometry.type.includes('ConeGeometry'));
                }

                tree.position.x = treeX; 
                tree.position.z = treeZ; 
                tree.scale.setScalar(0.7 + Math.random() * 0.6); 
                tree.userData.isCollectible = true;
                tree.userData.type = 'log';
                tree.userData.collectibleAmount = 10; // 10 –±—Ä–µ–≤–µ–Ω —Å –¥–µ—Ä–µ–≤–∞
                collectibleTrees.push(tree);
                scene.add(tree);
            }

            // –°–æ–∑–¥–∞–µ–º –æ–ª–µ–Ω–µ–π
            const numDeer = 3;
            for (let i = 0; i < numDeer; i++) {
                const deerX = forestMinX + Math.random() * (forestMaxX - forestMinX);
                const deerZ = forestMinZ + Math.random() * (forestMaxZ - forestMinZ);
                createDeer(deerX, deerZ);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –æ–¥–Ω–æ–≥–æ –æ–ª–µ–Ω—è.
         * @param {number} x - –ü–æ–∑–∏—Ü–∏—è X.
         * @param {number} z - –ü–æ–∑–∏—Ü–∏—è Z.
         */
        function createDeer(x, z) {
            const deerGroup = new THREE.Group();
            const deerMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 }); // –ö–æ—Ä–∏—á–Ω–µ–≤—ã–π —Ü–≤–µ—Ç –æ–ª–µ–Ω—è
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.7 }); // –¢–µ–º–Ω–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π –¥–ª—è –Ω–æ–≥

            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.7);
            const body = new THREE.Mesh(bodyGeometry, deerMaterial);
            body.position.y = 0.8; // –ü–æ–¥–Ω—è–ª–∏ —Ç–µ–ª–æ, —á—Ç–æ–±—ã –æ–Ω–æ —Å—Ç–æ—è–ª–æ –Ω–∞ –Ω–æ–≥–∞—Ö
            body.castShadow = true;
            body.receiveShadow = true;
            deerGroup.add(body);

            // –®–µ—è
            const neckGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.5, 8);
            const neck = new THREE.Mesh(neckGeometry, deerMaterial);
            neck.position.set(0.6, 1.2, 0); // –ü–æ–¥–Ω—è–ª–∏ —à–µ—é
            neck.rotation.z = Math.PI / 4;
            neck.castShadow = true;
            neck.receiveShadow = true;
            deerGroup.add(neck);

            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.SphereGeometry(0.3, 12, 12);
            const head = new THREE.Mesh(headGeometry, deerMaterial);
            head.position.set(0.9, 1.5, 0); // –ü–æ–¥–Ω—è–ª–∏ –≥–æ–ª–æ–≤—É
            head.castShadow = true;
            head.receiveShadow = true;
            deerGroup.add(head);

            // –£—à–∏ (–ø—Ä–æ—Å—Ç—ã–µ –ø–ª–æ—Å–∫–æ—Å—Ç–∏)
            const earGeometry = new THREE.PlaneGeometry(0.2, 0.3);
            const earMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, side: THREE.DoubleSide });
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(0.95, 1.7, 0.15); // –ü–æ–¥–Ω—è–ª–∏ —É—à–∏
            leftEar.rotation.y = Math.PI / 4;
            leftEar.rotation.x = -Math.PI / 8;
            leftEar.castShadow = true;
            deerGroup.add(leftEar);
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.95, 1.7, -0.15); // –ü–æ–¥–Ω—è–ª–∏ —É—à–∏
            rightEar.rotation.y = -Math.PI / 4;
            rightEar.rotation.x = -Math.PI / 8;
            rightEar.castShadow = true;
            deerGroup.add(rightEar);

            // –†–æ–≥–∞ (–ø—Ä–æ—Å—Ç—ã–µ —Ü–∏–ª–∏–Ω–¥—Ä—ã)
            const antlerMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.7 });
            const antlerBaseGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.4, 6);
            const antlerBranchGeometry = new THREE.CylinderGeometry(0.03, 0.05, 0.3, 6);

            const leftAntlerBase = new THREE.Mesh(antlerBaseGeometry, antlerMaterial);
            leftAntlerBase.position.set(0.9, 1.8, 0.1); // –ü–æ–¥–Ω—è–ª–∏ —Ä–æ–≥–∞
            leftAntlerBase.rotation.z = Math.PI / 6;
            leftAntlerBase.castShadow = true;
            deerGroup.add(leftAntlerBase);

            const leftAntlerBranch1 = new THREE.Mesh(antlerBranchGeometry, antlerMaterial);
            leftAntlerBranch1.position.set(0.9 + 0.1, 1.8 + 0.2, 0.1 + 0.05); // –ü–æ–¥–Ω—è–ª–∏ –≤–µ—Ç–≤–∏ —Ä–æ–≥–æ–≤
            leftAntlerBranch1.rotation.z = Math.PI / 3;
            leftAntlerBranch1.castShadow = true;
            deerGroup.add(leftAntlerBranch1);

            const rightAntlerBase = new THREE.Mesh(antlerBaseGeometry, antlerMaterial);
            rightAntlerBase.position.set(0.9, 1.8, -0.1); // –ü–æ–¥–Ω—è–ª–∏ —Ä–æ–≥–∞
            rightAntlerBase.rotation.z = Math.PI / 6;
            rightAntlerBase.castShadow = true;
            deerGroup.add(rightAntlerBase);

            const rightAntlerBranch1 = new THREE.Mesh(antlerBranchGeometry, antlerMaterial);
            rightAntlerBranch1.position.set(0.9 + 0.1, 1.8 + 0.2, -0.1 - 0.05);
            rightAntlerBranch1.rotation.z = Math.PI / 3;
            rightAntlerBranch1.castShadow = true;
            deerGroup.add(rightAntlerBranch1);


            // –ù–æ–≥–∏
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8); // –í—ã—Å–æ—Ç–∞ –Ω–æ–≥
            
            const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontLeftLeg.position.set(0.5, 0.4, 0.3); // –ü–æ–∑–∏—Ü–∏—è –Ω–æ–≥ (Y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ - –ø–æ–ª–æ–≤–∏–Ω–∞ –≤—ã—Å–æ—Ç—ã –Ω–æ–≥–∏)
            frontLeftLeg.castShadow = true;
            frontLeftLeg.receiveShadow = true;
            deerGroup.add(frontLeftLeg);

            const frontRightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8), legMaterial);
            frontRightLeg.position.set(0.5, 0.4, -0.3);
            frontRightLeg.castShadow = true;
            frontRightLeg.receiveShadow = true;
            deerGroup.add(frontRightLeg);

            const backLeftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8), legMaterial);
            backLeftLeg.position.set(-0.5, 0.4, 0.3);
            backLeftLeg.castShadow = true;
            backLeftLeg.receiveShadow = true;
            deerGroup.add(backLeftLeg);

            const backRightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8), legMaterial);
            backRightLeg.position.set(-0.5, 0.4, -0.3);
            backRightLeg.castShadow = true;
            backRightLeg.receiveShadow = true;
            deerGroup.add(backRightLeg);

            deerGroup.position.set(x, 0, z);
            deerGroup.rotation.y = Math.random() * Math.PI * 2; // –°–ª—É—á–∞–π–Ω–æ–µ –Ω–∞—á–∞–ª—å–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
            deerGroup.userData.oscillationOffset = Math.random() * Math.PI * 2; // –î–ª—è –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è
            deerGroup.userData.head = head; // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –≥–æ–ª–æ–≤—É –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
            deerGroup.userData.neck = neck; // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —à–µ—é –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏

            scene.add(deerGroup);
            deer.push(deerGroup);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –º–∞–ª–µ–Ω—å–∫–∏–µ —Ü–≤–µ—Ç—ã –≤–æ–∫—Ä—É–≥ –¥–æ–º–∞.
         */
        function createFlowers() {
            const numFlowers = 50;
            const flowerColors = [0xFFC0CB, 0xFFD700, 0x90EE90, 0xADD8E6, 0xFF6347]; // –†–æ–∑–æ–≤—ã–π, –∑–æ–ª–æ—Ç–æ–π, —Å–≤–µ—Ç–ª–æ-–∑–µ–ª–µ–Ω—ã–π, —Å–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–æ–π, —Ç–æ–º–∞—Ç–Ω—ã–π
            const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.7 }); // –¢–µ–º–Ω–æ-–∑–µ–ª–µ–Ω—ã–π
            const petalGeometry = new THREE.SphereGeometry(0.08, 8, 8); // –ú–∞–ª–µ–Ω—å–∫–∞—è —Å—Ñ–µ—Ä–∞ –¥–ª—è –ª–µ–ø–µ—Å—Ç–∫–æ–≤
            const centerGeometry = new THREE.SphereGeometry(0.04, 8, 8); // –ï—â–µ –º–µ–Ω—å—à–µ –¥–ª—è —Ü–µ–Ω—Ç—Ä–∞

            const houseRadius = 5; // –ü—Ä–∏–º–µ—Ä–Ω—ã–π —Ä–∞–¥–∏—É—Å –≤–æ–∫—Ä—É–≥ –¥–æ–º–∞, –≥–¥–µ –±—É–¥—É—Ç —Ü–≤–µ—Ç—ã
            const exclusionBuffer = 1; // –ë—É—Ñ–µ—Ä, —á—Ç–æ–±—ã –Ω–µ –Ω–∞–∫–ª–∞–¥—ã–≤–∞—Ç—å—Å—è –Ω–∞ –¥–æ–º

            for (let i = 0; i < numFlowers; i++) {
                const flowerGroup = new THREE.Group();
                
                let flowerX, flowerZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    flowerX = (Math.random() - 0.5) * houseRadius * 2;
                    flowerZ = (Math.random() - 0.5) * houseRadius * 2;

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –±–ª–∏–∑–∫–æ –∫ –¥–æ–º—É
                    const distanceToHouseCenter = Math.sqrt(
                        Math.pow(flowerX, 2) + Math.pow(flowerZ, 2)
                    );
                    if (distanceToHouseCenter > (2 + exclusionBuffer) && distanceToHouseCenter < houseRadius + exclusionBuffer) { // –ò–∑–±–µ–≥–∞–µ–º –ø—Ä—è–º–æ–≥–æ –Ω–∞–ª–æ–∂–µ–Ω–∏—è –Ω–∞ –¥–æ–º
                        isValidPosition = true;
                    }
                }

                // –°—Ç–µ–±–µ–ª—å
                const stemHeight = 0.2 + Math.random() * 0.2;
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, stemHeight, 4), stemMaterial);
                stem.position.y = stemHeight / 2;
                stem.castShadow = true;
                stem.receiveShadow = true;
                flowerGroup.add(stem);

                // –°–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç –¥–ª—è –ª–µ–ø–µ—Å—Ç–∫–æ–≤
                const petalColor = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                const petalMaterial = new THREE.MeshStandardMaterial({ color: petalColor, roughness: 0.5 });
                const centerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFF000, roughness: 0.5 }); // –ñ–µ–ª—Ç—ã–π —Ü–µ–Ω—Ç—Ä

                // –õ–µ–ø–µ—Å—Ç–∫–∏
                const numPetals = 4 + Math.floor(Math.random() * 3); // 4-6 –ª–µ–ø–µ—Å—Ç–∫–æ–≤
                for (let j = 0; j < numPetals; j++) {
                    const angle = (j / numPetals) * Math.PI * 2;
                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    petal.position.set(
                        Math.cos(angle) * 0.1,
                        stemHeight + 0.05,
                        Math.sin(angle) * 0.1
                    );
                    petal.castShadow = true;
                    flowerGroup.add(petal);
                }

                // –¶–µ–Ω—Ç—Ä —Ü–≤–µ—Ç–∫–∞
                const center = new THREE.Mesh(centerGeometry, centerMaterial);
                center.position.y = stemHeight + 0.05;
                center.castShadow = true;
                flowerGroup.add(center);

                flowerGroup.position.set(flowerX, 0, flowerZ);
                flowerGroup.rotation.y = Math.random() * Math.PI * 2; // –°–ª—É—á–∞–π–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
                flowerGroup.scale.setScalar(0.8 + Math.random() * 0.4); // –°–ª—É—á–∞–π–Ω—ã–π —Ä–∞–∑–º–µ—Ä
                flowerGroup.userData.isCollectible = true;
                flowerGroup.userData.type = 'flower';
                flowerGroup.userData.collectibleAmount = 1;
                collectibleFlowers.push(flowerGroup);
                scene.add(flowerGroup);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —à–µ–∑–ª–æ–Ω–≥.
         * @param {number} x - –ü–æ–∑–∏—Ü–∏—è X.
         * @param {number} y - –ü–æ–∑–∏—Ü–∏—è Y.
         * @param {number} z - –ü–æ–∑–∏—Ü–∏—è Z.
         * @param {number} rotationY - –í—Ä–∞—â–µ–Ω–∏–µ –ø–æ –æ—Å–∏ Y.
         */
        function createSunLounger(x, y, z, rotationY) {
            const loungerGroup = new THREE.Group();
            const woodMaterialLounger = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x8B4513, // Keep the base color for tinting
                roughness: 0.7
            }); // –î–µ—Ä–µ–≤–æ
            const fabricMaterial = new THREE.MeshStandardMaterial({ color: 0xADD8E6, roughness: 0.5 }); // –°–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–∞—è —Ç–∫–∞–Ω—å

            // –°–∏–¥–µ–Ω—å–µ
            const seatGeometry = new THREE.BoxGeometry(1.5, 0.05, 0.6);
            const seat = new THREE.Mesh(seatGeometry, fabricMaterial);
            seat.position.y = 0.2;
            seat.castShadow = true;
            seat.receiveShadow = true;
            loungerGroup.add(seat);

            // –°–ø–∏–Ω–∫–∞ (–ø–æ–¥–Ω—è—Ç–∞—è)
            const backGeometry = new THREE.BoxGeometry(0.6, 0.05, 0.6);
            const back = new THREE.Mesh(backGeometry, fabricMaterial);
            back.position.set(-0.45, 0.35, 0);
            back.rotation.x = Math.PI / 4; // –ù–∞–∫–ª–æ–Ω —Å–ø–∏–Ω–∫–∏
            back.castShadow = true;
            back.receiveShadow = true;
            loungerGroup.add(back);

            // –ù–æ–∂–∫–∏
            const legGeometry = new THREE.BoxGeometry(0.05, 0.2, 0.05);
            const leg1 = new THREE.Mesh(legGeometry, woodMaterialLounger);
            leg1.position.set(0.6, 0.1, 0.25);
            leg1.castShadow = true;
            leg1.receiveShadow = true;
            loungerGroup.add(leg1);
            const leg2 = new THREE.Mesh(legGeometry, woodMaterialLounger);
            leg2.position.set(0.6, 0.1, -0.25);
            leg2.castShadow = true;
            leg2.receiveShadow = true;
            loungerGroup.add(leg2);
            const leg3 = new THREE.Mesh(legGeometry, woodMaterialLounger);
            leg3.position.set(-0.6, 0.1, 0.25);
            leg3.castShadow = true;
            leg3.receiveShadow = true;
            loungerGroup.add(leg3);
            const leg4 = new THREE.Mesh(legGeometry, woodMaterialLounger);
            leg4.position.set(-0.6, 0.1, -0.25);
            leg4.castShadow = true;
            leg4.receiveShadow = true;
            loungerGroup.add(leg4);

            loungerGroup.position.set(x, y, z);
            loungerGroup.rotation.y = rotationY;
            scene.add(loungerGroup);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –ø–ª—è–∂–Ω—ã–π –∑–æ–Ω—Ç–∏–∫.
         * @param {number} x - –ü–æ–∑–∏—Ü–∏—è X.
         * @param {number} y - –ü–æ–∑–∏—Ü–∏—è Y.
         * @param {number} z - –ü–æ–∑–∏—Ü–∏—è Z.
         * @param {number} rotationY - –í—Ä–∞—â–µ–Ω–∏–µ –ø–æ –æ—Å–∏ Y.
         */
        function createUmbrella(x, y, z, rotationY) {
            const umbrellaGroup = new THREE.Group();
            const poleMaterialUmbrella = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x8B4513, // Keep the base color for tinting
                roughness: 0.7
            }); // –î–µ—Ä–µ–≤–æ
            const canopyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.5 }); // –ó–æ–ª–æ—Ç–æ–π/–∂–µ–ª—Ç—ã–π –∫—É–ø–æ–ª

            // –°—Ç–≤–æ–ª
            const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.0, 8);
            const pole = new THREE.Mesh(poleGeometry, poleMaterialUmbrella);
            pole.position.y = 1.0;
            pole.castShadow = true;
            pole.receiveShadow = true;
            umbrellaGroup.add(pole);

            // –ö—É–ø–æ–ª –∑–æ–Ω—Ç–∏–∫–∞ (–∫–æ–Ω—É—Å)
            const canopyGeometry = new THREE.ConeGeometry(1.0, 0.5, 16); // –®–∏—Ä–æ–∫–∏–π, –ø–ª–æ—Å–∫–∏–π –∫–æ–Ω—É—Å
            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
            canopy.position.y = 2.0;
            canopy.castShadow = true;
            canopy.receiveShadow = true;
            umbrellaGroup.add(canopy);

            umbrellaGroup.position.set(x, y, z);
            umbrellaGroup.rotation.y = rotationY;
            scene.add(umbrellaGroup);
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –≥—Ä–∏–±—ã.
         */
        function createMushrooms() {
            const numMushrooms = 30;
            const mushroomCapMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.7 }); // –ö—Ä–∞—Å–Ω–∞—è —à–ª—è–ø–∫–∞
            const mushroomStemMaterial = new THREE.MeshStandardMaterial({ color: 0xFFF5EE, roughness: 0.8 }); // –ë–µ–ª–∞—è –Ω–æ–∂–∫–∞

            for (let i = 0; i < numMushrooms; i++) {
                const mushroomGroup = new THREE.Group();
                let mushroomX, mushroomZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    mushroomX = -forestRange + Math.random() * (forestRange * 2);
                    mushroomZ = -forestRange + Math.random() * (forestRange * 2);

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –±–ª–∏–∑–∫–æ –∫ –¥–æ–º—É, –æ–∑–µ—Ä—É, –¥—Ä—É–≥–∏–º –ø–æ—Å—Ç—Ä–æ–π–∫–∞–º
                    const distanceToHouse = Math.sqrt(Math.pow(mushroomX, 2) + Math.pow(mushroomZ, 2));
                    const distanceToLake = Math.sqrt(Math.pow(mushroomX - lakeCenterX, 2) + Math.pow(mushroomZ - lakeCenterZ, 2));
                    const distanceToBarn = Math.sqrt(Math.pow(mushroomX - (-40), 2) + Math.pow(mushroomZ - 40, 2));
                    const distanceToQuarry = Math.sqrt(Math.pow(mushroomX - 40, 2) + Math.pow(mushroomZ - (-40), 2));

                    if (distanceToHouse > 6 && distanceToLake > (lakeRadius + 6) && distanceToBarn > 6 && distanceToQuarry > 6) {
                        isValidPosition = true;
                    }
                }

                // –ù–æ–∂–∫–∞
                const stemHeight = 0.2 + Math.random() * 0.1;
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.08, stemHeight, 8), mushroomStemMaterial);
                stem.position.y = stemHeight / 2;
                stem.castShadow = true;
                stem.receiveShadow = true;
                mushroomGroup.add(stem);

                // –®–ª—è–ø–∫–∞
                const capRadius = 0.15 + Math.random() * 0.1;
                const cap = new THREE.Mesh(new THREE.SphereGeometry(capRadius, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), mushroomCapMaterial);
                cap.position.y = stemHeight + capRadius / 2 - 0.02; // –ù–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ—Ç –Ω–æ–∂–∫—É
                cap.castShadow = true;
                cap.receiveShadow = true;
                mushroomGroup.add(cap);

                mushroomGroup.position.set(mushroomX, 0, mushroomZ);
                mushroomGroup.rotation.y = Math.random() * Math.PI * 2;
                mushroomGroup.scale.setScalar(0.8 + Math.random() * 0.4);
                mushroomGroup.userData.isCollectible = true;
                mushroomGroup.userData.type = 'mushroom';
                mushroomGroup.userData.collectibleAmount = 1;
                collectibleMushrooms.push(mushroomGroup);
                scene.add(mushroomGroup);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –±–æ–ª—å—à–∏–µ –≤–∞–ª—É–Ω—ã.
         */
        function createBoulders() {
            const numBoulders = 15;
            const boulderMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.9 }); // –¢–µ–º–Ω–æ-—Å–µ—Ä—ã–π

            for (let i = 0; i < numBoulders; i++) {
                let boulderX, boulderZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    boulderX = -forestRange + Math.random() * (forestRange * 2);
                    boulderZ = -forestRange + Math.random() * (forestRange * 2);

                    const distanceToHouse = Math.sqrt(Math.pow(boulderX, 2) + Math.pow(boulderZ, 2));
                    const distanceToLake = Math.sqrt(Math.pow(boulderX - lakeCenterX, 2) + Math.pow(boulderZ - lakeCenterZ, 2));
                    const distanceToBarn = Math.sqrt(Math.pow(boulderX - (-40), 2) + Math.pow(boulderZ - 40, 2));
                    const distanceToQuarry = Math.sqrt(Math.pow(boulderX - 40, 2) + Math.pow(boulderZ - (-40), 2));

                    if (distanceToHouse > 8 && distanceToLake > (lakeRadius + 8) && distanceToBarn > 8 && distanceToQuarry > 8) {
                        isValidPosition = true;
                    }
                }

                const size = 1.5 + Math.random() * 1.5; // –†–∞–∑–º–µ—Ä—ã –æ—Ç 1.5 –¥–æ 3
                const boulderGeometry = new THREE.DodecahedronGeometry(size, 0); // –ë–æ–ª–µ–µ –æ—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∞—è —Ñ–æ—Ä–º–∞
                const boulder = new THREE.Mesh(boulderGeometry, boulderMaterial);
                boulder.position.set(boulderX, size / 2, boulderZ);
                boulder.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                boulder.castShadow = true;
                boulder.receiveShadow = true;
                scene.add(boulder);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —É–ø–∞–≤—à–∏–µ –±—Ä–µ–≤–Ω–∞.
         */
        function createFallenLogs() {
            const numFallenLogs = 20;
            const logMaterialFallen = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0x5C4033, // Keep the base color for tinting
                roughness: 0.8
            }); // –¢–µ–º–Ω–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π

            for (let i = 0; i < numFallenLogs; i++) {
                let logX, logZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    logX = -forestRange + Math.random() * (forestRange * 2);
                    logZ = -forestRange + Math.random() * (forestRange * 2);

                    const distanceToHouse = Math.sqrt(Math.pow(logX, 2) + Math.pow(logZ, 2));
                    const distanceToLake = Math.sqrt(Math.pow(logX - lakeCenterX, 2) + Math.pow(logZ - lakeCenterZ, 2));
                    const distanceToBarn = Math.sqrt(Math.pow(logX - (-40), 2) + Math.pow(logZ - 40, 2));
                    const distanceToQuarry = Math.sqrt(Math.pow(logX - 40, 2) + Math.pow(logZ - (-40), 2));

                    if (distanceToHouse > 5 && distanceToLake > (lakeRadius + 5) && distanceToBarn > 5 && distanceToQuarry > 5) {
                        isValidPosition = true;
                    }
                }

                const length = 2 + Math.random() * 2; // –î–ª–∏–Ω–∞ –æ—Ç 2 –¥–æ 4
                const radius = 0.2 + Math.random() * 0.1; // –†–∞–¥–∏—É—Å –æ—Ç 0.2 –¥–æ 0.3
                const fallenLogGeometry = new THREE.CylinderGeometry(radius, radius, length, 8);
                const fallenLog = new THREE.Mesh(fallenLogGeometry, logMaterialFallen);
                fallenLog.position.set(logX, radius, logZ);
                fallenLog.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI); // –°–ª—É—á–∞–π–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
                fallenLog.castShadow = true;
                fallenLog.receiveShadow = true;
                scene.add(fallenLog);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –Ω–∞–≤–µ—Å.
         * @param {THREE.Vector3} position - –ü–æ–∑–∏—Ü–∏—è –Ω–∞–≤–µ—Å–∞.
         * @param {number} rotationY - –í—Ä–∞—â–µ–Ω–∏–µ –ø–æ –æ—Å–∏ Y.
         */
        function createShelter(position, rotationY) {
            const shelterGroup = new THREE.Group();
            const woodMaterialShelter = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0xA0522D, // Keep the base color for tinting
                roughness: 0.7
            }); // Sienna
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.6 }); // –¢–µ–º–Ω–æ-—Å–µ—Ä—ã–π

            // –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ (—Å—Ç–æ–ª–±—ã)
            const postGeometry = new THREE.CylinderGeometry(0.15, 0.15, 3.0, 8);
            const post1 = new THREE.Mesh(postGeometry, woodMaterialShelter);
            post1.position.set(-2, 1.5, -1.5);
            post1.castShadow = true;
            post1.receiveShadow = true;
            shelterGroup.add(post1);
            const post2 = new THREE.Mesh(postGeometry, woodMaterialShelter);
            post2.position.set(2, 1.5, -1.5);
            post2.castShadow = true;
            post2.receiveShadow = true;
            shelterGroup.add(post2);
            const post3 = new THREE.Mesh(postGeometry, woodMaterialShelter);
            post3.position.set(-2, 1.5, 1.5);
            post3.castShadow = true;
            post3.receiveShadow = true;
            shelterGroup.add(post3);
            const post4 = new THREE.Mesh(postGeometry, woodMaterialShelter);
            post4.position.set(2, 1.5, 1.5);
            post4.castShadow = true;
            post4.receiveShadow = true;
            shelterGroup.add(post4);

            // –ö—Ä—ã—à–∞ (–ø–ª–æ—Å–∫–∞—è)
            const roofGeometry = new THREE.BoxGeometry(5, 0.2, 4);
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 3.0 + 0.1; // –ù–∞–¥ —Å—Ç–æ–ª–±–∞–º–∏
            roof.castShadow = true;
            roof.receiveShadow = true;
            shelterGroup.add(roof);

            shelterGroup.position.copy(position);
            shelterGroup.rotation.y = rotationY;
            scene.add(shelterGroup);
            return shelterGroup;
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç —è–≥–æ–¥–Ω—ã–µ –∫—É—Å—Ç—ã.
         */
        function createBerryBushes() {
            const numBushes = 40;
            const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x32CD32, roughness: 0.7 }); // –ó–µ–ª–µ–Ω—ã–π –∫—É—Å—Ç
            const berryMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.5 }); // –ö—Ä–∞—Å–Ω—ã–µ —è–≥–æ–¥—ã

            const exclusionBuffer = 5; // –ë—É—Ñ–µ—Ä –¥–ª—è –∏–∑–±–µ–≥–∞–Ω–∏—è –ø–æ—Å—Ç—Ä–æ–µ–∫

            for (let i = 0; i < numBushes; i++) {
                const bushGroup = new THREE.Group();
                let bushX, bushZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    bushX = -forestRange + Math.random() * (forestRange * 2);
                    bushZ = -forestRange + Math.random() * (forestRange * 2);

                    const distanceToHouse = Math.sqrt(Math.pow(bushX, 2) + Math.pow(bushZ, 2));
                    const distanceToLake = Math.sqrt(Math.pow(bushX - lakeCenterX, 2) + Math.pow(bushZ - lakeCenterZ, 2));
                    const distanceToBarn = Math.sqrt(Math.pow(bushX - (-40), 2) + Math.pow(bushZ - 40, 2));
                    const distanceToQuarry = Math.sqrt(Math.pow(bushX - 40, 2) + Math.pow(bushZ - (-40), 2));

                    if (distanceToHouse > exclusionBuffer && distanceToLake > (lakeRadius + exclusionBuffer) && distanceToBarn > exclusionBuffer && distanceToQuarry > exclusionBuffer) {
                        isValidPosition = true;
                    }
                }

                // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ–æ—Ä–º–∞ –∫—É—Å—Ç–∞ (–Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ñ–µ—Ä)
                const numBushParts = 2 + Math.floor(Math.random() * 2);
                for (let j = 0; j < numBushParts; j++) {
                    const bushPart = new THREE.Mesh(new THREE.SphereGeometry(0.5 + Math.random() * 0.3, 12, 12), bushMaterial);
                    bushPart.position.set((Math.random() - 0.5) * 0.8, (Math.random() * 0.3), (Math.random() - 0.5) * 0.8);
                    bushPart.castShadow = true;
                    bushPart.receiveShadow = true;
                    bushGroup.add(bushPart);
                }

                // –Ø–≥–æ–¥—ã –Ω–∞ –∫—É—Å—Ç–µ
                const numBerries = 5 + Math.floor(Math.random() * 5);
                for (let k = 0; k < numBerries; k++) {
                    const berry = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), berryMaterial);
                    berry.position.set(
                        (Math.random() - 0.5) * 0.8,
                        0.5 + Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.8
                    );
                    berry.castShadow = true;
                    bushGroup.add(berry);
                }

                bushGroup.position.set(bushX, 0, bushZ);
                bushGroup.scale.setScalar(0.8 + Math.random() * 0.4);
                bushGroup.userData.isCollectible = true;
                bushGroup.userData.type = 'berry';
                bushGroup.userData.collectibleAmount = 3; // 3 —è–≥–æ–¥—ã —Å –∫—É—Å—Ç–∞
                collectibleBerryBushes.push(bushGroup);
                scene.add(bushGroup);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –º–µ—Å—Ç–æ—Ä–æ–∂–¥–µ–Ω–∏—è –º–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–æ–π —Ä—É–¥—ã.
         */
        function createMetalOres() {
            const numOres = 20;
            const oreMaterial = new THREE.MeshStandardMaterial({ color: 0x606060, roughness: 0.9, metalness: 0.7 }); // –°–µ—Ä—ã–π —Å –º–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–º –±–ª–µ—Å–∫–æ–º

            const exclusionBuffer = 8; // –ë—É—Ñ–µ—Ä –¥–ª—è –∏–∑–±–µ–≥–∞–Ω–∏—è –ø–æ—Å—Ç—Ä–æ–µ–∫ –∏ –ª–µ—Å–∞

            for (let i = 0; i < numOres; i++) {
                const oreGroup = new THREE.Group();
                let oreX, oreZ;
                let isValidPosition = false;

                while (!isValidPosition) {
                    oreX = -forestRange + Math.random() * (forestRange * 2);
                    oreZ = -forestRange + Math.random() * (forestRange * 2);

                    const distanceToHouse = Math.sqrt(Math.pow(oreX, 2) + Math.pow(oreZ, 2));
                    const distanceToLake = Math.sqrt(Math.pow(oreX - lakeCenterX, 2) + Math.pow(oreZ - lakeCenterZ, 2));
                    const distanceToBarn = Math.sqrt(Math.pow(oreX - (-40), 2) + Math.pow(oreZ - 40, 2));
                    const distanceToQuarry = Math.sqrt(Math.pow(oreX - 40, 2) + Math.pow(oreZ - (-40), 2));
                    const isNearForest = (oreX >= 60 - exclusionBuffer && oreX <= 90 + exclusionBuffer && oreZ >= -90 - exclusionBuffer && oreZ <= -60 + exclusionBuffer);

                    if (distanceToHouse > exclusionBuffer && distanceToLake > (lakeRadius + exclusionBuffer) && distanceToBarn > exclusionBuffer && distanceToQuarry > exclusionBuffer && !isNearForest) {
                        isValidPosition = true;
                    }
                }

                const size = 0.8 + Math.random() * 0.5;
                const oreGeometry = new THREE.DodecahedronGeometry(size, 0); // –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ñ–æ—Ä–º–∞
                const ore = new THREE.Mesh(oreGeometry, oreMaterial);
                ore.position.y = size / 2;
                ore.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                ore.castShadow = true;
                ore.receiveShadow = true;
                oreGroup.add(ore);

                oreGroup.position.set(oreX, 0, oreZ);
                oreGroup.userData.isCollectible = true;
                oreGroup.userData.type = 'ore';
                oreGroup.userData.collectibleAmount = 2; // 2 —Ä—É–¥—ã —Å –º–µ—Å—Ç–æ—Ä–æ–∂–¥–µ–Ω–∏—è
                collectibleMetalOres.push(oreGroup);
                scene.add(oreGroup);
            }
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –¥–Ω—è/–Ω–æ—á–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ transitionProgress.
         * –í—ã–Ω–µ—Å–µ–Ω–æ –≤ –æ—Ç–¥–µ–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –≤—ã–∑—ã–≤–∞—Ç—å –∫–∞–∫ –∏–∑ animate, —Ç–∞–∫ –∏ –∏–∑ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –ø–æ–ª–∑—É–Ω–∫–∞.
         * @param {number} progress - –ó–Ω–∞—á–µ–Ω–∏–µ –æ—Ç 0 (–Ω–æ—á—å) –¥–æ 1 (–¥–µ–Ω—å).
         */
        function updateDayNightVisuals(progress) {
            const fogColorDay = new THREE.Color(daySettings.fogColor);
            const fogColorNight = new THREE.Color(nightSettings.fogColor);
            scene.fog.color.copy(fogColorNight).lerp(fogColorDay, progress);

            const clearColorDay = new THREE.Color(daySettings.clearColor);
            const clearColorNight = new THREE.Color(nightSettings.clearColor);
            const currentClearColor = new THREE.Color().copy(clearColorNight).lerp(clearColorDay, progress);
            renderer.setClearColor(currentClearColor, 1);

            if (ambientLight) {
                ambientLight.intensity = nightSettings.ambientIntensity + (daySettings.ambientIntensity - nightSettings.ambientIntensity) * progress;
            }
            if (directionalLight) {
                const dirColorDay = new THREE.Color(daySettings.directionalColor);
                const dirColorNight = new THREE.Color(nightSettings.directionalColor);
                directionalLight.color.copy(dirColorNight).lerp(dirColorDay, progress);
                directionalLight.intensity = nightSettings.directionalIntensity + (daySettings.directionalIntensity - nightSettings.directionalIntensity) * progress;
                
                directionalLight.position.x = nightSettings.directionalPosition.x + (daySettings.directionalPosition.x - nightSettings.directionalPosition.x) * progress;
                directionalLight.position.y = nightSettings.directionalPosition.y + (daySettings.directionalPosition.y - nightSettings.directionalPosition.y) * progress;
                directionalLight.position.z = nightSettings.directionalPosition.z + (daySettings.directionalPosition.z - nightSettings.directionalPosition.z) * progress;
            }
            if (hemisphereLight) {
                const hemiSkyColorDay = new THREE.Color(daySettings.hemisphereSkyColor);
                const hemiSkyColorNight = new THREE.Color(nightSettings.hemisphereSkyColor);
                hemisphereLight.color.copy(hemiSkyColorNight).lerp(hemiSkyColorDay, progress);

                const hemiGroundColorDay = new THREE.Color(daySettings.hemisphereGroundColor);
                const hemiGroundColorNight = new THREE.Color(nightSettings.hemisphereGroundColor);
                hemisphereLight.groundColor.copy(hemiGroundColorNight).lerp(hemiGroundColorDay, progress);
                hemisphereLight.intensity = nightSettings.hemisphereIntensity + (daySettings.hemisphereIntensity - nightSettings.hemisphereIntensity) * progress;
            }

            windowLights.forEach(light => {
                light.intensity = nightSettings.windowLightIntensity * (1 - progress);
            });
            barnLights.forEach(light => {
                light.intensity = nightSettings.windowLightIntensity * (1 - progress);
            });
            quarryLights.forEach(light => {
                light.intensity = nightSettings.windowLightIntensity * (1 - progress);
            });

            fireflies.forEach(firefly => {
                firefly.material.opacity = (1 - progress) * 0.8;
            });

            const dayNightIcon = document.getElementById('dayNightIcon');
            if (progress > 0.5) {
                dayNightIcon.textContent = '‚òÄÔ∏è';
                isDayTime = true;
            } else {
                dayNightIcon.textContent = 'üåô';
                isDayTime = false;
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–æ–∂–µ–Ω–∏–µ –ø–æ–ª–∑—É–Ω–∫–∞, –µ—Å–ª–∏ –æ–Ω –Ω–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ—Ç—Å—è
            const dayNightSlider = document.getElementById('dayNightSlider');
            if (dayNightSlider && !isSliderDragging) {
                dayNightSlider.value = progress * 100;
            }
        }


        /**
         * –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –∞–Ω–∏–º–∞—Ü–∏–∏.
         */
        function animate() {
            requestAnimationFrame(animate);

            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å–º–µ–Ω–∞ –¥–Ω—è/–Ω–æ—á–∏, –µ—Å–ª–∏ –ø–æ–ª–∑—É–Ω–æ–∫ –Ω–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ—Ç—Å—è
            if (!isManualTimeControl) { // –ò—Å–ø–æ–ª—å–∑—É–µ–º isManualTimeControl
                const timeInCycle = Date.now() % dayNightCycleDuration;
                transitionProgress = (Math.sin(timeInCycle * Math.PI / halfDayNightCycle + Math.PI / 2) + 1) / 2;
            }
            
            updateDayNightVisuals(transitionProgress); // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã

            updatePlayer();

            const cameraOffset = new THREE.Vector3(
                Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance,
                Math.sin(cameraAngleX) * cameraDistance + 3,
                Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance
            );

            camera.position.copy(playerPosition).add(cameraOffset);
            camera.lookAt(playerPosition.x, playerPosition.y + 1, playerPosition.z);

            // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü –¥—ã–º–∞
            particles.forEach((particle, idx) => { 
                particle.position.add(particle.userData.velocity);
                particle.userData.life += 0.01;

                if (particle.userData.life > 1 || particle.position.y > 15) {
                    particle.position.set(-1.2, 5.2 + idx * 0.3, -1.2); 
                    particle.userData.life = 0;
                    particle.userData.velocity.set(
                        (Math.random() - 0.5) * 0.02,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.02
                    );
                }

                particle.material.opacity = 0.6 * (1 - particle.userData.life);
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è —Ä—ã–±—ã
            const currentLakeRadius = lakeRadius; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
            fish.forEach(f => {
                f.position.add(f.userData.velocity);
                
                const distanceToCenter = f.position.distanceTo(new THREE.Vector3(lakeCenterX, f.position.y, lakeCenterZ));
                if (distanceToCenter > currentLakeRadius * 1.2) { 
                    const directionToCenter = new THREE.Vector3().subVectors(new THREE.Vector3(lakeCenterX, f.position.y, lakeCenterZ), f.position).normalize();
                    f.userData.velocity.copy(directionToCenter).multiplyScalar(0.025 + Math.random() * 0.01); 
                    
                    f.userData.velocity.x += (Math.random() - 0.5) * 0.005; 
                    f.userData.velocity.z += (Math.random() - 0.5) * 0.005; 
                    f.userData.velocity.normalize().multiplyScalar(0.025); 
                }

                f.position.y += Math.sin(f.userData.swimCycle) * 0.005; 
                f.userData.swimCycle += 0.05;

                f.rotation.y = Math.atan2(f.userData.velocity.x, f.userData.velocity.z);
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –∫—Ä–æ–ª–∏–∫–æ–≤ (–ø–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –≤–ø–µ—Ä–µ–¥/–Ω–∞–∑–∞–¥ –∏ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ)
            rabbits.forEach(rabbit => {
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é Z-–ø–æ–∑–∏—Ü–∏—é –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∏–Ω—É—Å–æ–∏–¥—ã –¥–ª—è –ø–ª–∞–≤–Ω–æ–π –æ—Å—Ü–∏–ª–ª—è—Ü–∏–∏
                const newZ = rabbit.userData.initialPosition.z + Math.sin(Date.now() * rabbit.userData.oscillationSpeed + rabbit.userData.oscillationOffset) * rabbit.userData.oscillationAmplitude;
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è
                const prevZ = rabbit.position.z;
                rabbit.position.z = newZ;

                // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∫—Ä–æ–ª–∏–∫–∞ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è
                // –ï—Å–ª–∏ –¥–≤–∏–∂–µ—Ç—Å—è –≤–ø–µ—Ä–µ–¥ (newZ > prevZ), –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É, –∏–Ω–∞—á–µ –≤ –¥—Ä—É–≥—É—é
                if (newZ > prevZ) { 
                    rabbit.rotation.y = rabbit.userData.initialRotationY; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –≤–ø–µ—Ä–µ–¥
                } else { 
                    rabbit.rotation.y = rabbit.userData.initialRotationY + Math.PI; // –î–æ–±–∞–≤–ª—è–µ–º PI –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –Ω–∞–∑–∞–¥
                }

                // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∑–µ–º–ª–∏ (y=0)
                rabbit.position.y = Math.sin(Date.now() * 0.005 + rabbit.userData.offset) * 0.05; 
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –æ–ª–µ–Ω–µ–π (–ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ –≥–æ–ª–æ–≤–æ–π/—à–µ–µ–π)
            deer.forEach(d => {
                // –ù–µ–±–æ–ª—å—à–æ–µ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ –≥–æ–ª–æ–≤–æ–π
                if (d.userData.head) {
                    d.userData.head.rotation.y = Math.sin(Date.now() * 0.002 + d.userData.oscillationOffset) * 0.1;
                }
                // –ù–µ–±–æ–ª—å—à–æ–µ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ —à–µ–µ–π
                if (d.userData.neck) {
                    d.userData.neck.rotation.y = Math.sin(Date.now() * 0.0025 + d.userData.oscillationOffset + 0.5) * 0.05;
                }
            });


            // –ê–Ω–∏–º–∞—Ü–∏—è –æ–±–ª–∞–∫–æ–≤
            clouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speed;
                // –ó–∞–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –æ–±–ª–∞–∫–∞ –≤–æ–∫—Ä—É–≥ –º–∏—Ä–∞
                if (cloud.position.x > forestRange + 10) cloud.position.x = -forestRange - 10; 
                if (cloud.position.x < -forestRange - 10) cloud.position.x = forestRange + 10; 
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –ø—Ç–∏—Ü—ã
            if (bird) {
                bird.userData.flightAngle += bird.userData.flightSpeed;
                bird.position.x = bird.userData.flightRadius * Math.cos(bird.userData.flightAngle);
                bird.position.z = bird.userData.flightRadius * Math.sin(bird.userData.flightAngle);
                bird.rotation.y = -bird.userData.flightAngle + Math.PI / 2; // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ø—Ç–∏—Ü—É –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é –ø–æ–ª–µ—Ç–∞

                // –ê–Ω–∏–º–∞—Ü–∏—è –º–∞—Ö–∞ –∫—Ä—ã–ª—å—è–º–∏
                const wingAngle = Math.sin(Date.now() * bird.userData.wingFlapSpeed) * bird.userData.wingFlapAmplitude;
                if (bird.userData.leftWing) bird.userData.leftWing.rotation.x = Math.PI / 4 + wingAngle;
                if (bird.userData.rightWing) bird.userData.rightWing.rotation.x = -Math.PI / 4 - wingAngle; 
            }

            // –ê–Ω–∏–º–∞—Ü–∏—è —Å–≤–µ—Ç–ª—è—á–∫–æ–≤
            fireflies.forEach(firefly => {
                // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
                firefly.position.x = firefly.userData.initialPosition.x + Math.sin(Date.now() * firefly.userData.speed + firefly.userData.offset) * 0.5;
                firefly.position.y = firefly.userData.initialPosition.y + Math.cos(Date.now() * firefly.userData.speed * 0.8 + firefly.userData.offset) * 0.3;
                firefly.position.z = firefly.userData.initialPosition.z + Math.sin(Date.now() * firefly.userData.speed * 1.2 + firefly.userData.offset) * 0.5;

                // –ú–µ—Ä—Ü–∞–Ω–∏–µ (—Ç–æ–ª—å–∫–æ –Ω–æ—á—å—é)
                if (!isDayTime) {
                    firefly.material.opacity = 0.5 + Math.sin(Date.now() * 0.01 + firefly.userData.offset) * 0.5;
                } else {
                    firefly.material.opacity = 0; // –°–≤–µ—Ç–ª—è—á–∫–∏ –Ω–µ–≤–∏–¥–∏–º—ã –¥–Ω–µ–º
                }
            });


            house.rotation.y = Math.sin(Date.now() * 0.0005) * 0.02;

            renderer.render(scene, camera);
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç –ø–æ–∑–∏—Ü–∏—é –∏ –≤—Ä–∞—â–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–≤–æ–¥–∞ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã.
         */
        function updatePlayer() {
            let isMoving = false;
            const speed = keys['ShiftLeft'] || keys['ShiftRight'] ? 0.3 : 0.08; // Doubled running speed
            const moveDirection = new THREE.Vector3(); 
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection); 

            // –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
            cameraDirection.y = 0;
            cameraDirection.normalize();

            const cameraRight = new THREE.Vector3();
            // –í–µ–∫—Ç–æ—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞ "–≤–≤–µ—Ä—Ö" –∫–∞–º–µ—Ä—ã –∏ –≤–µ–∫—Ç–æ—Ä–∞ "–≤–ø–µ—Ä–µ–¥" –¥–∞–µ—Ç –≤–µ–∫—Ç–æ—Ä "–≤–ø—Ä–∞–≤–æ"
            cameraRight.crossVectors(camera.up, cameraDirection); 
            cameraRight.normalize();

            // –í—ã—á–∏—Å–ª—è–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–∂–∞—Ç—ã—Ö –∫–ª–∞–≤–∏—à –∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ –∫–∞–º–µ—Ä—ã
            if (keys['KeyW'] || keys['ArrowUp']) {
                moveDirection.add(cameraDirection);
                isMoving = true;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                moveDirection.sub(cameraDirection);
                isMoving = true;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                moveDirection.add(cameraRight); // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞–º–µ—Ä—ã
                isMoving = true;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                moveDirection.sub(cameraRight); // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ª–µ–≤–æ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞–º–µ—Ä—ã
                isMoving = true;
            }

            if (isMoving) {
                moveDirection.normalize().multiplyScalar(speed);
                playerPosition.add(moveDirection);

                // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞, —á—Ç–æ–±—ã –æ–Ω —Å–º–æ—Ç—Ä–µ–ª –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è
                if (Math.abs(moveDirection.x) > 0.0001 || Math.abs(moveDirection.z) > 0.0001) {
                    player.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);
                }

                walkAnimation += 0.2;
                if (player.userData.leftLeg && player.userData.rightLeg) {
                    player.userData.leftLeg.rotation.x = Math.sin(walkAnimation) * 0.3;
                    player.userData.rightLeg.rotation.x = -Math.sin(walkAnimation) * 0.3;
                }
            } else {
                if (player.userData.leftLeg && player.userData.rightLeg) {
                    player.userData.leftLeg.rotation.x = 0;
                    player.userData.rightLeg.rotation.x = 0;
                }
            }

            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∏–≥—Ä–æ–∫–∞ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –≥—Ä–∞–Ω–∏—Ü —Å—Ü–µ–Ω—ã
            playerPosition.x = Math.max(-forestRange, Math.min(forestRange, playerPosition.x)); 
            playerPosition.z = Math.max(-forestRange, Math.min(forestRange, playerPosition.z)); 

            player.position.copy(playerPosition);
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è.
         */
        function updateInventoryUI() {
            const inventoryList = document.getElementById('inventory-list');
            inventoryList.innerHTML = ''; // –û—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫

            for (const itemType in playerInventory) {
                if (playerInventory[itemType] > 0) {
                    const listItem = document.createElement('li');
                    let itemName = itemType;
                    // –ü–µ—Ä–µ–≤–æ–¥–∏–º –Ω–∞–∑–≤–∞–Ω–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                    switch(itemType) {
                        case 'log': itemName = '–ë—Ä–µ–≤–Ω–∞'; break;
                        case 'stone': itemName = '–ö–∞–º–Ω–∏'; break;
                        case 'berry': itemName = '–Ø–≥–æ–¥—ã'; break;
                        case 'flower': itemName = '–¶–≤–µ—Ç—ã'; break;
                        case 'mushroom': itemName = '–ì—Ä–∏–±—ã'; break;
                        case 'ore': itemName = '–†—É–¥–∞'; break;
                        case 'plank': itemName = '–î–æ—Å–∫–∏'; break;
                        case 'brick': itemName = '–ö–∏—Ä–ø–∏—á–∏'; break;
                        case 'small-wall': itemName = '–ú–∞–ª—ã–µ —Å—Ç–µ–Ω—ã'; break;
                        case 'basic-pickaxe': itemName = '–ë–∞–∑–æ–≤–∞—è –∫–∏—Ä–∫–∞'; break;
                    }
                    listItem.textContent = `${itemName}: ${playerInventory[itemType]}`;
                    inventoryList.appendChild(listItem);
                }
            }
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Å—á–µ—Ç—á–∏–∫–∏ (–º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å, –µ—Å–ª–∏ –æ–Ω–∏ –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω—ã)
            document.getElementById('collectedLogsCount').textContent = playerInventory.log;
            document.getElementById('collectedStonesCount').textContent = playerInventory.stone;
        }

        /**
         * –ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –≤–∏–¥–∏–º–æ—Å—Ç—å –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è.
         */
        function toggleInventory() {
            const inventoryUI = document.getElementById('inventory-ui');
            const craftingUI = document.getElementById('crafting-ui');

            if (inventoryUI.style.display === 'block') {
                inventoryUI.style.display = 'none';
            } else {
                inventoryUI.style.display = 'block';
                craftingUI.style.display = 'none'; // –ó–∞–∫—Ä—ã–≤–∞–µ–º –∫—Ä–∞—Ñ—Ç, –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç
                updateInventoryUI(); // –û–±–Ω–æ–≤–ª—è–µ–º UI –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏
            }
        }

        /**
         * –ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –≤–∏–¥–∏–º–æ—Å—Ç—å –º–µ–Ω—é –∫—Ä–∞—Ñ—Ç–∞.
         */
        function toggleCrafting() {
            const craftingUI = document.getElementById('crafting-ui');
            const inventoryUI = document.getElementById('inventory-ui');

            if (craftingUI.style.display === 'flex') {
                craftingUI.style.display = 'none';
            } else {
                craftingUI.style.display = 'flex';
                inventoryUI.style.display = 'none'; // –ó–∞–∫—Ä—ã–≤–∞–µ–º –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å, –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç
                updateCraftingRecipesUI(); // –û–±–Ω–æ–≤–ª—è–µ–º UI —Ä–µ—Ü–µ–ø—Ç–æ–≤ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏
            }
        }

        /**
         * –ó–∞–∫—Ä—ã–≤–∞–µ—Ç –º–µ–Ω—é –∫—Ä–∞—Ñ—Ç–∞.
         */
        function closeCraftingMenu() {
            document.getElementById('crafting-ui').style.display = 'none';
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–µ—Ü–µ–ø—Ç–æ–≤ –∫—Ä–∞—Ñ—Ç–∞ –∏ –∏—Ö –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å.
         */
        function updateCraftingRecipesUI() {
            const craftingRecipesDiv = document.getElementById('crafting-recipes');
            craftingRecipesDiv.innerHTML = ''; // –û—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫

            craftingRecipes.forEach(recipe => {
                const recipeDiv = document.createElement('div');
                recipeDiv.className = 'crafting-recipe';

                const recipeHeader = document.createElement('div');
                recipeHeader.className = 'recipe-header';
                recipeHeader.innerHTML = `<strong>${recipe.name}</strong><span>x${recipe.output.amount}</span>`;
                recipeDiv.appendChild(recipeHeader);

                const ingredientsList = document.createElement('div');
                ingredientsList.className = 'recipe-ingredients';
                let ingredientsText = '–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã: ';
                let canCraft = true;
                for (const ingredient in recipe.ingredients) {
                    const required = recipe.ingredients[ingredient];
                    const possessed = playerInventory[ingredient] || 0;
                    let ingredientName = ingredient;
                    switch(ingredient) {
                        case 'log': ingredientName = '–ë—Ä–µ–≤–Ω–æ'; break;
                        case 'stone': ingredientName = '–ö–∞–º–µ–Ω—å'; break;
                        case 'plank': ingredientName = '–î–æ—Å–∫–∞'; break;
                        case 'brick': ingredientName = '–ö–∏—Ä–ø–∏—á'; break;
                        case 'berry': ingredientName = '–Ø–≥–æ–¥–∞'; break;
                        case 'flower': ingredientName = '–¶–≤–µ—Ç–æ–∫'; break;
                        case 'mushroom': ingredientName = '–ì—Ä–∏–±'; break;
                        case 'ore': ingredientName = '–†—É–¥–∞'; break;
                    }
                    ingredientsText += `${ingredientName} (${possessed}/${required}) `;
                    if (possessed < required) {
                        canCraft = false;
                    }
                }
                ingredientsList.textContent = ingredientsText;
                recipeDiv.appendChild(ingredientsList);

                const craftButton = document.createElement('button');
                craftButton.className = 'craft-button';
                craftButton.textContent = '–°–æ–∑–¥–∞—Ç—å';
                craftButton.disabled = !canCraft;
                craftButton.onclick = () => craftItem(recipe.id);
                recipeDiv.appendChild(craftButton);

                craftingRecipesDiv.appendChild(recipeDiv);
            });
        }

        /**
         * –í—ã–ø–æ–ª–Ω—è–µ—Ç –∫—Ä–∞—Ñ—Ç –ø—Ä–µ–¥–º–µ—Ç–∞.
         * @param {string} recipeId - ID —Ä–µ—Ü–µ–ø—Ç–∞ –¥–ª—è –∫—Ä–∞—Ñ—Ç–∞.
         */
        function craftItem(recipeId) {
            const recipe = craftingRecipes.find(r => r.id === recipeId);
            if (!recipe) {
                console.error('–†–µ—Ü–µ–ø—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω:', recipeId);
                return;
            }

            let canCraft = true;
            for (const ingredient in recipe.ingredients) {
                if ((playerInventory[ingredient] || 0) < recipe.ingredients[ingredient]) {
                    canCraft = false;
                    break;
                }
            }

            if (canCraft) {
                for (const ingredient in recipe.ingredients) {
                    playerInventory[ingredient] -= recipe.ingredients[ingredient];
                }
                playerInventory[recipe.output.type] = (playerInventory[recipe.output.type] || 0) + recipe.output.amount;
                console.log(`–°–æ–∑–¥–∞–Ω ${recipe.name}! –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å:`, playerInventory);

                // –ï—Å–ª–∏ —Å–∫—Ä–∞—Ñ—á–µ–Ω –ø—Ä–µ–¥–º–µ—Ç, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –¥–µ—Ä–∂–∞—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å—Ç–µ–Ω–∞), –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –≤ —Ä—É–∫—É
                if (recipe.output.type === 'plank') {
                    if (!playerHasResource) {
                        currentHeldResource = createCraftedPlank();
                        player.userData.hand.add(currentHeldResource);
                        playerHasResource = true;
                        currentResourceType = 'plank';
                        playerInventory.plank--; // –í—ã—á–∏—Ç–∞–µ–º –∏–∑ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è, —Ç–∞–∫ –∫–∞–∫ —Ç–µ–ø–µ—Ä—å –æ–Ω –≤ —Ä—É–∫–µ
                    }
                } else if (recipe.output.type === 'brick') {
                    if (!playerHasResource) {
                        currentHeldResource = createCraftedBrick();
                        player.userData.hand.add(currentHeldResource);
                        playerHasResource = true;
                        currentResourceType = 'brick';
                        playerInventory.brick--;
                    }
                } else if (recipe.output.type === 'small-wall') {
                    if (!playerHasResource) {
                        currentHeldResource = createCraftedSmallWall();
                        player.userData.hand.add(currentHeldResource);
                        playerHasResource = true;
                        currentResourceType = 'small-wall';
                        playerInventory['small-wall']--;
                    }
                }
                // –î–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ (–∫–∞–∫ –∫–∏—Ä–∫–∞), –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å, –Ω–µ –≤ —Ä—É–∫—É
                // –ï—Å–ª–∏ –∑–∞—Ö–æ—Ç–∏–º, –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–ª–æ—Ç –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –µ–≥–æ "—ç–∫–∏–ø–∏—Ä–æ–≤–∞—Ç—å"

                updateInventoryUI();
                updateCraftingRecipesUI();
            } else {
                console.log('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ä–µ—Å—É—Ä—Å–æ–≤ –¥–ª—è –∫—Ä–∞—Ñ—Ç–∞:', recipe.name);
            }
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –º–µ—à —Å–∫—Ä–∞—Ñ—á–µ–Ω–Ω–æ–π –¥–æ—Å–∫–∏.
         * @returns {THREE.Mesh} –ú–µ—à –¥–æ—Å–∫–∏.
         */
        function createCraftedPlank() {
            const plankGeometry = new THREE.BoxGeometry(1.0, 0.15, 0.3); // –î–ª–∏–Ω–∞, —Ç–æ–ª—â–∏–Ω–∞, —à–∏—Ä–∏–Ω–∞
            const plankMaterial = new THREE.MeshStandardMaterial({
                map: woodDiffuseTexture,
                bumpMap: woodBumpTexture,
                color: 0xdeb887, // –ë–æ–ª–µ–µ —Å–≤–µ—Ç–ª—ã–π —Ü–≤–µ—Ç –¥–µ—Ä–µ–≤–∞
                roughness: 0.6
            });
            const plank = new THREE.Mesh(plankGeometry, plankMaterial);
            plank.castShadow = true;
            plank.receiveShadow = true;
            plank.userData.type = 'plank';
            return plank;
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –º–µ—à —Å–∫—Ä–∞—Ñ—á–µ–Ω–Ω–æ–≥–æ –∫–∏—Ä–ø–∏—á–∞.
         * @returns {THREE.Mesh} –ú–µ—à –∫–∏—Ä–ø–∏—á–∞.
         */
        function createCraftedBrick() {
            const brickGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.25);
            const brickMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
            const brick = new THREE.Mesh(brickGeometry, brickMaterial);
            brick.castShadow = true;
            brick.receiveShadow = true;
            brick.userData.type = 'brick';
            return brick;
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –º–µ—à —Å–∫—Ä–∞—Ñ—á–µ–Ω–Ω–æ–π –º–∞–ª–æ–π —Å—Ç–µ–Ω—ã.
         * @returns {THREE.Mesh} –ú–µ—à –º–∞–ª–æ–π —Å—Ç–µ–Ω—ã.
         */
        function createCraftedSmallWall() {
            const wallGeometry = new THREE.BoxGeometry(2.0, 1.0, 0.2);
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xdeb887, roughness: 0.7 }); // –¶–≤–µ—Ç –∫–∞–∫ —É –¥–æ—Å–æ–∫
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.castShadow = true;
            wall.receiveShadow = true;
            wall.userData.type = 'small-wall';
            return wall;
        }


        // --- –§—É–Ω–∫—Ü–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ---
        // –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑, –∫–æ–≥–¥–∞ –æ–∫–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≥—Ä—É–∑–∏—Ç—Å—è.
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(daySettings.fogColor, 20, 200); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(daySettings.clearColor, 1); 
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('container').appendChild(renderer.domElement);

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑—á–∏–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä –∏ –∑–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
            textureLoader = new THREE.TextureLoader();

            grassTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(50, 50);
            });
            grassNormalMap = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big-normal.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(50, 50);
            });

            woodDiffuseTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(2, 2);
            });
            woodBumpTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_bump.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(2, 2);
            });

            // –°–æ–∑–¥–∞–µ–º –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å—Ü–µ–Ω—ã
            createHouse();
            createPlayer();
            createGround();
            createTrees(); // –¢–µ–ø–µ—Ä—å —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–µ—Ç –≤—Å–µ –ª–∏—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏ –µ–ª–æ–≤—ã–µ –¥–µ—Ä–µ–≤—å—è –∫–∞–∫ —Å–æ–±–∏—Ä–∞–µ–º—ã–µ
            createRocks(); // –¢–µ–ø–µ—Ä—å —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–µ—Ç –≤—Å–µ –∫–∞–º–Ω–∏ –∫–∞–∫ —Å–æ–±–∏—Ä–∞–µ–º—ã–µ
            createLake();   
            createSmokeParticles();
            createLakeVegetation(); 
            createPierAndBoat(); 
            createFence(); 
            createRabbits(); 
            createClouds(); // –î–æ–±–∞–≤–ª—è–µ–º –æ–±–ª–∞–∫–∞
            createMailbox(); // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—á—Ç–æ–≤—ã–π —è—â–∏–∫
            createPath(); // –î–æ–±–∞–≤–ª—è–µ–º –¥–æ—Ä–æ–∂–∫—É
            createBench(); // –î–æ–±–∞–≤–ª—è–µ–º —Å–∫–∞–º–µ–π–∫—É
            createLilyPads(); // –î–æ–±–∞–≤–ª—è–µ–º –∫—É–≤—à–∏–Ω–∫–∏
            createBird(); // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ç–∏—Ü—É
            createFireflies(); // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—Ç–ª—è—á–∫–æ–≤
            createDenseForestWithDeer(); // –°–æ–∑–¥–∞–µ–º –≥—É—Å—Ç–æ–π –ª–µ—Å —Å –æ–ª–µ–Ω—è–º–∏
            createFlowers(); // –°–æ–∑–¥–∞–µ–º —Ü–≤–µ—Ç—ã (—Ç–µ–ø–µ—Ä—å —Å–æ–±–∏—Ä–∞–µ–º—ã–µ)
            createMushrooms(); // –î–æ–±–∞–≤–ª—è–µ–º –≥—Ä–∏–±—ã (—Ç–µ–ø–µ—Ä—å —Å–æ–±–∏—Ä–∞–µ–º—ã–µ)
            createBerryBushes(); // –î–æ–±–∞–≤–ª—è–µ–º —è–≥–æ–¥–Ω—ã–µ –∫—É—Å—Ç—ã
            createMetalOres(); // –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Å—Ç–æ—Ä–æ–∂–¥–µ–Ω–∏—è —Ä—É–¥—ã

            // –°–æ–∑–¥–∞–µ–º —Å–∞—Ä–∞–π—á–∏–∫ (–ª–µ—Å–æ–ø–∏–ª–∫—É)
            const barn = createBarn();
            // –°–æ–∑–¥–∞–µ–º –ø–æ–ª–µ–Ω–Ω–∏—Ü—É —É —Å–∞—Ä–∞–π—á–∏–∫–∞ (–ª–µ—Å–æ–ø–∏–ª–∫–∏)
            createFirewoodPile(barn);
            // –°–æ–∑–¥–∞–µ–º –Ω–∞–≤–µ—Å –Ω–∞–¥ –ø–æ–ª–µ–Ω–Ω–∏—Ü–µ–π
            createShelter(new THREE.Vector3(barn.position.x + 3.5, 0, barn.position.z + 0.5), Math.PI / 6);


            // –°–æ–∑–¥–∞–µ–º –∫–∞–º–µ–Ω–æ–ª–æ–º–Ω—é –∏ –∫—É—á—É –∫–∞–º–Ω–µ–π
            const quarry = createQuarry();
            createStoneDropOffPile(quarry);
            // –°–æ–∑–¥–∞–µ–º –Ω–∞–≤–µ—Å –Ω–∞–¥ –∫—É—á–µ–π –∫–∞–º–Ω–µ–π
            createShelter(new THREE.Vector3(quarry.position.x - 3.5, 0, quarry.position.z - 0.5), -Math.PI / 4);

            // –î–æ–±–∞–≤–ª—è–µ–º —à–µ–∑–ª–æ–Ω–≥ –∏ –∑–æ–Ω—Ç–∏–∫ –≤–æ–∑–ª–µ –æ–∑–µ—Ä–∞
            // –ü–æ–∑–∏—Ü–∏—è —à–µ–∑–ª–æ–Ω–≥–∞ –∏ –∑–æ–Ω—Ç–∏–∫–∞ —Ç–µ–ø–µ—Ä—å –∑–∞ –∫–∞–º—ã—à–∞–º–∏
            createSunLounger(lakeCenterX + lakeRadius + lakeReedsOffset + sunLoungerOffset, 0, lakeCenterZ + 5, Math.PI / 4); 
            createUmbrella(lakeCenterX + lakeRadius + lakeReedsOffset + sunLoungerOffset, 0, lakeCenterZ + 5, Math.PI / 4); 

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –æ—Å–≤–µ—â–µ–Ω–∏–µ (—Å–æ–∑–¥–∞–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞)
            initializeLighting(); 
            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            setupControls();

            // –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–Ω—è/–Ω–æ—á–∏
            // –ü–æ—Å–∫–æ–ª—å–∫—É —Ü–∏–∫–ª –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π, –ø—Ä–æ—Å—Ç–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∫–æ–Ω–∫–∏
            const dayNightIcon = document.getElementById('dayNightIcon');
            dayNightIcon.textContent = '‚òÄÔ∏è'; // –ù–∞—á–∏–Ω–∞–µ–º —Å –¥–Ω—è

            updateInventoryUI(); // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ

            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ü–∏–∫–ª –∞–Ω–∏–º–∞—Ü–∏–∏
            animate();
        }

        // –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ init –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –æ–∫–Ω–∞ (–≤–∫–ª—é—á–∞—è –≤—Å–µ —Å–∫—Ä–∏–ø—Ç—ã)
        window.onload = function() {
            init();
        }; 
    </script>
</body>
</html>

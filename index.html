<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –î–æ–º–∏–∫</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        #controls h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }

        #controls p {
            margin: 5px 0;
            color: #666;
            font-size: 12px;
        }

        .key {
            display: inline-block;
            background: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 0 2px;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-width: 250px;
        }

        #info h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }

        #info p {
            margin: 5px 0;
            color: #666;
            font-size: 12px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>üè† –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
            <p>üñ±Ô∏è –ú—ã—à—å: –ø–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</p>
            <p>üîÑ –ö–æ–ª–µ—Å–æ: –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ</p>
            <p>üåô –ö–ª–∏–∫: –¥–µ–Ω—å/–Ω–æ—á—å</p>
            <p>üö∂ <span class="key">WASD</span> –∏–ª–∏ <span class="key">‚Üë‚Üì‚Üê‚Üí</span>: –¥–≤–∏–∂–µ–Ω–∏–µ</p>
            <p>üèÉ <span class="key">Shift</span>: –±–µ–≥</p>
        </div>

        <div id="info">
            <h3>üåü 3D –î–æ–º–∏–∫</h3>
            <p>–£—é—Ç–Ω—ã–π –¥–æ–º–∏–∫ —Å –∫—Ä–∞—Å–Ω–æ–π –∫—Ä—ã—à–µ–π, –¥–≤–µ—Ä—å—é –∏ –æ–∫–æ—à–∫–∞–º–∏.</p>
            <p>–£–ø—Ä–∞–≤–ª—è–π—Ç–µ —á–µ–ª–æ–≤–µ—á–∫–æ–º –∏ –∏—Å—Å–ª–µ–¥—É–π—Ç–µ –º–∏—Ä!</p>
            <p>–©–µ–ª–∫–Ω–∏—Ç–µ –º—ã—à–∫–æ–π –¥–ª—è —Å–º–µ–Ω—ã –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫!</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, house, particles = [], player;
        let isMouseDown = false, mouseX = 0, mouseY = 0;
        let cameraAngleX = 0.3, cameraAngleY = 0;
        let cameraDistance = 10;
        let isDayTime = true;
        let keys = {};
        let playerPosition = new THREE.Vector3(0, 0, 6);
        let playerRotation = 0;
        let walkAnimation = 0;

        function init() {
            // –°—Ü–µ–Ω–∞
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

            // –ö–∞–º–µ—Ä–∞
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // –†–µ–Ω–¥–µ—Ä–µ—Ä
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            createHouse();
            createPlayer();
            createGround();
            createTrees();
            createSmokeParticles();
            setupLighting();
            setupControls();

            animate();
        }

        function createHouse() {
            house = new THREE.Group();

            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ –¥–æ–º–∞
            const wallGeometry = new THREE.BoxGeometry(4, 3, 4);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xF5DEB3 });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 1.5;
            walls.castShadow = true;
            walls.receiveShadow = true;
            house.add(walls);

            // –ö—Ä—ã—à–∞
            const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 4;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            house.add(roof);

            // –î–≤–µ—Ä—å
            const doorGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.1);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x4A4A4A });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.9, 2.05);
            house.add(door);

            // –†—É—á–∫–∞ –¥–≤–µ—Ä–∏
            const handleGeometry = new THREE.SphereGeometry(0.05);
            const handleMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(-0.3, 0.9, 2.1);
            house.add(handle);

            // –û–∫–Ω–∞
            const windowGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.1);
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB });

            // –ü–µ—Ä–µ–¥–Ω–µ–µ –æ–∫–Ω–æ
            const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow.position.set(1.2, 1.8, 2.05);
            house.add(frontWindow);

            // –ë–æ–∫–æ–≤–æ–µ –æ–∫–Ω–æ
            const sideWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            sideWindow.position.set(2.05, 1.8, 0);
            house.add(sideWindow);

            // –¢—Ä—É–±–∞
            const chimneyGeometry = new THREE.BoxGeometry(0.6, 1.5, 0.6);
            const chimneyMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(-1.2, 4.5, -1.2);
            chimney.castShadow = true;
            house.add(chimney);

            scene.add(house);
        }

        function createPlayer() {
            player = new THREE.Group();

            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            player.add(body);

            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.SphereGeometry(0.25);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB3 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.45;
            head.castShadow = true;
            player.add(head);

            // –ì–ª–∞–∑–∞
            const eyeGeometry = new THREE.SphereGeometry(0.05);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.5, 0.2);
            player.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.5, 0.2);
            player.add(rightEye);

            // –†—É–∫–∏
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB3 });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.45, 0.8, 0);
            leftArm.castShadow = true;
            player.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.45, 0.8, 0);
            rightArm.castShadow = true;
            player.add(rightArm);

            // –ù–æ–≥–∏
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, -0.4, 0);
            leftLeg.castShadow = true;
            player.add(leftLeg);
            player.userData.leftLeg = leftLeg;

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, -0.4, 0);
            rightLeg.castShadow = true;
            player.add(rightLeg);
            player.userData.rightLeg = rightLeg;

            player.position.copy(playerPosition);
            scene.add(player);
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(30, 30);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createTrees() {
            for (let i = 0; i < 8; i++) {
                const tree = new THREE.Group();

                // –°—Ç–≤–æ–ª
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1;
                trunk.castShadow = true;
                tree.add(trunk);

                // –ö—Ä–æ–Ω–∞
                const foliageGeometry = new THREE.SphereGeometry(1.2);
                const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = 2.5;
                foliage.castShadow = true;
                tree.add(foliage);

                // –°–ª—É—á–∞–π–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ
                const angle = (i / 8) * Math.PI * 2;
                const distance = 8 + Math.random() * 5;
                tree.position.x = Math.cos(angle) * distance;
                tree.position.z = Math.sin(angle) * distance;
                tree.scale.setScalar(0.8 + Math.random() * 0.4);

                scene.add(tree);
            }
        }

        function createSmokeParticles() {
            const particleGeometry = new THREE.SphereGeometry(0.1);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0xDDDDDD,
                transparent: true,
                opacity: 0.6
            });

            for (let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(-1.2, 5.2 + i * 0.3, -1.2);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.02
                    ),
                    life: Math.random()
                };
                particles.push(particle);
                scene.add(particle);
            }
        }

        function setupLighting() {
            // –û—Å–Ω–æ–≤–Ω–æ–π —Å–≤–µ—Ç
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–≤–µ—Ç (—Å–æ–ª–Ω—Ü–µ)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
        }

        function setupControls() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            renderer.domElement.addEventListener('click', toggleDayNight);
            window.addEventListener('resize', onWindowResize);

            // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
        }

        function onKeyDown(event) {
            keys[event.code] = true;
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX));

                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onWheel(event) {
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(3, Math.min(20, cameraDistance));
        }

        function toggleDayNight() {
            isDayTime = !isDayTime;

            if (isDayTime) {
                scene.fog.color.setHex(0x87CEEB);
                renderer.setClearColor(0x87CEEB);
            } else {
                scene.fog.color.setHex(0x000033);
                renderer.setClearColor(0x000033);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            updatePlayer();

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫–∞–º–µ—Ä—ã –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∏–≥—Ä–æ–∫–∞
            const cameraOffset = new THREE.Vector3(
                Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance,
                Math.sin(cameraAngleX) * cameraDistance + 3,
                Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance
            );

            camera.position.copy(playerPosition).add(cameraOffset);
            camera.lookAt(playerPosition.x, playerPosition.y + 1, playerPosition.z);

            // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü –¥—ã–º–∞
            particles.forEach(particle => {
                particle.position.add(particle.userData.velocity);
                particle.userData.life += 0.01;

                if (particle.userData.life > 1 || particle.position.y > 15) {
                    particle.position.set(-1.2, 5.2, -1.2);
                    particle.userData.life = 0;
                    particle.userData.velocity.set(
                        (Math.random() - 0.5) * 0.02,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.02
                    );
                }

                particle.material.opacity = 0.6 * (1 - particle.userData.life);
            });

            // –õ–µ–≥–∫–æ–µ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ –¥–æ–º–∞
            house.rotation.y = Math.sin(Date.now() * 0.0005) * 0.02;

            renderer.render(scene, camera);
        }

        function updatePlayer() {
            let isMoving = false;
            const speed = keys['ShiftLeft'] || keys['ShiftRight'] ? 0.15 : 0.08;
            const newPosition = playerPosition.clone();

            // –î–≤–∏–∂–µ–Ω–∏–µ
            if (keys['KeyW'] || keys['ArrowUp']) {
                newPosition.z -= speed;
                playerRotation = 0;
                isMoving = true;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                newPosition.z += speed;
                playerRotation = Math.PI;
                isMoving = true;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                newPosition.x -= speed;
                playerRotation = Math.PI / 2;
                isMoving = true;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                newPosition.x += speed;
                playerRotation = -Math.PI / 2;
                isMoving = true;
            }

            // –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
            if ((keys['KeyW'] || keys['ArrowUp']) && (keys['KeyA'] || keys['ArrowLeft'])) {
                playerRotation = Math.PI / 4;
            }
            if ((keys['KeyW'] || keys['ArrowUp']) && (keys['KeyD'] || keys['ArrowRight'])) {
                playerRotation = -Math.PI / 4;
            }
            if ((keys['KeyS'] || keys['ArrowDown']) && (keys['KeyA'] || keys['ArrowLeft'])) {
                playerRotation = 3 * Math.PI / 4;
            }
            if ((keys['KeyS'] || keys['ArrowDown']) && (keys['KeyD'] || keys['ArrowRight'])) {
                playerRotation = -3 * Math.PI / 4;
            }

            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –ø–æ –≥—Ä–∞–Ω–∏—Ü–∞–º
            newPosition.x = Math.max(-12, Math.min(12, newPosition.x));
            newPosition.z = Math.max(-12, Math.min(12, newPosition.z));

            playerPosition.copy(newPosition);
            player.position.copy(playerPosition);
            player.rotation.y = playerRotation;

            // –ê–Ω–∏–º–∞—Ü–∏—è —Ö–æ–¥—å–±—ã
            if (isMoving) {
                walkAnimation += 0.2;
                if (player.userData.leftLeg && player.userData.rightLeg) {
                    player.userData.leftLeg.rotation.x = Math.sin(walkAnimation) * 0.3;
                    player.userData.rightLeg.rotation.x = -Math.sin(walkAnimation) * 0.3;
                }
            } else {
                if (player.userData.leftLeg && player.userData.rightLeg) {
                    player.userData.leftLeg.rotation.x = 0;
                    player.userData.rightLeg.rotation.x = 0;
                }
            }
        }

        init();
    </script>
</body>
</html>